import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-IKJM6GHQ.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl2) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K2[i * 2];
            l = K2[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/js-sha512/src/sha512.js
var require_sha512 = __commonJS({
  "node_modules/js-sha512/src/sha512.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW2 = typeof window === "object";
      var root2 = WINDOW2 ? window : {};
      if (root2.JS_SHA512_NO_WINDOW) {
        WINDOW2 = false;
      }
      var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
      var NODE_JS2 = !root2.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      } else if (WEB_WORKER2) {
        root2 = self;
      }
      var COMMON_JS2 = !root2.JS_SHA512_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var ARRAY_BUFFER2 = !root2.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var EXTRA2 = [-2147483648, 8388608, 32768, 128];
      var SHIFT2 = [24, 16, 8, 0];
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES2 = ["hex", "array", "digest", "arrayBuffer"];
      var blocks2 = [];
      if (root2.JS_SHA512_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER2 && (root2.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod2 = function(outputType, bits) {
        return function(message) {
          return new Sha512(bits, true).update(message)[outputType]();
        };
      };
      var createMethod2 = function(bits) {
        var method2 = createOutputMethod2("hex", bits);
        method2.create = function() {
          return new Sha512(bits);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
          var type = OUTPUT_TYPES2[i];
          method2[type] = createOutputMethod2(type, bits);
        }
        return method2;
      };
      var createHmacOutputMethod2 = function(outputType, bits) {
        return function(key, message) {
          return new HmacSha512(key, bits, true).update(message)[outputType]();
        };
      };
      var createHmacMethod2 = function(bits) {
        var method2 = createHmacOutputMethod2("hex", bits);
        method2.create = function(key) {
          return new HmacSha512(key, bits);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
          var type = OUTPUT_TYPES2[i];
          method2[type] = createHmacOutputMethod2(type, bits);
        }
        return method2;
      };
      function Sha512(bits, sharedMemory) {
        if (sharedMemory) {
          blocks2[0] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          this.blocks = blocks2;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks3 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks3[0] = this.block;
            blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = blocks3[16] = blocks3[17] = blocks3[18] = blocks3[19] = blocks3[20] = blocks3[21] = blocks3[22] = blocks3[23] = blocks3[24] = blocks3[25] = blocks3[26] = blocks3[27] = blocks3[28] = blocks3[29] = blocks3[30] = blocks3[31] = blocks3[32] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 128; ++index) {
              blocks3[i >> 2] |= message[index] << SHIFT2[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 128; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks3[i >> 2] |= code << SHIFT2[i++ & 3];
              } else if (code < 2048) {
                blocks3[i >> 2] |= (192 | code >> 6) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks3[i >> 2] |= (224 | code >> 12) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks3[i >> 2] |= (240 | code >> 18) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 128) {
            this.block = blocks3[32];
            this.start = i - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks3 = this.blocks, i = this.lastByteIndex;
        blocks3[32] = this.block;
        blocks3[i >> 2] |= EXTRA2[i & 3];
        this.block = blocks3[32];
        if (i >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks3[0] = this.block;
          blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = blocks3[16] = blocks3[17] = blocks3[18] = blocks3[19] = blocks3[20] = blocks3[21] = blocks3[22] = blocks3[23] = blocks3[24] = blocks3[25] = blocks3[26] = blocks3[27] = blocks3[28] = blocks3[29] = blocks3[30] = blocks3[31] = blocks3[32] = 0;
        }
        blocks3[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks3[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks3 = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j = 32; j < 160; j += 2) {
          t1h = blocks3[j - 30];
          t1l = blocks3[j - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks3[j - 4];
          t1l = blocks3[j - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks3[j - 32];
          t1l = blocks3[j - 31];
          t2h = blocks3[j - 14];
          t2l = blocks3[j - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks3[j] = c4 << 16 | c3 & 65535;
          blocks3[j + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j = 0; j < 160; j += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks3[j];
          t1l = blocks3[j + 1];
          t2h = K2[j];
          t2l = K2[j + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks3[j + 2];
          t1l = blocks3[j + 3];
          t2h = K2[j + 2];
          t2l = K2[j + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks3[j + 4];
          t1l = blocks3[j + 5];
          t2h = K2[j + 4];
          t2l = K2[j + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks3[j + 6];
          t1l = blocks3[j + 7];
          t2h = K2[j + 6];
          t2l = K2[j + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var hex = HEX_CHARS2[h0h >> 28 & 15] + HEX_CHARS2[h0h >> 24 & 15] + HEX_CHARS2[h0h >> 20 & 15] + HEX_CHARS2[h0h >> 16 & 15] + HEX_CHARS2[h0h >> 12 & 15] + HEX_CHARS2[h0h >> 8 & 15] + HEX_CHARS2[h0h >> 4 & 15] + HEX_CHARS2[h0h & 15] + HEX_CHARS2[h0l >> 28 & 15] + HEX_CHARS2[h0l >> 24 & 15] + HEX_CHARS2[h0l >> 20 & 15] + HEX_CHARS2[h0l >> 16 & 15] + HEX_CHARS2[h0l >> 12 & 15] + HEX_CHARS2[h0l >> 8 & 15] + HEX_CHARS2[h0l >> 4 & 15] + HEX_CHARS2[h0l & 15] + HEX_CHARS2[h1h >> 28 & 15] + HEX_CHARS2[h1h >> 24 & 15] + HEX_CHARS2[h1h >> 20 & 15] + HEX_CHARS2[h1h >> 16 & 15] + HEX_CHARS2[h1h >> 12 & 15] + HEX_CHARS2[h1h >> 8 & 15] + HEX_CHARS2[h1h >> 4 & 15] + HEX_CHARS2[h1h & 15] + HEX_CHARS2[h1l >> 28 & 15] + HEX_CHARS2[h1l >> 24 & 15] + HEX_CHARS2[h1l >> 20 & 15] + HEX_CHARS2[h1l >> 16 & 15] + HEX_CHARS2[h1l >> 12 & 15] + HEX_CHARS2[h1l >> 8 & 15] + HEX_CHARS2[h1l >> 4 & 15] + HEX_CHARS2[h1l & 15] + HEX_CHARS2[h2h >> 28 & 15] + HEX_CHARS2[h2h >> 24 & 15] + HEX_CHARS2[h2h >> 20 & 15] + HEX_CHARS2[h2h >> 16 & 15] + HEX_CHARS2[h2h >> 12 & 15] + HEX_CHARS2[h2h >> 8 & 15] + HEX_CHARS2[h2h >> 4 & 15] + HEX_CHARS2[h2h & 15] + HEX_CHARS2[h2l >> 28 & 15] + HEX_CHARS2[h2l >> 24 & 15] + HEX_CHARS2[h2l >> 20 & 15] + HEX_CHARS2[h2l >> 16 & 15] + HEX_CHARS2[h2l >> 12 & 15] + HEX_CHARS2[h2l >> 8 & 15] + HEX_CHARS2[h2l >> 4 & 15] + HEX_CHARS2[h2l & 15] + HEX_CHARS2[h3h >> 28 & 15] + HEX_CHARS2[h3h >> 24 & 15] + HEX_CHARS2[h3h >> 20 & 15] + HEX_CHARS2[h3h >> 16 & 15] + HEX_CHARS2[h3h >> 12 & 15] + HEX_CHARS2[h3h >> 8 & 15] + HEX_CHARS2[h3h >> 4 & 15] + HEX_CHARS2[h3h & 15];
        if (bits >= 256) {
          hex += HEX_CHARS2[h3l >> 28 & 15] + HEX_CHARS2[h3l >> 24 & 15] + HEX_CHARS2[h3l >> 20 & 15] + HEX_CHARS2[h3l >> 16 & 15] + HEX_CHARS2[h3l >> 12 & 15] + HEX_CHARS2[h3l >> 8 & 15] + HEX_CHARS2[h3l >> 4 & 15] + HEX_CHARS2[h3l & 15];
        }
        if (bits >= 384) {
          hex += HEX_CHARS2[h4h >> 28 & 15] + HEX_CHARS2[h4h >> 24 & 15] + HEX_CHARS2[h4h >> 20 & 15] + HEX_CHARS2[h4h >> 16 & 15] + HEX_CHARS2[h4h >> 12 & 15] + HEX_CHARS2[h4h >> 8 & 15] + HEX_CHARS2[h4h >> 4 & 15] + HEX_CHARS2[h4h & 15] + HEX_CHARS2[h4l >> 28 & 15] + HEX_CHARS2[h4l >> 24 & 15] + HEX_CHARS2[h4l >> 20 & 15] + HEX_CHARS2[h4l >> 16 & 15] + HEX_CHARS2[h4l >> 12 & 15] + HEX_CHARS2[h4l >> 8 & 15] + HEX_CHARS2[h4l >> 4 & 15] + HEX_CHARS2[h4l & 15] + HEX_CHARS2[h5h >> 28 & 15] + HEX_CHARS2[h5h >> 24 & 15] + HEX_CHARS2[h5h >> 20 & 15] + HEX_CHARS2[h5h >> 16 & 15] + HEX_CHARS2[h5h >> 12 & 15] + HEX_CHARS2[h5h >> 8 & 15] + HEX_CHARS2[h5h >> 4 & 15] + HEX_CHARS2[h5h & 15] + HEX_CHARS2[h5l >> 28 & 15] + HEX_CHARS2[h5l >> 24 & 15] + HEX_CHARS2[h5l >> 20 & 15] + HEX_CHARS2[h5l >> 16 & 15] + HEX_CHARS2[h5l >> 12 & 15] + HEX_CHARS2[h5l >> 8 & 15] + HEX_CHARS2[h5l >> 4 & 15] + HEX_CHARS2[h5l & 15];
        }
        if (bits == 512) {
          hex += HEX_CHARS2[h6h >> 28 & 15] + HEX_CHARS2[h6h >> 24 & 15] + HEX_CHARS2[h6h >> 20 & 15] + HEX_CHARS2[h6h >> 16 & 15] + HEX_CHARS2[h6h >> 12 & 15] + HEX_CHARS2[h6h >> 8 & 15] + HEX_CHARS2[h6h >> 4 & 15] + HEX_CHARS2[h6h & 15] + HEX_CHARS2[h6l >> 28 & 15] + HEX_CHARS2[h6l >> 24 & 15] + HEX_CHARS2[h6l >> 20 & 15] + HEX_CHARS2[h6l >> 16 & 15] + HEX_CHARS2[h6l >> 12 & 15] + HEX_CHARS2[h6l >> 8 & 15] + HEX_CHARS2[h6l >> 4 & 15] + HEX_CHARS2[h6l & 15] + HEX_CHARS2[h7h >> 28 & 15] + HEX_CHARS2[h7h >> 24 & 15] + HEX_CHARS2[h7h >> 20 & 15] + HEX_CHARS2[h7h >> 16 & 15] + HEX_CHARS2[h7h >> 12 & 15] + HEX_CHARS2[h7h >> 8 & 15] + HEX_CHARS2[h7h >> 4 & 15] + HEX_CHARS2[h7h & 15] + HEX_CHARS2[h7l >> 28 & 15] + HEX_CHARS2[h7l >> 24 & 15] + HEX_CHARS2[h7l >> 20 & 15] + HEX_CHARS2[h7l >> 16 & 15] + HEX_CHARS2[h7l >> 12 & 15] + HEX_CHARS2[h7l >> 8 & 15] + HEX_CHARS2[h7l >> 4 & 15] + HEX_CHARS2[h7l & 15];
        }
        return hex;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var arr = [
          h0h >> 24 & 255,
          h0h >> 16 & 255,
          h0h >> 8 & 255,
          h0h & 255,
          h0l >> 24 & 255,
          h0l >> 16 & 255,
          h0l >> 8 & 255,
          h0l & 255,
          h1h >> 24 & 255,
          h1h >> 16 & 255,
          h1h >> 8 & 255,
          h1h & 255,
          h1l >> 24 & 255,
          h1l >> 16 & 255,
          h1l >> 8 & 255,
          h1l & 255,
          h2h >> 24 & 255,
          h2h >> 16 & 255,
          h2h >> 8 & 255,
          h2h & 255,
          h2l >> 24 & 255,
          h2l >> 16 & 255,
          h2l >> 8 & 255,
          h2l & 255,
          h3h >> 24 & 255,
          h3h >> 16 & 255,
          h3h >> 8 & 255,
          h3h & 255
        ];
        if (bits >= 256) {
          arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
        }
        if (bits >= 384) {
          arr.push(
            h4h >> 24 & 255,
            h4h >> 16 & 255,
            h4h >> 8 & 255,
            h4h & 255,
            h4l >> 24 & 255,
            h4l >> 16 & 255,
            h4l >> 8 & 255,
            h4l & 255,
            h5h >> 24 & 255,
            h5h >> 16 & 255,
            h5h >> 8 & 255,
            h5h & 255,
            h5l >> 24 & 255,
            h5l >> 16 & 255,
            h5l >> 8 & 255,
            h5l & 255
          );
        }
        if (bits == 512) {
          arr.push(
            h6h >> 24 & 255,
            h6h >> 16 & 255,
            h6h >> 8 & 255,
            h6h & 255,
            h6l >> 24 & 255,
            h6l >> 16 & 255,
            h6l >> 8 & 255,
            h6l & 255,
            h7h >> 24 & 255,
            h7h >> 16 & 255,
            h7h >> 8 & 255,
            h7h & 255,
            h7l >> 24 & 255,
            h7l >> 16 & 255,
            h7l >> 8 & 255,
            h7l & 255
          );
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits = this.bits;
        var buffer = new ArrayBuffer(bits / 8);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0h);
        dataView.setUint32(4, this.h0l);
        dataView.setUint32(8, this.h1h);
        dataView.setUint32(12, this.h1l);
        dataView.setUint32(16, this.h2h);
        dataView.setUint32(20, this.h2l);
        dataView.setUint32(24, this.h3h);
        if (bits >= 256) {
          dataView.setUint32(28, this.h3l);
        }
        if (bits >= 384) {
          dataView.setUint32(32, this.h4h);
          dataView.setUint32(36, this.h4l);
          dataView.setUint32(40, this.h5h);
          dataView.setUint32(44, this.h5l);
        }
        if (bits == 512) {
          dataView.setUint32(48, this.h6h);
          dataView.setUint32(52, this.h6l);
          dataView.setUint32(56, this.h7h);
          dataView.setUint32(60, this.h7l);
        }
        return buffer;
      };
      Sha512.prototype.clone = function() {
        var hash = new Sha512(this.bits, false);
        this.copyTo(hash);
        return hash;
      };
      Sha512.prototype.copyTo = function(hash) {
        var i = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i = 0; i < attrs.length; ++i) {
          hash[attrs[i]] = this[attrs[i]];
        }
        for (i = 0; i < this.blocks.length; ++i) {
          hash.blocks[i] = this.blocks[i];
        }
      };
      function HmacSha512(key, bits, sharedMemory) {
        var notString, type = typeof key;
        if (type !== "string") {
          if (type === "object") {
            if (key === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(key)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var length = key.length;
        if (!notString) {
          var bytes = [], length = key.length, index = 0, code;
          for (var i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 128) {
          key = new Sha512(bits, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i = 0; i < 128; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha512.call(this, bits, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash = new HmacSha512([], this.bits, false);
        this.copyTo(hash);
        hash.inner = this.inner;
        for (var i = 0; i < this.oKeyPad.length; ++i) {
          hash.oKeyPad[i] = this.oKeyPad[i];
        }
        return hash;
      };
      var exports3 = createMethod2(512);
      exports3.sha512 = exports3;
      exports3.sha384 = createMethod2(384);
      exports3.sha512_256 = createMethod2(256);
      exports3.sha512_224 = createMethod2(224);
      exports3.sha512.hmac = createHmacMethod2(512);
      exports3.sha384.hmac = createHmacMethod2(384);
      exports3.sha512_256.hmac = createHmacMethod2(256);
      exports3.sha512_224.hmac = createHmacMethod2(224);
      if (COMMON_JS2) {
        module2.exports = exports3;
      } else {
        root2.sha512 = exports3.sha512;
        root2.sha384 = exports3.sha384;
        root2.sha512_256 = exports3.sha512_256;
        root2.sha512_224 = exports3.sha512_224;
        if (AMD2) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/algosdk/dist/esm/src/nacl/naclWrappers.js
var naclWrappers_exports = {};
__export(naclWrappers_exports, {
  HASH_BYTES_LENGTH: () => HASH_BYTES_LENGTH,
  PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
  SECRET_KEY_LENGTH: () => SECRET_KEY_LENGTH,
  SEED_BTYES_LENGTH: () => SEED_BTYES_LENGTH,
  bytesEqual: () => bytesEqual,
  genericHash: () => genericHash,
  isValidSignatureLength: () => isValidSignatureLength,
  keyPair: () => keyPair,
  keyPairFromSecretKey: () => keyPairFromSecretKey,
  keyPairFromSeed: () => keyPairFromSeed,
  randomBytes: () => randomBytes,
  sign: () => sign,
  verify: () => verify
});
function genericHash(arr) {
  return import_js_sha512.default.sha512_256.array(arr);
}
function randomBytes(length) {
  return import_tweetnacl.default.randomBytes(length);
}
function keyPairFromSeed(seed) {
  return import_tweetnacl.default.sign.keyPair.fromSeed(seed);
}
function keyPair() {
  const seed = randomBytes(import_tweetnacl.default.box.secretKeyLength);
  return keyPairFromSeed(seed);
}
function isValidSignatureLength(len) {
  return len === import_tweetnacl.default.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return import_tweetnacl.default.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return import_tweetnacl.default.sign.detached(msg, secretKey);
}
function bytesEqual(a, b) {
  return import_tweetnacl.default.verify(a, b);
}
function verify(message, signature, verifyKey) {
  return import_tweetnacl.default.sign.detached.verify(message, signature, verifyKey);
}
var import_tweetnacl, import_js_sha512, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, HASH_BYTES_LENGTH, SEED_BTYES_LENGTH;
var init_naclWrappers = __esm({
  "node_modules/algosdk/dist/esm/src/nacl/naclWrappers.js"() {
    import_tweetnacl = __toESM(require_nacl_fast());
    import_js_sha512 = __toESM(require_sha512());
    PUBLIC_KEY_LENGTH = import_tweetnacl.default.sign.publicKeyLength;
    SECRET_KEY_LENGTH = import_tweetnacl.default.sign.secretKeyLength;
    HASH_BYTES_LENGTH = 32;
    SEED_BTYES_LENGTH = 32;
  }
});

// node_modules/hi-base32/src/base32.js
var require_base32 = __commonJS({
  "node_modules/hi-base32/src/base32.js"(exports2, module2) {
    (function() {
      "use strict";
      var root2 = typeof window === "object" ? window : {};
      var NODE_JS2 = !root2.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      }
      var COMMON_JS2 = !root2.HI_BASE32_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks2 = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes) {
        var str = "", length = bytes.length, i = 0, followingChars = 0, b, c;
        while (i < length) {
          b = bytes[i++];
          if (b <= 127) {
            str += String.fromCharCode(b);
            continue;
          } else if (b > 191 && b <= 223) {
            c = b & 31;
            followingChars = 1;
          } else if (b <= 239) {
            c = b & 15;
            followingChars = 2;
          } else if (b <= 247) {
            c = b & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i, str);
          }
          for (var j = 0; j < followingChars; ++j) {
            b = bytes[i++];
            if (b < 128 || b > 191) {
              throwInvalidUtf8(i, str);
            }
            c <<= 6;
            c += b & 63;
          }
          if (c >= 55296 && c <= 57343) {
            throwInvalidUtf8(i, str);
          }
          if (c > 1114111) {
            throwInvalidUtf8(i, str);
          }
          if (c <= 65535) {
            str += String.fromCharCode(c);
          } else {
            c -= 65536;
            str += String.fromCharCode((c >> 10) + 55296);
            str += String.fromCharCode((c & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
        for (var i = 0, count = length >> 3 << 3; i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          bytes[index++] = (v7 << 5 | v8) & 255;
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
        for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v4 = str.charCodeAt(i++);
          v5 = str.charCodeAt(i++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v4 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v4, v5, code, end = false, base32Str = "", index = 0, i, start = 0, bytes = 0, length = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks2[0] = blocks2[5];
          blocks2[1] = blocks2[6];
          blocks2[2] = blocks2[7];
          for (i = start; index < length && i < 5; ++index) {
            code = str.charCodeAt(index);
            if (code < 128) {
              blocks2[i++] = code;
            } else if (code < 2048) {
              blocks2[i++] = 192 | code >> 6;
              blocks2[i++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              blocks2[i++] = 224 | code >> 12;
              blocks2[i++] = 128 | code >> 6 & 63;
              blocks2[i++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
              blocks2[i++] = 240 | code >> 18;
              blocks2[i++] = 128 | code >> 12 & 63;
              blocks2[i++] = 128 | code >> 6 & 63;
              blocks2[i++] = 128 | code & 63;
            }
          }
          bytes += i - start;
          start = i - 5;
          if (index === length) {
            ++index;
          }
          if (index > length && i < 6) {
            end = true;
          }
          v1 = blocks2[0];
          if (i > 4) {
            v2 = blocks2[1];
            v3 = blocks2[2];
            v4 = blocks2[3];
            v5 = blocks2[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i === 2) {
            v2 = blocks2[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i === 3) {
            v2 = blocks2[1];
            v3 = blocks2[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks2[1];
            v3 = blocks2[2];
            v4 = blocks2[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes) {
        var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
        for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          v4 = bytes[i++];
          v5 = bytes[i++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i++];
          v2 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          v4 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode3 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode4 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
        if (length === -1) {
          length = base32Str.length;
        }
        for (var i = 0, count = length >> 3 << 3; i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports3 = {
        encode: encode3,
        decode: decode4
      };
      decode4.asBytes = decodeAsBytes;
      if (COMMON_JS2) {
        module2.exports = exports3;
      } else {
        root2.base32 = exports3;
        if (AMD2) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method2) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method2.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        storeAsString: false,
        alwaysParseAsBig: false,
        useNativeBigInt: false,
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null)
            BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt)
                string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt)
                string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// node_modules/algosdk/dist/esm/src/types/intDecoding.js
var IntDecoding, intDecoding_default;
var init_intDecoding = __esm({
  "node_modules/algosdk/dist/esm/src/types/intDecoding.js"() {
    (function(IntDecoding2) {
      IntDecoding2["DEFAULT"] = "default";
      IntDecoding2["SAFE"] = "safe";
      IntDecoding2["MIXED"] = "mixed";
      IntDecoding2["BIGINT"] = "bigint";
    })(IntDecoding || (IntDecoding = {}));
    intDecoding_default = IntDecoding;
  }
});

// node_modules/algosdk/dist/esm/src/utils/utils.js
var utils_exports = {};
__export(utils_exports, {
  arrayEqual: () => arrayEqual,
  concatArrays: () => concatArrays,
  isNode: () => isNode,
  parseJSON: () => parseJSON,
  removeUndefinedProperties: () => removeUndefinedProperties
});
function parseJSON(str, options) {
  const intDecoding = options && options.intDecoding ? options.intDecoding : intDecoding_default.DEFAULT;
  return JSONbig.parse(str, (_, value) => {
    if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
      Object.setPrototypeOf(value, Object.prototype);
    }
    if (typeof value === "bigint") {
      if (intDecoding === "safe" && value > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (intDecoding === "bigint" || intDecoding === "mixed" && value > Number.MAX_SAFE_INTEGER) {
        return value;
      }
      return Number(value);
    }
    if (typeof value === "number") {
      if (intDecoding === "bigint" && Number.isInteger(value)) {
        return BigInt(value);
      }
    }
    return value;
  });
}
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return Array.from(a).every((val, i) => val === b[i]);
}
function concatArrays(...arrs) {
  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c = new Uint8Array(size);
  let offset = 0;
  for (let i = 0; i < arrs.length; i++) {
    c.set(arrs[i], offset);
    offset += arrs[i].length;
  }
  return c;
}
function removeUndefinedProperties(obj) {
  const mutableCopy = { ...obj };
  Object.keys(mutableCopy).forEach((key) => {
    if (typeof mutableCopy[key] === "undefined")
      delete mutableCopy[key];
  });
  return mutableCopy;
}
function isNode() {
  return typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node !== "undefined";
}
var import_json_bigint, JSONbig;
var init_utils = __esm({
  "node_modules/algosdk/dist/esm/src/utils/utils.js"() {
    import_json_bigint = __toESM(require_json_bigint());
    init_intDecoding();
    JSONbig = (0, import_json_bigint.default)({ useNativeBigInt: true, strict: true });
  }
});

// node_modules/algosdk/dist/esm/src/encoding/uint64.js
function encodeUint64(num) {
  const isInteger = typeof num === "bigint" || Number.isInteger(num);
  if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
    throw new Error("Input is not a 64-bit unsigned integer");
  }
  const buf = Buffer.allocUnsafe(8);
  buf.writeBigUInt64BE(BigInt(num));
  return new Uint8Array(buf);
}
function decodeUint64(data, decodingMode = "safe") {
  if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
    throw new Error(`Unknown decodingMode option: ${decodingMode}`);
  }
  if (data.byteLength === 0 || data.byteLength > 8) {
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
  }
  const padding = Buffer.allocUnsafe(8 - data.byteLength);
  padding.fill(0);
  const buf = Buffer.concat([padding, Buffer.from(data)]);
  const num = buf.readBigUInt64BE();
  const isBig = num > Number.MAX_SAFE_INTEGER;
  if (decodingMode === "safe") {
    if (isBig) {
      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    }
    return Number(num);
  }
  if (decodingMode === "mixed" && !isBig) {
    return Number(num);
  }
  return num;
}
var init_uint64 = __esm({
  "node_modules/algosdk/dist/esm/src/encoding/uint64.js"() {
  }
});

// node_modules/algosdk/dist/esm/src/encoding/address.js
var address_exports = {};
__export(address_exports, {
  ALGORAND_ZERO_ADDRESS_STRING: () => ALGORAND_ZERO_ADDRESS_STRING,
  CHECKSUM_ADDRESS_ERROR_MSG: () => CHECKSUM_ADDRESS_ERROR_MSG,
  INVALID_MSIG_PK_ERROR_MSG: () => INVALID_MSIG_PK_ERROR_MSG,
  INVALID_MSIG_THRESHOLD_ERROR_MSG: () => INVALID_MSIG_THRESHOLD_ERROR_MSG,
  INVALID_MSIG_VERSION_ERROR_MSG: () => INVALID_MSIG_VERSION_ERROR_MSG,
  MALFORMED_ADDRESS_ERROR_MSG: () => MALFORMED_ADDRESS_ERROR_MSG,
  UNEXPECTED_PK_LEN_ERROR_MSG: () => UNEXPECTED_PK_LEN_ERROR_MSG,
  decodeAddress: () => decodeAddress,
  encodeAddress: () => encodeAddress,
  fromMultisigPreImg: () => fromMultisigPreImg,
  fromMultisigPreImgAddrs: () => fromMultisigPreImgAddrs,
  getApplicationAddress: () => getApplicationAddress,
  isValidAddress: () => isValidAddress
});
function decodeAddress(address) {
  if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const decoded = import_hi_base32.default.decode.asBytes(address.toString());
  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
  const checksum = genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH);
  if (!arrayEqual(checksum, cs))
    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
  return { publicKey: pk, checksum: cs };
}
function isValidAddress(address) {
  try {
    decodeAddress(address);
  } catch (e) {
    return false;
  }
  return true;
}
function encodeAddress(address) {
  const checksum = genericHash(address).slice(PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, PUBLIC_KEY_LENGTH);
  const addr = import_hi_base32.default.encode(concatArrays(address, checksum));
  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
}
function fromMultisigPreImg({ version, threshold, pks }) {
  if (version !== 1 || version > 255 || version < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i = 0; i < pks.length; i++) {
    if (pks[i].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
  }
  return new Uint8Array(genericHash(merged));
}
function fromMultisigPreImgAddrs({ version, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  return encodeAddress(fromMultisigPreImg({ version, threshold, pks }));
}
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
  const hash = genericHash(toBeSigned);
  return encodeAddress(new Uint8Array(hash));
}
var import_hi_base32, ALGORAND_ADDRESS_BYTE_LENGTH, ALGORAND_CHECKSUM_BYTE_LENGTH, ALGORAND_ADDRESS_LENGTH, ALGORAND_ZERO_ADDRESS_STRING, MULTISIG_PREIMG2ADDR_PREFIX, APP_ID_PREFIX, MALFORMED_ADDRESS_ERROR_MSG, CHECKSUM_ADDRESS_ERROR_MSG, INVALID_MSIG_VERSION_ERROR_MSG, INVALID_MSIG_THRESHOLD_ERROR_MSG, INVALID_MSIG_PK_ERROR_MSG, UNEXPECTED_PK_LEN_ERROR_MSG;
var init_address = __esm({
  "node_modules/algosdk/dist/esm/src/encoding/address.js"() {
    import_hi_base32 = __toESM(require_base32());
    init_naclWrappers();
    init_utils();
    init_uint64();
    ALGORAND_ADDRESS_BYTE_LENGTH = 36;
    ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
    ALGORAND_ADDRESS_LENGTH = 58;
    ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
    MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
      77,
      117,
      108,
      116,
      105,
      115,
      105,
      103,
      65,
      100,
      100,
      114
    ]);
    APP_ID_PREFIX = Buffer.from("appID");
    MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
    CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
    INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
    INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
    INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
    UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
  }
});

// node_modules/algo-msgpack-with-bigint/dist.es5/msgpack.min.js
var require_msgpack_min = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist.es5/msgpack.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports2 ? exports2.MessagePack = e() : t.MessagePack = e();
    }(exports2, function() {
      return function(t) {
        var e = {};
        function r(n) {
          if (e[n])
            return e[n].exports;
          var i = e[n] = { i: n, l: false, exports: {} };
          return t[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
        }
        return r.m = t, r.c = e, r.d = function(t2, e2, n) {
          r.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
        }, r.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, r.t = function(t2, e2) {
          if (1 & e2 && (t2 = r(t2)), 8 & e2)
            return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
            return t2;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
            for (var i in t2)
              r.d(n, i, function(e3) {
                return t2[e3];
              }.bind(null, i));
          return n;
        }, r.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return r.d(e2, "a", e2), e2;
        }, r.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, r.p = "", r(r.s = 0);
      }([function(t, e, r) {
        "use strict";
        r.r(e), r.d(e, "encode", function() {
          return T;
        }), r.d(e, "decode", function() {
          return V;
        }), r.d(e, "decodeAsync", function() {
          return Y;
        }), r.d(e, "decodeArrayStream", function() {
          return Z;
        }), r.d(e, "decodeStream", function() {
          return $;
        }), r.d(e, "Decoder", function() {
          return O;
        }), r.d(e, "Encoder", function() {
          return I;
        }), r.d(e, "ExtensionCodec", function() {
          return S;
        }), r.d(e, "ExtData", function() {
          return p;
        }), r.d(e, "EXT_TIMESTAMP", function() {
          return w;
        }), r.d(e, "encodeDateToTimeSpec", function() {
          return g;
        }), r.d(e, "encodeTimeSpecToTimestamp", function() {
          return v;
        }), r.d(e, "decodeTimestampToTimeSpec", function() {
          return U;
        }), r.d(e, "encodeTimestampExtension", function() {
          return b;
        }), r.d(e, "decodeTimestampExtension", function() {
          return m;
        });
        var n = function(t2, e2) {
          var r2 = "function" == typeof Symbol && t2[Symbol.iterator];
          if (!r2)
            return t2;
          var n2, i2, o2 = r2.call(t2), s2 = [];
          try {
            for (; (void 0 === e2 || e2-- > 0) && !(n2 = o2.next()).done; )
              s2.push(n2.value);
          } catch (t3) {
            i2 = { error: t3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return s2;
        }, i = function() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2 = t2.concat(n(arguments[e2]));
          return t2;
        }, o = "undefined" != typeof process && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
        function s(t2) {
          for (var e2 = t2.length, r2 = 0, n2 = 0; n2 < e2; ) {
            var i2 = t2.charCodeAt(n2++);
            if (0 != (4294967168 & i2))
              if (0 == (4294965248 & i2))
                r2 += 2;
              else {
                if (i2 >= 55296 && i2 <= 56319 && n2 < e2) {
                  var o2 = t2.charCodeAt(n2);
                  56320 == (64512 & o2) && (++n2, i2 = ((1023 & i2) << 10) + (1023 & o2) + 65536);
                }
                r2 += 0 == (4294901760 & i2) ? 3 : 4;
              }
            else
              r2++;
          }
          return r2;
        }
        var a = o ? new TextEncoder() : void 0, h = "undefined" != typeof process ? 200 : 0;
        var u = (null == a ? void 0 : a.encodeInto) ? function(t2, e2, r2) {
          a.encodeInto(t2, e2.subarray(r2));
        } : function(t2, e2, r2) {
          e2.set(a.encode(t2), r2);
        };
        function c(t2, e2, r2) {
          for (var n2 = e2, o2 = n2 + r2, s2 = [], a2 = ""; n2 < o2; ) {
            var h2 = t2[n2++];
            if (0 == (128 & h2))
              s2.push(h2);
            else if (192 == (224 & h2)) {
              var u2 = 63 & t2[n2++];
              s2.push((31 & h2) << 6 | u2);
            } else if (224 == (240 & h2)) {
              u2 = 63 & t2[n2++];
              var c2 = 63 & t2[n2++];
              s2.push((31 & h2) << 12 | u2 << 6 | c2);
            } else if (240 == (248 & h2)) {
              var f2 = (7 & h2) << 18 | (u2 = 63 & t2[n2++]) << 12 | (c2 = 63 & t2[n2++]) << 6 | 63 & t2[n2++];
              f2 > 65535 && (f2 -= 65536, s2.push(f2 >>> 10 & 1023 | 55296), f2 = 56320 | 1023 & f2), s2.push(f2);
            } else
              s2.push(h2);
            s2.length >= 4096 && (a2 += String.fromCharCode.apply(String, i(s2)), s2.length = 0);
          }
          return s2.length > 0 && (a2 += String.fromCharCode.apply(String, i(s2))), a2;
        }
        var f = o ? new TextDecoder() : null, l = "undefined" != typeof process ? 200 : 0;
        var p = function(t2, e2) {
          this.type = t2, this.data = e2;
        };
        function d(t2, e2, r2) {
          var n2 = Math.floor(r2 / 4294967296), i2 = r2;
          t2.setUint32(e2, n2), t2.setUint32(e2 + 4, i2);
        }
        function y(t2, e2) {
          var r2 = t2.getInt32(e2), n2 = t2.getUint32(e2 + 4), i2 = r2 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r2 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n2, o2 = r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
          return i2 || o2 ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2;
        }
        var w = -1;
        function v(t2) {
          var e2 = t2.sec, r2 = t2.nsec;
          if (e2 >= 0 && r2 >= 0 && e2 <= 17179869183) {
            if (0 === r2 && e2 <= 4294967295) {
              var n2 = new Uint8Array(4);
              return (s2 = new DataView(n2.buffer)).setUint32(0, e2), n2;
            }
            var i2 = e2 / 4294967296, o2 = 4294967295 & e2;
            n2 = new Uint8Array(8);
            return (s2 = new DataView(n2.buffer)).setUint32(0, r2 << 2 | 3 & i2), s2.setUint32(4, o2), n2;
          }
          var s2;
          n2 = new Uint8Array(12);
          return (s2 = new DataView(n2.buffer)).setUint32(0, r2), d(s2, 4, e2), n2;
        }
        function g(t2) {
          var e2 = t2.getTime(), r2 = Math.floor(e2 / 1e3), n2 = 1e6 * (e2 - 1e3 * r2), i2 = Math.floor(n2 / 1e9);
          return { sec: r2 + i2, nsec: n2 - 1e9 * i2 };
        }
        function b(t2) {
          return t2 instanceof Date ? v(g(t2)) : null;
        }
        function U(t2) {
          var e2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
          switch (t2.byteLength) {
            case 4:
              return { sec: e2.getUint32(0), nsec: 0 };
            case 8:
              var r2 = e2.getUint32(0);
              return { sec: 4294967296 * (3 & r2) + e2.getUint32(4), nsec: r2 >>> 2 };
            case 12:
              return { sec: y(e2, 4), nsec: e2.getUint32(0) };
            default:
              throw new Error("Unrecognized data size for timestamp: " + t2.length);
          }
        }
        function m(t2) {
          var e2 = U(t2);
          return new Date(1e3 * e2.sec + e2.nsec / 1e6);
        }
        var x = { type: w, encode: b, decode: m }, S = function() {
          function t2() {
            this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x);
          }
          return t2.prototype.register = function(t3) {
            var e2 = t3.type, r2 = t3.encode, n2 = t3.decode;
            if (e2 >= 0)
              this.encoders[e2] = r2, this.decoders[e2] = n2;
            else {
              var i2 = 1 + e2;
              this.builtInEncoders[i2] = r2, this.builtInDecoders[i2] = n2;
            }
          }, t2.prototype.tryToEncode = function(t3, e2) {
            for (var r2 = 0; r2 < this.builtInEncoders.length; r2++) {
              if (null != (n2 = this.builtInEncoders[r2])) {
                if (null != (i2 = n2(t3, e2)))
                  return new p(-1 - r2, i2);
              }
            }
            for (r2 = 0; r2 < this.encoders.length; r2++) {
              var n2, i2;
              if (null != (n2 = this.encoders[r2])) {
                if (null != (i2 = n2(t3, e2)))
                  return new p(r2, i2);
              }
            }
            return t3 instanceof p ? t3 : null;
          }, t2.prototype.decode = function(t3, e2, r2) {
            var n2 = e2 < 0 ? this.builtInDecoders[-1 - e2] : this.decoders[e2];
            return n2 ? n2(t3, e2, r2) : new p(e2, t3);
          }, t2.defaultCodec = new t2(), t2;
        }();
        function B(t2) {
          return t2 instanceof Uint8Array ? t2 : ArrayBuffer.isView(t2) ? new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength) : t2 instanceof ArrayBuffer ? new Uint8Array(t2) : Uint8Array.from(t2);
        }
        var E = function(t2) {
          var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
          if (r2)
            return r2.call(t2);
          if (t2 && "number" == typeof t2.length)
            return { next: function() {
              return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
            } };
          throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, I = function() {
          function t2(t3, e2, r2, n2, i2, o2, s2, a2) {
            void 0 === t3 && (t3 = S.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 100), void 0 === n2 && (n2 = 2048), void 0 === i2 && (i2 = false), void 0 === o2 && (o2 = false), void 0 === s2 && (s2 = false), void 0 === a2 && (a2 = false), this.extensionCodec = t3, this.context = e2, this.maxDepth = r2, this.initialBufferSize = n2, this.sortKeys = i2, this.forceFloat32 = o2, this.ignoreUndefined = s2, this.forceIntegerToFloat = a2, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
          }
          return t2.prototype.getUint8Array = function() {
            return this.bytes.subarray(0, this.pos);
          }, t2.prototype.reinitializeState = function() {
            this.pos = 0;
          }, t2.prototype.encode = function(t3) {
            return this.reinitializeState(), this.doEncode(t3, 1), this.getUint8Array();
          }, t2.prototype.doEncode = function(t3, e2) {
            if (e2 > this.maxDepth)
              throw new Error("Too deep objects in depth " + e2);
            null == t3 ? this.encodeNil() : "boolean" == typeof t3 ? this.encodeBoolean(t3) : "number" == typeof t3 ? this.encodeNumber(t3) : "string" == typeof t3 ? this.encodeString(t3) : "bigint" == typeof t3 ? this.encodebigint(t3) : this.encodeObject(t3, e2);
          }, t2.prototype.ensureBufferSizeToWrite = function(t3) {
            var e2 = this.pos + t3;
            this.view.byteLength < e2 && this.resizeBuffer(2 * e2);
          }, t2.prototype.resizeBuffer = function(t3) {
            var e2 = new ArrayBuffer(t3), r2 = new Uint8Array(e2), n2 = new DataView(e2);
            r2.set(this.bytes), this.view = n2, this.bytes = r2;
          }, t2.prototype.encodeNil = function() {
            this.writeU8(192);
          }, t2.prototype.encodeBoolean = function(t3) {
            false === t3 ? this.writeU8(194) : this.writeU8(195);
          }, t2.prototype.encodeNumber = function(t3) {
            Number.isSafeInteger(t3) && !this.forceIntegerToFloat ? t3 >= 0 ? t3 < 128 ? this.writeU8(t3) : t3 < 256 ? (this.writeU8(204), this.writeU8(t3)) : t3 < 65536 ? (this.writeU8(205), this.writeU16(t3)) : t3 < 4294967296 ? (this.writeU8(206), this.writeU32(t3)) : (this.writeU8(207), this.writeU64(t3)) : t3 >= -32 ? this.writeU8(224 | t3 + 32) : t3 >= -128 ? (this.writeU8(208), this.writeI8(t3)) : t3 >= -32768 ? (this.writeU8(209), this.writeI16(t3)) : t3 >= -2147483648 ? (this.writeU8(210), this.writeI32(t3)) : (this.writeU8(211), this.writeI64(t3)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t3)) : (this.writeU8(203), this.writeF64(t3));
          }, t2.prototype.encodebigint = function(t3) {
            t3 >= BigInt(0) ? t3 < BigInt(128) ? this.writeU8(Number(t3)) : t3 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t3))) : t3 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t3))) : t3 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t3))) : (this.writeU8(207), this.writeBig64(t3)) : t3 >= BigInt(-32) ? this.writeU8(224 | Number(t3) + 32) : t3 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t3))) : t3 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t3))) : t3 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t3))) : (this.writeU8(211), this.writeBig64(t3));
          }, t2.prototype.writeStringHeader = function(t3) {
            if (t3 < 32)
              this.writeU8(160 + t3);
            else if (t3 < 256)
              this.writeU8(217), this.writeU8(t3);
            else if (t3 < 65536)
              this.writeU8(218), this.writeU16(t3);
            else {
              if (!(t3 < 4294967296))
                throw new Error("Too long string: " + t3 + " bytes in UTF-8");
              this.writeU8(219), this.writeU32(t3);
            }
          }, t2.prototype.encodeString = function(t3) {
            var e2 = t3.length;
            if (o && e2 > h) {
              var r2 = s(t3);
              this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), u(t3, this.bytes, this.pos), this.pos += r2;
            } else {
              r2 = s(t3);
              this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), function(t4, e3, r3) {
                for (var n2 = t4.length, i2 = r3, o2 = 0; o2 < n2; ) {
                  var s2 = t4.charCodeAt(o2++);
                  if (0 != (4294967168 & s2)) {
                    if (0 == (4294965248 & s2))
                      e3[i2++] = s2 >> 6 & 31 | 192;
                    else {
                      if (s2 >= 55296 && s2 <= 56319 && o2 < n2) {
                        var a2 = t4.charCodeAt(o2);
                        56320 == (64512 & a2) && (++o2, s2 = ((1023 & s2) << 10) + (1023 & a2) + 65536);
                      }
                      0 == (4294901760 & s2) ? (e3[i2++] = s2 >> 12 & 15 | 224, e3[i2++] = s2 >> 6 & 63 | 128) : (e3[i2++] = s2 >> 18 & 7 | 240, e3[i2++] = s2 >> 12 & 63 | 128, e3[i2++] = s2 >> 6 & 63 | 128);
                    }
                    e3[i2++] = 63 & s2 | 128;
                  } else
                    e3[i2++] = s2;
                }
              }(t3, this.bytes, this.pos), this.pos += r2;
            }
          }, t2.prototype.encodeObject = function(t3, e2) {
            var r2 = this.extensionCodec.tryToEncode(t3, this.context);
            if (null != r2)
              this.encodeExtension(r2);
            else if (Array.isArray(t3))
              this.encodeArray(t3, e2);
            else if (ArrayBuffer.isView(t3))
              this.encodeBinary(t3);
            else {
              if ("object" != typeof t3)
                throw new Error("Unrecognized object: " + Object.prototype.toString.apply(t3));
              this.encodeMap(t3, e2);
            }
          }, t2.prototype.encodeBinary = function(t3) {
            var e2 = t3.byteLength;
            if (e2 < 256)
              this.writeU8(196), this.writeU8(e2);
            else if (e2 < 65536)
              this.writeU8(197), this.writeU16(e2);
            else {
              if (!(e2 < 4294967296))
                throw new Error("Too large binary: " + e2);
              this.writeU8(198), this.writeU32(e2);
            }
            var r2 = B(t3);
            this.writeU8a(r2);
          }, t2.prototype.encodeArray = function(t3, e2) {
            var r2, n2, i2 = t3.length;
            if (i2 < 16)
              this.writeU8(144 + i2);
            else if (i2 < 65536)
              this.writeU8(220), this.writeU16(i2);
            else {
              if (!(i2 < 4294967296))
                throw new Error("Too large array: " + i2);
              this.writeU8(221), this.writeU32(i2);
            }
            try {
              for (var o2 = E(t3), s2 = o2.next(); !s2.done; s2 = o2.next()) {
                var a2 = s2.value;
                this.doEncode(a2, e2 + 1);
              }
            } catch (t4) {
              r2 = { error: t4 };
            } finally {
              try {
                s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, t2.prototype.countWithoutUndefined = function(t3, e2) {
            var r2, n2, i2 = 0;
            try {
              for (var o2 = E(e2), s2 = o2.next(); !s2.done; s2 = o2.next()) {
                void 0 !== t3[s2.value] && i2++;
              }
            } catch (t4) {
              r2 = { error: t4 };
            } finally {
              try {
                s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return i2;
          }, t2.prototype.encodeMap = function(t3, e2) {
            var r2, n2, i2 = Object.keys(t3);
            this.sortKeys && i2.sort();
            var o2 = this.ignoreUndefined ? this.countWithoutUndefined(t3, i2) : i2.length;
            if (o2 < 16)
              this.writeU8(128 + o2);
            else if (o2 < 65536)
              this.writeU8(222), this.writeU16(o2);
            else {
              if (!(o2 < 4294967296))
                throw new Error("Too large map object: " + o2);
              this.writeU8(223), this.writeU32(o2);
            }
            try {
              for (var s2 = E(i2), a2 = s2.next(); !a2.done; a2 = s2.next()) {
                var h2 = a2.value, u2 = t3[h2];
                this.ignoreUndefined && void 0 === u2 || (this.encodeString(h2), this.doEncode(u2, e2 + 1));
              }
            } catch (t4) {
              r2 = { error: t4 };
            } finally {
              try {
                a2 && !a2.done && (n2 = s2.return) && n2.call(s2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, t2.prototype.encodeExtension = function(t3) {
            var e2 = t3.data.length;
            if (1 === e2)
              this.writeU8(212);
            else if (2 === e2)
              this.writeU8(213);
            else if (4 === e2)
              this.writeU8(214);
            else if (8 === e2)
              this.writeU8(215);
            else if (16 === e2)
              this.writeU8(216);
            else if (e2 < 256)
              this.writeU8(199), this.writeU8(e2);
            else if (e2 < 65536)
              this.writeU8(200), this.writeU16(e2);
            else {
              if (!(e2 < 4294967296))
                throw new Error("Too large extension object: " + e2);
              this.writeU8(201), this.writeU32(e2);
            }
            this.writeI8(t3.type), this.writeU8a(t3.data);
          }, t2.prototype.writeU8 = function(t3) {
            this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t3), this.pos++;
          }, t2.prototype.writeU8a = function(t3) {
            var e2 = t3.length;
            this.ensureBufferSizeToWrite(e2), this.bytes.set(t3, this.pos), this.pos += e2;
          }, t2.prototype.writeI8 = function(t3) {
            this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t3), this.pos++;
          }, t2.prototype.writeU16 = function(t3) {
            this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t3), this.pos += 2;
          }, t2.prototype.writeI16 = function(t3) {
            this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t3), this.pos += 2;
          }, t2.prototype.writeU32 = function(t3) {
            this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t3), this.pos += 4;
          }, t2.prototype.writeI32 = function(t3) {
            this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t3), this.pos += 4;
          }, t2.prototype.writeF32 = function(t3) {
            this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t3), this.pos += 4;
          }, t2.prototype.writeF64 = function(t3) {
            this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t3), this.pos += 8;
          }, t2.prototype.writeU64 = function(t3) {
            this.ensureBufferSizeToWrite(8), function(t4, e2, r2) {
              var n2 = r2 / 4294967296, i2 = r2;
              t4.setUint32(e2, n2), t4.setUint32(e2 + 4, i2);
            }(this.view, this.pos, t3), this.pos += 8;
          }, t2.prototype.writeI64 = function(t3) {
            this.ensureBufferSizeToWrite(8), d(this.view, this.pos, t3), this.pos += 8;
          }, t2.prototype.writeBig64 = function(t3) {
            this.ensureBufferSizeToWrite(8), function(t4, e2, r2) {
              var n2 = Number(r2 / BigInt(4294967296)), i2 = Number(r2 % BigInt(4294967296));
              n2 < 0 && 0 !== i2 && (n2 -= 1), t4.setUint32(e2, n2), t4.setUint32(e2 + 4, i2);
            }(this.view, this.pos, t3), this.pos += 8;
          }, t2;
        }(), A = {};
        function T(t2, e2) {
          return void 0 === e2 && (e2 = A), new I(e2.extensionCodec, e2.context, e2.maxDepth, e2.initialBufferSize, e2.sortKeys, e2.forceFloat32, e2.ignoreUndefined, e2.forceIntegerToFloat).encode(t2);
        }
        function L(t2) {
          return (t2 < 0 ? "-" : "") + "0x" + Math.abs(t2).toString(16).padStart(2, "0");
        }
        var M = function() {
          function t2(t3, e2) {
            void 0 === t3 && (t3 = 16), void 0 === e2 && (e2 = 16), this.maxKeyLength = t3, this.maxLengthPerKey = e2, this.hit = 0, this.miss = 0, this.caches = [];
            for (var r2 = 0; r2 < this.maxKeyLength; r2++)
              this.caches.push([]);
          }
          return t2.prototype.canBeCached = function(t3) {
            return t3 > 0 && t3 <= this.maxKeyLength;
          }, t2.prototype.get = function(t3, e2, r2) {
            var n2 = this.caches[r2 - 1], i2 = n2.length;
            t:
              for (var o2 = 0; o2 < i2; o2++) {
                for (var s2 = n2[o2], a2 = s2.bytes, h2 = 0; h2 < r2; h2++)
                  if (a2[h2] !== t3[e2 + h2])
                    continue t;
                return s2.value;
              }
            return null;
          }, t2.prototype.store = function(t3, e2) {
            var r2 = this.caches[t3.length - 1], n2 = { bytes: t3, value: e2 };
            r2.length >= this.maxLengthPerKey ? r2[Math.random() * r2.length | 0] = n2 : r2.push(n2);
          }, t2.prototype.decode = function(t3, e2, r2) {
            var n2 = this.get(t3, e2, r2);
            if (null != n2)
              return this.hit++, n2;
            this.miss++;
            var i2 = c(t3, e2, r2), o2 = Uint8Array.prototype.slice.call(t3, e2, e2 + r2);
            return this.store(o2, i2), i2;
          }, t2;
        }(), k = function(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i2, o2) {
            function s2(t3) {
              try {
                h2(n2.next(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function a2(t3) {
              try {
                h2(n2.throw(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function h2(t3) {
              var e3;
              t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                t4(e3);
              })).then(s2, a2);
            }
            h2((n2 = n2.apply(t2, e2 || [])).next());
          });
        }, z = function(t2, e2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = e2.call(t2, s2);
                  } catch (t3) {
                    o4 = [6, t3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, D = function(t2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var e2, r2 = t2[Symbol.asyncIterator];
          return r2 ? r2.call(t2) : (t2 = "function" == typeof __values ? __values(t2) : t2[Symbol.iterator](), e2 = {}, n2("next"), n2("throw"), n2("return"), e2[Symbol.asyncIterator] = function() {
            return this;
          }, e2);
          function n2(r3) {
            e2[r3] = t2[r3] && function(e3) {
              return new Promise(function(n3, i2) {
                (function(t3, e4, r4, n4) {
                  Promise.resolve(n4).then(function(e5) {
                    t3({ value: e5, done: r4 });
                  }, e4);
                })(n3, i2, (e3 = t2[r3](e3)).done, e3.value);
              });
            };
          }
        }, N = function(t2) {
          return this instanceof N ? (this.v = t2, this) : new N(t2);
        }, C = function(t2, e2, r2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n2, i2 = r2.apply(t2, e2 || []), o2 = [];
          return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
            return this;
          }, n2;
          function s2(t3) {
            i2[t3] && (n2[t3] = function(e3) {
              return new Promise(function(r3, n3) {
                o2.push([t3, e3, r3, n3]) > 1 || a2(t3, e3);
              });
            });
          }
          function a2(t3, e3) {
            try {
              (r3 = i2[t3](e3)).value instanceof N ? Promise.resolve(r3.value.v).then(h2, u2) : c2(o2[0][2], r3);
            } catch (t4) {
              c2(o2[0][3], t4);
            }
            var r3;
          }
          function h2(t3) {
            a2("next", t3);
          }
          function u2(t3) {
            a2("throw", t3);
          }
          function c2(t3, e3) {
            t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
          }
        }, P = new DataView(new ArrayBuffer(0)), F = new Uint8Array(P.buffer), j = function() {
          try {
            P.getInt8(0);
          } catch (t2) {
            return t2.constructor;
          }
          throw new Error("never reached");
        }(), _ = new j("Insufficient data"), W = new M(), O = function() {
          function t2(t3, e2, r2, n2, i2, o2, s2, a2) {
            void 0 === t3 && (t3 = S.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 4294967295), void 0 === n2 && (n2 = 4294967295), void 0 === i2 && (i2 = 4294967295), void 0 === o2 && (o2 = 4294967295), void 0 === s2 && (s2 = 4294967295), void 0 === a2 && (a2 = W), this.extensionCodec = t3, this.context = e2, this.maxStrLength = r2, this.maxBinLength = n2, this.maxArrayLength = i2, this.maxMapLength = o2, this.maxExtLength = s2, this.keyDecoder = a2, this.totalPos = 0, this.pos = 0, this.view = P, this.bytes = F, this.headByte = -1, this.stack = [];
          }
          return t2.prototype.reinitializeState = function() {
            this.totalPos = 0, this.headByte = -1;
          }, t2.prototype.setBuffer = function(t3) {
            this.bytes = B(t3), this.view = function(t4) {
              if (t4 instanceof ArrayBuffer)
                return new DataView(t4);
              var e2 = B(t4);
              return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
            }(this.bytes), this.pos = 0;
          }, t2.prototype.appendBuffer = function(t3) {
            if (-1 !== this.headByte || this.hasRemaining()) {
              var e2 = this.bytes.subarray(this.pos), r2 = B(t3), n2 = new Uint8Array(e2.length + r2.length);
              n2.set(e2), n2.set(r2, e2.length), this.setBuffer(n2);
            } else
              this.setBuffer(t3);
          }, t2.prototype.hasRemaining = function(t3) {
            return void 0 === t3 && (t3 = 1), this.view.byteLength - this.pos >= t3;
          }, t2.prototype.createNoExtraBytesError = function(t3) {
            var e2 = this.view, r2 = this.pos;
            return new RangeError("Extra " + (e2.byteLength - r2) + " of " + e2.byteLength + " byte(s) found at buffer[" + t3 + "]");
          }, t2.prototype.decode = function(t3) {
            return this.reinitializeState(), this.setBuffer(t3), this.doDecodeSingleSync();
          }, t2.prototype.doDecodeSingleSync = function() {
            var t3 = this.doDecodeSync();
            if (this.hasRemaining())
              throw this.createNoExtraBytesError(this.pos);
            return t3;
          }, t2.prototype.decodeAsync = function(t3) {
            var e2, r2, n2, i2;
            return k(this, void 0, void 0, function() {
              var o2, s2, a2, h2, u2, c2, f2, l2;
              return z(this, function(p2) {
                switch (p2.label) {
                  case 0:
                    o2 = false, p2.label = 1;
                  case 1:
                    p2.trys.push([1, 6, 7, 12]), e2 = D(t3), p2.label = 2;
                  case 2:
                    return [4, e2.next()];
                  case 3:
                    if ((r2 = p2.sent()).done)
                      return [3, 5];
                    if (a2 = r2.value, o2)
                      throw this.createNoExtraBytesError(this.totalPos);
                    this.appendBuffer(a2);
                    try {
                      s2 = this.doDecodeSync(), o2 = true;
                    } catch (t4) {
                      if (!(t4 instanceof j))
                        throw t4;
                    }
                    this.totalPos += this.pos, p2.label = 4;
                  case 4:
                    return [3, 2];
                  case 5:
                    return [3, 12];
                  case 6:
                    return h2 = p2.sent(), n2 = { error: h2 }, [3, 12];
                  case 7:
                    return p2.trys.push([7, , 10, 11]), r2 && !r2.done && (i2 = e2.return) ? [4, i2.call(e2)] : [3, 9];
                  case 8:
                    p2.sent(), p2.label = 9;
                  case 9:
                    return [3, 11];
                  case 10:
                    if (n2)
                      throw n2.error;
                    return [7];
                  case 11:
                    return [7];
                  case 12:
                    if (o2) {
                      if (this.hasRemaining())
                        throw this.createNoExtraBytesError(this.totalPos);
                      return [2, s2];
                    }
                    throw c2 = (u2 = this).headByte, f2 = u2.pos, l2 = u2.totalPos, new RangeError("Insufficient data in parcing " + L(c2) + " at " + l2 + " (" + f2 + " in the current buffer)");
                }
              });
            });
          }, t2.prototype.decodeArrayStream = function(t3) {
            return this.decodeMultiAsync(t3, true);
          }, t2.prototype.decodeStream = function(t3) {
            return this.decodeMultiAsync(t3, false);
          }, t2.prototype.decodeMultiAsync = function(t3, e2) {
            return C(this, arguments, function() {
              var r2, n2, i2, o2, s2, a2, h2, u2, c2;
              return z(this, function(f2) {
                switch (f2.label) {
                  case 0:
                    r2 = e2, n2 = -1, f2.label = 1;
                  case 1:
                    f2.trys.push([1, 13, 14, 19]), i2 = D(t3), f2.label = 2;
                  case 2:
                    return [4, N(i2.next())];
                  case 3:
                    if ((o2 = f2.sent()).done)
                      return [3, 12];
                    if (s2 = o2.value, e2 && 0 === n2)
                      throw this.createNoExtraBytesError(this.totalPos);
                    this.appendBuffer(s2), r2 && (n2 = this.readArraySize(), r2 = false, this.complete()), f2.label = 4;
                  case 4:
                    f2.trys.push([4, 9, , 10]), f2.label = 5;
                  case 5:
                    return [4, N(this.doDecodeSync())];
                  case 6:
                    return [4, f2.sent()];
                  case 7:
                    return f2.sent(), 0 == --n2 ? [3, 8] : [3, 5];
                  case 8:
                    return [3, 10];
                  case 9:
                    if (!((a2 = f2.sent()) instanceof j))
                      throw a2;
                    return [3, 10];
                  case 10:
                    this.totalPos += this.pos, f2.label = 11;
                  case 11:
                    return [3, 2];
                  case 12:
                    return [3, 19];
                  case 13:
                    return h2 = f2.sent(), u2 = { error: h2 }, [3, 19];
                  case 14:
                    return f2.trys.push([14, , 17, 18]), o2 && !o2.done && (c2 = i2.return) ? [4, N(c2.call(i2))] : [3, 16];
                  case 15:
                    f2.sent(), f2.label = 16;
                  case 16:
                    return [3, 18];
                  case 17:
                    if (u2)
                      throw u2.error;
                    return [7];
                  case 18:
                    return [7];
                  case 19:
                    return [2];
                }
              });
            });
          }, t2.prototype.doDecodeSync = function() {
            t:
              for (; ; ) {
                var t3 = this.readHeadByte(), e2 = void 0;
                if (t3 >= 224)
                  e2 = t3 - 256;
                else if (t3 < 192)
                  if (t3 < 128)
                    e2 = t3;
                  else if (t3 < 144) {
                    if (0 !== (n2 = t3 - 128)) {
                      this.pushMapState(n2), this.complete();
                      continue t;
                    }
                    e2 = {};
                  } else if (t3 < 160) {
                    if (0 !== (n2 = t3 - 144)) {
                      this.pushArrayState(n2), this.complete();
                      continue t;
                    }
                    e2 = [];
                  } else {
                    var r2 = t3 - 160;
                    e2 = this.decodeUtf8String(r2, 0);
                  }
                else if (192 === t3)
                  e2 = null;
                else if (194 === t3)
                  e2 = false;
                else if (195 === t3)
                  e2 = true;
                else if (202 === t3)
                  e2 = this.readF32();
                else if (203 === t3)
                  e2 = this.readF64();
                else if (204 === t3)
                  e2 = this.readU8();
                else if (205 === t3)
                  e2 = this.readU16();
                else if (206 === t3)
                  e2 = this.readU32();
                else if (207 === t3)
                  e2 = this.readU64();
                else if (208 === t3)
                  e2 = this.readI8();
                else if (209 === t3)
                  e2 = this.readI16();
                else if (210 === t3)
                  e2 = this.readI32();
                else if (211 === t3)
                  e2 = this.readI64();
                else if (217 === t3) {
                  r2 = this.lookU8();
                  e2 = this.decodeUtf8String(r2, 1);
                } else if (218 === t3) {
                  r2 = this.lookU16();
                  e2 = this.decodeUtf8String(r2, 2);
                } else if (219 === t3) {
                  r2 = this.lookU32();
                  e2 = this.decodeUtf8String(r2, 4);
                } else if (220 === t3) {
                  if (0 !== (n2 = this.readU16())) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else if (221 === t3) {
                  if (0 !== (n2 = this.readU32())) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else if (222 === t3) {
                  if (0 !== (n2 = this.readU16())) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (223 === t3) {
                  if (0 !== (n2 = this.readU32())) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (196 === t3) {
                  var n2 = this.lookU8();
                  e2 = this.decodeBinary(n2, 1);
                } else if (197 === t3) {
                  n2 = this.lookU16();
                  e2 = this.decodeBinary(n2, 2);
                } else if (198 === t3) {
                  n2 = this.lookU32();
                  e2 = this.decodeBinary(n2, 4);
                } else if (212 === t3)
                  e2 = this.decodeExtension(1, 0);
                else if (213 === t3)
                  e2 = this.decodeExtension(2, 0);
                else if (214 === t3)
                  e2 = this.decodeExtension(4, 0);
                else if (215 === t3)
                  e2 = this.decodeExtension(8, 0);
                else if (216 === t3)
                  e2 = this.decodeExtension(16, 0);
                else if (199 === t3) {
                  n2 = this.lookU8();
                  e2 = this.decodeExtension(n2, 1);
                } else if (200 === t3) {
                  n2 = this.lookU16();
                  e2 = this.decodeExtension(n2, 2);
                } else {
                  if (201 !== t3)
                    throw new Error("Unrecognized type byte: " + L(t3));
                  n2 = this.lookU32();
                  e2 = this.decodeExtension(n2, 4);
                }
                this.complete();
                for (var i2 = this.stack; i2.length > 0; ) {
                  var o2 = i2[i2.length - 1];
                  if (0 === o2.type) {
                    if (o2.array[o2.position] = e2, o2.position++, o2.position !== o2.size)
                      continue t;
                    i2.pop(), e2 = o2.array;
                  } else {
                    if (1 === o2.type) {
                      if (s2 = void 0, "string" !== (s2 = typeof e2) && "number" !== s2)
                        throw new Error("The type of key must be string or number but " + typeof e2);
                      o2.key = e2, o2.type = 2;
                      continue t;
                    }
                    if (o2.map[o2.key] = e2, o2.readCount++, o2.readCount !== o2.size) {
                      o2.key = null, o2.type = 1;
                      continue t;
                    }
                    i2.pop(), e2 = o2.map;
                  }
                }
                return e2;
              }
            var s2;
          }, t2.prototype.readHeadByte = function() {
            return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
          }, t2.prototype.complete = function() {
            this.headByte = -1;
          }, t2.prototype.readArraySize = function() {
            var t3 = this.readHeadByte();
            switch (t3) {
              case 220:
                return this.readU16();
              case 221:
                return this.readU32();
              default:
                if (t3 < 160)
                  return t3 - 144;
                throw new Error("Unrecognized array type byte: " + L(t3));
            }
          }, t2.prototype.pushMapState = function(t3) {
            if (t3 > this.maxMapLength)
              throw new Error("Max length exceeded: map length (" + t3 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
            this.stack.push({ type: 1, size: t3, key: null, readCount: 0, map: {} });
          }, t2.prototype.pushArrayState = function(t3) {
            if (t3 > this.maxArrayLength)
              throw new Error("Max length exceeded: array length (" + t3 + ") > maxArrayLength (" + this.maxArrayLength + ")");
            this.stack.push({ type: 0, size: t3, array: new Array(t3), position: 0 });
          }, t2.prototype.decodeUtf8String = function(t3, e2) {
            var r2;
            if (t3 > this.maxStrLength)
              throw new Error("Max length exceeded: UTF-8 byte length (" + t3 + ") > maxStrLength (" + this.maxStrLength + ")");
            if (this.bytes.byteLength < this.pos + e2 + t3)
              throw _;
            var n2, i2 = this.pos + e2;
            return n2 = this.stateIsMapKey() && (null === (r2 = this.keyDecoder) || void 0 === r2 ? void 0 : r2.canBeCached(t3)) ? this.keyDecoder.decode(this.bytes, i2, t3) : o && t3 > l ? function(t4, e3, r3) {
              var n3 = t4.subarray(e3, e3 + r3);
              return f.decode(n3);
            }(this.bytes, i2, t3) : c(this.bytes, i2, t3), this.pos += e2 + t3, n2;
          }, t2.prototype.stateIsMapKey = function() {
            return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
          }, t2.prototype.decodeBinary = function(t3, e2) {
            if (t3 > this.maxBinLength)
              throw new Error("Max length exceeded: bin length (" + t3 + ") > maxBinLength (" + this.maxBinLength + ")");
            if (!this.hasRemaining(t3 + e2))
              throw _;
            var r2 = this.pos + e2, n2 = this.bytes.subarray(r2, r2 + t3);
            return this.pos += e2 + t3, n2;
          }, t2.prototype.decodeExtension = function(t3, e2) {
            if (t3 > this.maxExtLength)
              throw new Error("Max length exceeded: ext length (" + t3 + ") > maxExtLength (" + this.maxExtLength + ")");
            var r2 = this.view.getInt8(this.pos + e2), n2 = this.decodeBinary(t3, e2 + 1);
            return this.extensionCodec.decode(n2, r2, this.context);
          }, t2.prototype.lookU8 = function() {
            return this.view.getUint8(this.pos);
          }, t2.prototype.lookU16 = function() {
            return this.view.getUint16(this.pos);
          }, t2.prototype.lookU32 = function() {
            return this.view.getUint32(this.pos);
          }, t2.prototype.readU8 = function() {
            var t3 = this.view.getUint8(this.pos);
            return this.pos++, t3;
          }, t2.prototype.readI8 = function() {
            var t3 = this.view.getInt8(this.pos);
            return this.pos++, t3;
          }, t2.prototype.readU16 = function() {
            var t3 = this.view.getUint16(this.pos);
            return this.pos += 2, t3;
          }, t2.prototype.readI16 = function() {
            var t3 = this.view.getInt16(this.pos);
            return this.pos += 2, t3;
          }, t2.prototype.readU32 = function() {
            var t3 = this.view.getUint32(this.pos);
            return this.pos += 4, t3;
          }, t2.prototype.readI32 = function() {
            var t3 = this.view.getInt32(this.pos);
            return this.pos += 4, t3;
          }, t2.prototype.readU64 = function() {
            var t3, e2, r2, n2, i2 = (t3 = this.view, e2 = this.pos, r2 = t3.getUint32(e2), n2 = t3.getUint32(e2 + 4), r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2);
            return this.pos += 8, i2;
          }, t2.prototype.readI64 = function() {
            var t3 = y(this.view, this.pos);
            return this.pos += 8, t3;
          }, t2.prototype.readF32 = function() {
            var t3 = this.view.getFloat32(this.pos);
            return this.pos += 4, t3;
          }, t2.prototype.readF64 = function() {
            var t3 = this.view.getFloat64(this.pos);
            return this.pos += 8, t3;
          }, t2;
        }(), R = {};
        function V(t2, e2) {
          return void 0 === e2 && (e2 = R), new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decode(t2);
        }
        var K2 = function(t2, e2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = e2.call(t2, s2);
                  } catch (t3) {
                    o4 = [6, t3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        }, G = function(t2) {
          return this instanceof G ? (this.v = t2, this) : new G(t2);
        }, H = function(t2, e2, r2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n2, i2 = r2.apply(t2, e2 || []), o2 = [];
          return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
            return this;
          }, n2;
          function s2(t3) {
            i2[t3] && (n2[t3] = function(e3) {
              return new Promise(function(r3, n3) {
                o2.push([t3, e3, r3, n3]) > 1 || a2(t3, e3);
              });
            });
          }
          function a2(t3, e3) {
            try {
              (r3 = i2[t3](e3)).value instanceof G ? Promise.resolve(r3.value.v).then(h2, u2) : c2(o2[0][2], r3);
            } catch (t4) {
              c2(o2[0][3], t4);
            }
            var r3;
          }
          function h2(t3) {
            a2("next", t3);
          }
          function u2(t3) {
            a2("throw", t3);
          }
          function c2(t3, e3) {
            t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
          }
        };
        function X(t2) {
          if (null == t2)
            throw new Error("Assertion Failure: value must not be null nor undefined");
        }
        function q(t2) {
          return null != t2[Symbol.asyncIterator] ? t2 : function(t3) {
            return H(this, arguments, function() {
              var e2, r2, n2, i2;
              return K2(this, function(o2) {
                switch (o2.label) {
                  case 0:
                    e2 = t3.getReader(), o2.label = 1;
                  case 1:
                    o2.trys.push([1, , 9, 10]), o2.label = 2;
                  case 2:
                    return [4, G(e2.read())];
                  case 3:
                    return r2 = o2.sent(), n2 = r2.done, i2 = r2.value, n2 ? [4, G(void 0)] : [3, 5];
                  case 4:
                    return [2, o2.sent()];
                  case 5:
                    return X(i2), [4, G(i2)];
                  case 6:
                    return [4, o2.sent()];
                  case 7:
                    return o2.sent(), [3, 2];
                  case 8:
                    return [3, 10];
                  case 9:
                    return e2.releaseLock(), [7];
                  case 10:
                    return [2];
                }
              });
            });
          }(t2);
        }
        var J = function(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i2, o2) {
            function s2(t3) {
              try {
                h2(n2.next(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function a2(t3) {
              try {
                h2(n2.throw(t3));
              } catch (t4) {
                o2(t4);
              }
            }
            function h2(t3) {
              var e3;
              t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                t4(e3);
              })).then(s2, a2);
            }
            h2((n2 = n2.apply(t2, e2 || [])).next());
          });
        }, Q = function(t2, e2) {
          var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function a2(o3) {
            return function(a3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; s2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return s2.label++, { value: o4[1], done: false };
                      case 5:
                        s2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = s2.ops.pop(), s2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          s2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          s2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && s2.label < i2[1]) {
                          s2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && s2.label < i2[2]) {
                          s2.label = i2[2], s2.ops.push(o4);
                          break;
                        }
                        i2[2] && s2.ops.pop(), s2.trys.pop();
                        continue;
                    }
                    o4 = e2.call(t2, s2);
                  } catch (t3) {
                    o4 = [6, t3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, a3]);
            };
          }
        };
        function Y(t2, e2) {
          return void 0 === e2 && (e2 = R), J(this, void 0, void 0, function() {
            var r2;
            return Q(this, function(n2) {
              return r2 = q(t2), [2, new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeAsync(r2)];
            });
          });
        }
        function Z(t2, e2) {
          void 0 === e2 && (e2 = R);
          var r2 = q(t2);
          return new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeArrayStream(r2);
        }
        function $(t2, e2) {
          void 0 === e2 && (e2 = R);
          var r2 = q(t2);
          return new O(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeStream(r2);
        }
      }]);
    });
  }
});

// node_modules/algosdk/dist/esm/src/encoding/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  ERROR_CONTAINS_EMPTY_STRING: () => ERROR_CONTAINS_EMPTY_STRING,
  decode: () => decode2,
  encode: () => encode2
});
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function encode2(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  const options = { sortKeys: true };
  return msgpack.encode(obj, options);
}
function decode2(buffer) {
  return msgpack.decode(buffer);
}
var msgpack, ERROR_CONTAINS_EMPTY_STRING;
var init_encoding = __esm({
  "node_modules/algosdk/dist/esm/src/encoding/encoding.js"() {
    msgpack = __toESM(require_msgpack_min());
    ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
  }
});

// node_modules/algosdk/dist/esm/src/types/transactions/base.js
function isTransactionType(s) {
  return s === TransactionType.pay || s === TransactionType.keyreg || s === TransactionType.acfg || s === TransactionType.axfer || s === TransactionType.afrz || s === TransactionType.appl || s === TransactionType.stpf;
}
var TransactionType, OnApplicationComplete;
var init_base = __esm({
  "node_modules/algosdk/dist/esm/src/types/transactions/base.js"() {
    (function(TransactionType2) {
      TransactionType2["pay"] = "pay";
      TransactionType2["keyreg"] = "keyreg";
      TransactionType2["acfg"] = "acfg";
      TransactionType2["axfer"] = "axfer";
      TransactionType2["afrz"] = "afrz";
      TransactionType2["appl"] = "appl";
      TransactionType2["stpf"] = "stpf";
    })(TransactionType || (TransactionType = {}));
    (function(OnApplicationComplete2) {
      OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
      OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
      OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
      OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
      OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
      OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
    })(OnApplicationComplete || (OnApplicationComplete = {}));
  }
});

// node_modules/algosdk/dist/esm/src/transaction.js
var transaction_exports = {};
__export(transaction_exports, {
  ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
  Transaction: () => Transaction,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  default: () => transaction_default,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  instantiateTxnIfNeeded: () => instantiateTxnIfNeeded
});
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputAsBuffer;
  if (typeof input === "string") {
    inputAsBuffer = Buffer.from(input, "base64");
  } else if (input.constructor === Uint8Array) {
    inputAsBuffer = Buffer.from(input);
  } else if (Buffer.isBuffer(input)) {
    inputAsBuffer = input;
  }
  if (inputAsBuffer == null || inputAsBuffer.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array or Buffer or base64 string.`);
  }
  return inputAsBuffer;
}
function encodeUnsignedTransaction(transactionObject) {
  const objToEncode = transactionObject.get_obj_for_encoding();
  return encode2(objToEncode);
}
function decodeUnsignedTransaction(transactionBuffer) {
  const partlyDecodedObject = decode2(transactionBuffer);
  return Transaction.from_obj_for_encoding(partlyDecodedObject);
}
function decodeSignedTransaction(transactionBuffer) {
  const stxnDecoded = decode2(transactionBuffer);
  const stxn = {
    ...stxnDecoded,
    txn: Transaction.from_obj_for_encoding(stxnDecoded.txn)
  };
  return stxn;
}
function instantiateTxnIfNeeded(transactionLike) {
  return transactionLike instanceof Transaction ? transactionLike : new Transaction(transactionLike);
}
var import_hi_base322, ALGORAND_TRANSACTION_LENGTH, ALGORAND_MIN_TX_FEE, ALGORAND_TRANSACTION_LEASE_LENGTH, ALGORAND_MAX_ASSET_DECIMALS, NUM_ADDL_BYTES_AFTER_SIGNING, ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH, ALGORAND_TRANSACTION_ADDRESS_LENGTH, ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH, ASSET_METADATA_HASH_LENGTH, KEYREG_VOTE_KEY_LENGTH, KEYREG_SELECTION_KEY_LENGTH, KEYREG_STATE_PROOF_KEY_LENGTH, Transaction, transaction_default;
var init_transaction = __esm({
  "node_modules/algosdk/dist/esm/src/transaction.js"() {
    import_hi_base322 = __toESM(require_base32());
    init_address();
    init_encoding();
    init_naclWrappers();
    init_utils();
    init_base();
    ALGORAND_TRANSACTION_LENGTH = 52;
    ALGORAND_MIN_TX_FEE = 1e3;
    ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
    ALGORAND_MAX_ASSET_DECIMALS = 19;
    NUM_ADDL_BYTES_AFTER_SIGNING = 75;
    ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
    ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
    ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
    ASSET_METADATA_HASH_LENGTH = 32;
    KEYREG_VOTE_KEY_LENGTH = 32;
    KEYREG_SELECTION_KEY_LENGTH = 32;
    KEYREG_STATE_PROOF_KEY_LENGTH = 64;
    Transaction = class {
      constructor({ ...transaction }) {
        this.name = "Transaction";
        this.tag = Buffer.from("TX");
        const defaults = {
          type: TransactionType.pay,
          flatFee: false,
          nonParticipation: false
        };
        if (typeof transaction.type === "undefined") {
          transaction.type = defaults.type;
        }
        if (typeof transaction.flatFee === "undefined") {
          transaction.flatFee = defaults.flatFee;
        }
        if (transaction.type === TransactionType.keyreg && typeof transaction.voteKey !== "undefined" && typeof transaction.nonParticipation === "undefined") {
          transaction.nonParticipation = defaults.nonParticipation;
        }
        if (transaction.suggestedParams !== void 0) {
          const reference = transaction;
          reference.genesisHash = reference.suggestedParams.genesisHash;
          reference.fee = reference.suggestedParams.fee;
          if (reference.suggestedParams.flatFee !== void 0)
            reference.flatFee = reference.suggestedParams.flatFee;
          reference.firstRound = reference.suggestedParams.firstRound;
          reference.lastRound = reference.suggestedParams.lastRound;
          reference.genesisID = reference.suggestedParams.genesisID;
        }
        const txn = transaction;
        txn.from = decodeAddress(txn.from);
        if (txn.to !== void 0)
          txn.to = decodeAddress(txn.to);
        if (txn.closeRemainderTo !== void 0)
          txn.closeRemainderTo = decodeAddress(txn.closeRemainderTo);
        if (txn.assetManager !== void 0)
          txn.assetManager = decodeAddress(txn.assetManager);
        if (txn.assetReserve !== void 0)
          txn.assetReserve = decodeAddress(txn.assetReserve);
        if (txn.assetFreeze !== void 0)
          txn.assetFreeze = decodeAddress(txn.assetFreeze);
        if (txn.assetClawback !== void 0)
          txn.assetClawback = decodeAddress(txn.assetClawback);
        if (txn.assetRevocationTarget !== void 0)
          txn.assetRevocationTarget = decodeAddress(txn.assetRevocationTarget);
        if (txn.freezeAccount !== void 0)
          txn.freezeAccount = decodeAddress(txn.freezeAccount);
        if (txn.reKeyTo !== void 0)
          txn.reKeyTo = decodeAddress(txn.reKeyTo);
        if (txn.genesisHash === void 0)
          throw Error("genesis hash must be specified and in a base64 string.");
        txn.genesisHash = Buffer.from(txn.genesisHash, "base64");
        if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
          throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
        if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
          throw Error("fee must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
          throw Error("firstRound must be a positive number");
        if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
          throw Error("lastRound must be a positive number");
        if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
          throw Error("extraPages must be an Integer between and including 0 to 3");
        if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
          throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
        if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
          throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
        if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
          throw Error("Asset index must be a positive number and smaller than 2^53-1");
        if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
          throw Error("Application index must be a positive number and smaller than 2^53-1");
        if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
          throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
        if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
          throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
        if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
          throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
        if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
          throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
        if (txn.appApprovalProgram !== void 0) {
          if (txn.appApprovalProgram.constructor !== Uint8Array)
            throw Error("appApprovalProgram must be a Uint8Array.");
        }
        if (txn.appClearProgram !== void 0) {
          if (txn.appClearProgram.constructor !== Uint8Array)
            throw Error("appClearProgram must be a Uint8Array.");
        }
        if (txn.appArgs !== void 0) {
          if (!Array.isArray(txn.appArgs))
            throw Error("appArgs must be an Array of Uint8Array.");
          txn.appArgs = txn.appArgs.slice();
          txn.appArgs.forEach((arg) => {
            if (arg.constructor !== Uint8Array)
              throw Error("each element of AppArgs must be a Uint8Array.");
          });
        } else {
          txn.appArgs = [];
        }
        if (txn.appAccounts !== void 0) {
          if (!Array.isArray(txn.appAccounts))
            throw Error("appAccounts must be an Array of addresses.");
          txn.appAccounts = txn.appAccounts.map((addressAsString) => decodeAddress(addressAsString));
        }
        if (txn.appForeignApps !== void 0) {
          if (!Array.isArray(txn.appForeignApps))
            throw Error("appForeignApps must be an Array of integers.");
          txn.appForeignApps = txn.appForeignApps.slice();
          txn.appForeignApps.forEach((foreignAppIndex) => {
            if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
              throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
          });
        }
        if (txn.appForeignAssets !== void 0) {
          if (!Array.isArray(txn.appForeignAssets))
            throw Error("appForeignAssets must be an Array of integers.");
          txn.appForeignAssets = txn.appForeignAssets.slice();
          txn.appForeignAssets.forEach((foreignAssetIndex) => {
            if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
              throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
          });
        }
        if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
          if (typeof txn.assetMetadataHash === "string") {
            txn.assetMetadataHash = new Uint8Array(Buffer.from(txn.assetMetadataHash));
          }
          if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
            throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
          }
          if (txn.assetMetadataHash.every((value) => value === 0)) {
            txn.assetMetadataHash = void 0;
          }
        } else {
          txn.assetMetadataHash = void 0;
        }
        if (txn.note !== void 0) {
          if (txn.note.constructor !== Uint8Array)
            throw Error("note must be a Uint8Array.");
        } else {
          txn.note = new Uint8Array(0);
        }
        if (txn.lease !== void 0) {
          if (txn.lease.constructor !== Uint8Array)
            throw Error("lease must be a Uint8Array.");
          if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
            throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
          if (txn.lease.every((value) => value === 0)) {
            txn.lease = new Uint8Array(0);
          }
        } else {
          txn.lease = new Uint8Array(0);
        }
        txn.voteKey = getKeyregKey(txn.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH);
        txn.selectionKey = getKeyregKey(txn.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH);
        txn.stateProofKey = getKeyregKey(txn.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH);
        if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.stateProofKey || txn.voteLast || txn.voteKeyDilution)) {
          throw new Error("nonParticipation is true but participation params are present.");
        }
        if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.stateProofKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
          throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
        }
        delete txn.suggestedParams;
        Object.assign(this, removeUndefinedProperties(txn));
        if (!txn.flatFee) {
          this.fee *= this.estimateSize();
          if (this.fee < ALGORAND_MIN_TX_FEE) {
            this.fee = ALGORAND_MIN_TX_FEE;
          }
        }
        this.group = void 0;
        if (txn.stateProofType !== void 0 && (!Number.isSafeInteger(txn.stateProofType) || txn.stateProofType < 0))
          throw Error("State Proof type must be a positive number and smaller than 2^53-1");
        if (txn.stateProofMessage !== void 0) {
          if (txn.stateProofMessage.constructor !== Uint8Array)
            throw Error("stateProofMessage must be a Uint8Array.");
        } else {
          txn.stateProofMessage = new Uint8Array(0);
        }
        if (txn.stateProof !== void 0) {
          if (txn.stateProof.constructor !== Uint8Array)
            throw Error("stateProof must be a Uint8Array.");
        } else {
          txn.stateProof = new Uint8Array(0);
        }
      }
      get_obj_for_encoding() {
        if (this.type === "pay") {
          const txn = {
            amt: this.amount,
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: "pay",
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group
          };
          if (this.closeRemainderTo !== void 0 && encodeAddress(this.closeRemainderTo.publicKey) !== ALGORAND_ZERO_ADDRESS_STRING) {
            txn.close = Buffer.from(this.closeRemainderTo.publicKey);
          }
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (this.to !== void 0)
            txn.rcv = Buffer.from(this.to.publicKey);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (txn.grp === void 0)
            delete txn.grp;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.rekey)
            delete txn.rekey;
          return txn;
        }
        if (this.type === "keyreg") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            votekey: this.voteKey,
            selkey: this.selectionKey,
            sprfkey: this.stateProofKey,
            votefst: this.voteFirst,
            votelst: this.voteLast,
            votekd: this.voteKeyDilution
          };
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (txn.grp === void 0)
            delete txn.grp;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (this.nonParticipation) {
            txn.nonpart = true;
          }
          if (!txn.selkey)
            delete txn.selkey;
          if (!txn.votekey)
            delete txn.votekey;
          if (!txn.sprfkey)
            delete txn.sprfkey;
          if (!txn.votefst)
            delete txn.votefst;
          if (!txn.votelst)
            delete txn.votelst;
          if (!txn.votekd)
            delete txn.votekd;
          return txn;
        }
        if (this.type === "acfg") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            caid: this.assetIndex,
            apar: {
              t: this.assetTotal,
              df: this.assetDefaultFrozen,
              dc: this.assetDecimals
            }
          };
          if (this.assetManager !== void 0)
            txn.apar.m = Buffer.from(this.assetManager.publicKey);
          if (this.assetReserve !== void 0)
            txn.apar.r = Buffer.from(this.assetReserve.publicKey);
          if (this.assetFreeze !== void 0)
            txn.apar.f = Buffer.from(this.assetFreeze.publicKey);
          if (this.assetClawback !== void 0)
            txn.apar.c = Buffer.from(this.assetClawback.publicKey);
          if (this.assetName !== void 0)
            txn.apar.an = this.assetName;
          if (this.assetUnitName !== void 0)
            txn.apar.un = this.assetUnitName;
          if (this.assetURL !== void 0)
            txn.apar.au = this.assetURL;
          if (this.assetMetadataHash !== void 0)
            txn.apar.am = Buffer.from(this.assetMetadataHash);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (!txn.caid)
            delete txn.caid;
          if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
            delete txn.apar;
          } else {
            if (!txn.apar.t)
              delete txn.apar.t;
            if (!txn.apar.dc)
              delete txn.apar.dc;
            if (!txn.apar.un)
              delete txn.apar.un;
            if (!txn.apar.an)
              delete txn.apar.an;
            if (!txn.apar.df)
              delete txn.apar.df;
            if (!txn.apar.m)
              delete txn.apar.m;
            if (!txn.apar.r)
              delete txn.apar.r;
            if (!txn.apar.f)
              delete txn.apar.f;
            if (!txn.apar.c)
              delete txn.apar.c;
            if (!txn.apar.au)
              delete txn.apar.au;
            if (!txn.apar.am)
              delete txn.apar.am;
          }
          if (txn.grp === void 0)
            delete txn.grp;
          return txn;
        }
        if (this.type === "axfer") {
          const txn = {
            aamt: this.amount,
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            arcv: Buffer.from(this.to.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            xaid: this.assetIndex
          };
          if (this.closeRemainderTo !== void 0)
            txn.aclose = Buffer.from(this.closeRemainderTo.publicKey);
          if (this.assetRevocationTarget !== void 0)
            txn.asnd = Buffer.from(this.assetRevocationTarget.publicKey);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.aamt)
            delete txn.aamt;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (txn.grp === void 0)
            delete txn.grp;
          if (!txn.aclose)
            delete txn.aclose;
          if (!txn.asnd)
            delete txn.asnd;
          if (!txn.rekey)
            delete txn.rekey;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          return txn;
        }
        if (this.type === "afrz") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            faid: this.assetIndex,
            afrz: this.freezeState
          };
          if (this.freezeAccount !== void 0)
            txn.fadd = Buffer.from(this.freezeAccount.publicKey);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (!txn.afrz)
            delete txn.afrz;
          if (txn.grp === void 0)
            delete txn.grp;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          return txn;
        }
        if (this.type === "appl") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            apid: this.appIndex,
            apan: this.appOnComplete,
            apls: {
              nui: this.appLocalInts,
              nbs: this.appLocalByteSlices
            },
            apgs: {
              nui: this.appGlobalInts,
              nbs: this.appGlobalByteSlices
            },
            apfa: this.appForeignApps,
            apas: this.appForeignAssets,
            apep: this.extraPages
          };
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (this.appApprovalProgram !== void 0) {
            txn.apap = Buffer.from(this.appApprovalProgram);
          }
          if (this.appClearProgram !== void 0) {
            txn.apsu = Buffer.from(this.appClearProgram);
          }
          if (this.appArgs !== void 0) {
            txn.apaa = this.appArgs.map((arg) => Buffer.from(arg));
          }
          if (this.appAccounts !== void 0) {
            txn.apat = this.appAccounts.map((decodedAddress) => Buffer.from(decodedAddress.publicKey));
          }
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (!txn.apid)
            delete txn.apid;
          if (!txn.apls.nui)
            delete txn.apls.nui;
          if (!txn.apls.nbs)
            delete txn.apls.nbs;
          if (!txn.apls.nui && !txn.apls.nbs)
            delete txn.apls;
          if (!txn.apgs.nui)
            delete txn.apgs.nui;
          if (!txn.apgs.nbs)
            delete txn.apgs.nbs;
          if (!txn.apaa || !txn.apaa.length)
            delete txn.apaa;
          if (!txn.apgs.nui && !txn.apgs.nbs)
            delete txn.apgs;
          if (!txn.apap)
            delete txn.apap;
          if (!txn.apsu)
            delete txn.apsu;
          if (!txn.apan)
            delete txn.apan;
          if (!txn.apfa || !txn.apfa.length)
            delete txn.apfa;
          if (!txn.apas || !txn.apas.length)
            delete txn.apas;
          if (!txn.apat || !txn.apat.length)
            delete txn.apat;
          if (!txn.apep)
            delete txn.apep;
          if (txn.grp === void 0)
            delete txn.grp;
          return txn;
        }
        if (this.type === "stpf") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            sptype: this.stateProofType,
            spmsg: Buffer.from(this.stateProofMessage),
            sp: Buffer.from(this.stateProof)
          };
          if (!txn.sptype)
            delete txn.sptype;
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (!txn.apid)
            delete txn.apid;
          if (!txn.apaa || !txn.apaa.length)
            delete txn.apaa;
          if (!txn.apap)
            delete txn.apap;
          if (!txn.apsu)
            delete txn.apsu;
          if (!txn.apan)
            delete txn.apan;
          if (!txn.apfa || !txn.apfa.length)
            delete txn.apfa;
          if (!txn.apas || !txn.apas.length)
            delete txn.apas;
          if (!txn.apat || !txn.apat.length)
            delete txn.apat;
          if (!txn.apep)
            delete txn.apep;
          if (txn.grp === void 0)
            delete txn.grp;
          return txn;
        }
        return void 0;
      }
      static from_obj_for_encoding(txnForEnc) {
        const txn = Object.create(this.prototype);
        txn.name = "Transaction";
        txn.tag = Buffer.from("TX");
        txn.genesisID = txnForEnc.gen;
        txn.genesisHash = Buffer.from(txnForEnc.gh);
        if (!isTransactionType(txnForEnc.type)) {
          throw new Error(`Unrecognized transaction type: ${txnForEnc.type}`);
        }
        txn.type = txnForEnc.type;
        txn.fee = txnForEnc.fee;
        txn.firstRound = txnForEnc.fv;
        txn.lastRound = txnForEnc.lv;
        txn.note = new Uint8Array(txnForEnc.note);
        txn.lease = new Uint8Array(txnForEnc.lx);
        txn.from = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.snd)));
        if (txnForEnc.grp !== void 0)
          txn.group = Buffer.from(txnForEnc.grp);
        if (txnForEnc.rekey !== void 0)
          txn.reKeyTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rekey)));
        if (txnForEnc.type === "pay") {
          txn.amount = txnForEnc.amt;
          txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rcv)));
          if (txnForEnc.close !== void 0)
            txn.closeRemainderTo = decodeAddress(encodeAddress(txnForEnc.close));
        } else if (txnForEnc.type === "keyreg") {
          if (txnForEnc.votekey !== void 0) {
            txn.voteKey = Buffer.from(txnForEnc.votekey);
          }
          if (txnForEnc.selkey !== void 0) {
            txn.selectionKey = Buffer.from(txnForEnc.selkey);
          }
          if (txnForEnc.sprfkey !== void 0) {
            txn.stateProofKey = Buffer.from(txnForEnc.sprfkey);
          }
          if (txnForEnc.votekd !== void 0) {
            txn.voteKeyDilution = txnForEnc.votekd;
          }
          if (txnForEnc.votefst !== void 0) {
            txn.voteFirst = txnForEnc.votefst;
          }
          if (txnForEnc.votelst !== void 0) {
            txn.voteLast = txnForEnc.votelst;
          }
          if (txnForEnc.nonpart !== void 0) {
            txn.nonParticipation = txnForEnc.nonpart;
          }
        } else if (txnForEnc.type === "acfg") {
          if (txnForEnc.caid !== void 0) {
            txn.assetIndex = txnForEnc.caid;
          }
          if (txnForEnc.apar !== void 0) {
            txn.assetTotal = txnForEnc.apar.t;
            txn.assetDefaultFrozen = txnForEnc.apar.df;
            if (txnForEnc.apar.dc !== void 0)
              txn.assetDecimals = txnForEnc.apar.dc;
            if (txnForEnc.apar.m !== void 0)
              txn.assetManager = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.m)));
            if (txnForEnc.apar.r !== void 0)
              txn.assetReserve = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.r)));
            if (txnForEnc.apar.f !== void 0)
              txn.assetFreeze = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.f)));
            if (txnForEnc.apar.c !== void 0)
              txn.assetClawback = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.c)));
            if (txnForEnc.apar.un !== void 0)
              txn.assetUnitName = txnForEnc.apar.un;
            if (txnForEnc.apar.an !== void 0)
              txn.assetName = txnForEnc.apar.an;
            if (txnForEnc.apar.au !== void 0)
              txn.assetURL = txnForEnc.apar.au;
            if (txnForEnc.apar.am !== void 0)
              txn.assetMetadataHash = txnForEnc.apar.am;
          }
        } else if (txnForEnc.type === "axfer") {
          if (txnForEnc.xaid !== void 0) {
            txn.assetIndex = txnForEnc.xaid;
          }
          if (txnForEnc.aamt !== void 0)
            txn.amount = txnForEnc.aamt;
          if (txnForEnc.aclose !== void 0) {
            txn.closeRemainderTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.aclose)));
          }
          if (txnForEnc.asnd !== void 0) {
            txn.assetRevocationTarget = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.asnd)));
          }
          txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.arcv)));
        } else if (txnForEnc.type === "afrz") {
          if (txnForEnc.afrz !== void 0) {
            txn.freezeState = txnForEnc.afrz;
          }
          if (txnForEnc.faid !== void 0) {
            txn.assetIndex = txnForEnc.faid;
          }
          txn.freezeAccount = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.fadd)));
        } else if (txnForEnc.type === "appl") {
          if (txnForEnc.apid !== void 0) {
            txn.appIndex = txnForEnc.apid;
          }
          if (txnForEnc.apan !== void 0) {
            txn.appOnComplete = txnForEnc.apan;
          }
          if (txnForEnc.apls !== void 0) {
            if (txnForEnc.apls.nui !== void 0)
              txn.appLocalInts = txnForEnc.apls.nui;
            if (txnForEnc.apls.nbs !== void 0)
              txn.appLocalByteSlices = txnForEnc.apls.nbs;
          }
          if (txnForEnc.apgs !== void 0) {
            if (txnForEnc.apgs.nui !== void 0)
              txn.appGlobalInts = txnForEnc.apgs.nui;
            if (txnForEnc.apgs.nbs !== void 0)
              txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
          }
          if (txnForEnc.apep !== void 0) {
            txn.extraPages = txnForEnc.apep;
          }
          if (txnForEnc.apap !== void 0) {
            txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
          }
          if (txnForEnc.apsu !== void 0) {
            txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
          }
          if (txnForEnc.apaa !== void 0) {
            txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
          }
          if (txnForEnc.apat !== void 0) {
            txn.appAccounts = txnForEnc.apat.map((addressBytes) => decodeAddress(encodeAddress(new Uint8Array(addressBytes))));
          }
          if (txnForEnc.apfa !== void 0) {
            txn.appForeignApps = txnForEnc.apfa;
          }
          if (txnForEnc.apas !== void 0) {
            txn.appForeignAssets = txnForEnc.apas;
          }
        } else if (txnForEnc.type === "stpf") {
          if (txnForEnc.sptype !== void 0) {
            txn.stateProofType = txnForEnc.sptype;
          }
          if (txnForEnc.sp !== void 0) {
            txn.stateProof = txnForEnc.sp;
          }
          if (txnForEnc.spmsg !== void 0) {
            txn.stateProofMessage = txnForEnc.spmsg;
          }
        }
        return txn;
      }
      estimateSize() {
        return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
      }
      bytesToSign() {
        const encodedMsg = this.toByte();
        return Buffer.from(concatArrays(this.tag, encodedMsg));
      }
      toByte() {
        return encode2(this.get_obj_for_encoding());
      }
      rawSignTxn(sk) {
        const toBeSigned = this.bytesToSign();
        const sig = sign(toBeSigned, sk);
        return Buffer.from(sig);
      }
      signTxn(sk) {
        const sTxn = {
          sig: this.rawSignTxn(sk),
          txn: this.get_obj_for_encoding()
        };
        const keypair = keyPairFromSecretKey(sk);
        const pubKeyFromSk = keypair.publicKey;
        if (encodeAddress(pubKeyFromSk) !== encodeAddress(this.from.publicKey)) {
          sTxn.sgnr = Buffer.from(pubKeyFromSk);
        }
        return new Uint8Array(encode2(sTxn));
      }
      attachSignature(signerAddr, signature) {
        if (!isValidSignatureLength(signature.length)) {
          throw new Error("Invalid signature length");
        }
        const sTxn = {
          sig: Buffer.from(signature),
          txn: this.get_obj_for_encoding()
        };
        if (signerAddr !== encodeAddress(this.from.publicKey)) {
          const signerPublicKey = decodeAddress(signerAddr).publicKey;
          sTxn.sgnr = Buffer.from(signerPublicKey);
        }
        return new Uint8Array(encode2(sTxn));
      }
      rawTxID() {
        const enMsg = this.toByte();
        const gh = Buffer.from(concatArrays(this.tag, enMsg));
        return Buffer.from(genericHash(gh));
      }
      txID() {
        const hash = this.rawTxID();
        return import_hi_base322.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
      }
      addLease(lease, feePerByte = 0) {
        let mutableLease;
        if (lease !== void 0) {
          if (lease.constructor !== Uint8Array)
            throw Error("lease must be a Uint8Array.");
          if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
            throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
          mutableLease = new Uint8Array(lease);
        } else {
          mutableLease = new Uint8Array(0);
        }
        this.lease = mutableLease;
        if (feePerByte !== 0) {
          this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
        }
      }
      addRekey(reKeyTo, feePerByte = 0) {
        if (reKeyTo !== void 0) {
          this.reKeyTo = decodeAddress(reKeyTo);
        }
        if (feePerByte !== 0) {
          this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
        }
      }
      _getDictForDisplay() {
        const forPrinting = {
          ...this
        };
        forPrinting.tag = forPrinting.tag.toString();
        forPrinting.from = encodeAddress(forPrinting.from.publicKey);
        if (forPrinting.to !== void 0)
          forPrinting.to = encodeAddress(forPrinting.to.publicKey);
        if (forPrinting.freezeAccount !== void 0)
          forPrinting.freezeAccount = encodeAddress(forPrinting.freezeAccount.publicKey);
        if (forPrinting.closeRemainderTo !== void 0)
          forPrinting.closeRemainderTo = encodeAddress(forPrinting.closeRemainderTo.publicKey);
        if (forPrinting.assetManager !== void 0)
          forPrinting.assetManager = encodeAddress(forPrinting.assetManager.publicKey);
        if (forPrinting.assetReserve !== void 0)
          forPrinting.assetReserve = encodeAddress(forPrinting.assetReserve.publicKey);
        if (forPrinting.assetFreeze !== void 0)
          forPrinting.assetFreeze = encodeAddress(forPrinting.assetFreeze.publicKey);
        if (forPrinting.assetClawback !== void 0)
          forPrinting.assetClawback = encodeAddress(forPrinting.assetClawback.publicKey);
        if (forPrinting.assetRevocationTarget !== void 0)
          forPrinting.assetRevocationTarget = encodeAddress(forPrinting.assetRevocationTarget.publicKey);
        if (forPrinting.reKeyTo !== void 0)
          forPrinting.reKeyTo = encodeAddress(forPrinting.reKeyTo.publicKey);
        forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
        return forPrinting;
      }
      prettyPrint() {
        console.log(this._getDictForDisplay());
      }
      toString() {
        return JSON.stringify(this._getDictForDisplay());
      }
    };
    transaction_default = Transaction;
  }
});

// node_modules/algosdk/dist/esm/src/group.js
var group_exports = {};
__export(group_exports, {
  TxGroup: () => TxGroup,
  assignGroupID: () => assignGroupID,
  computeGroupID: () => computeGroupID,
  default: () => group_default
});
function computeGroupID(txns) {
  const hashes = [];
  for (const txn of txns) {
    const tx = instantiateTxnIfNeeded(txn);
    hashes.push(tx.rawTxID());
  }
  const txgroup = new TxGroup(hashes);
  const bytes = txgroup.toByte();
  const toBeHashed = Buffer.from(concatArrays(txgroup.tag, bytes));
  const gid = genericHash(toBeHashed);
  return Buffer.from(gid);
}
function assignGroupID(txns, from) {
  const gid = computeGroupID(txns);
  const result = [];
  for (const txn of txns) {
    const tx = instantiateTxnIfNeeded(txn);
    if (!from || encodeAddress(tx.from.publicKey) === from) {
      tx.group = gid;
      result.push(tx);
    }
  }
  return result;
}
var ALGORAND_MAX_TX_GROUP_SIZE, TxGroup, group_default;
var init_group = __esm({
  "node_modules/algosdk/dist/esm/src/group.js"() {
    init_transaction();
    init_naclWrappers();
    init_encoding();
    init_address();
    init_utils();
    ALGORAND_MAX_TX_GROUP_SIZE = 16;
    TxGroup = class {
      constructor(hashes) {
        this.name = "Transaction group";
        this.tag = Buffer.from("TG");
        if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
          const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;
          throw Error(errorMsg);
        }
        this.txGroupHashes = hashes;
      }
      get_obj_for_encoding() {
        const txgroup = {
          txlist: this.txGroupHashes
        };
        return txgroup;
      }
      static from_obj_for_encoding(txgroupForEnc) {
        const txn = Object.create(this.prototype);
        txn.name = "Transaction group";
        txn.tag = Buffer.from("TG");
        txn.txGroupHashes = [];
        for (const hash of txgroupForEnc.txlist) {
          txn.txGroupHashes.push(Buffer.from(hash));
        }
        return txn;
      }
      toByte() {
        return encode2(this.get_obj_for_encoding());
      }
    };
    group_default = TxGroup;
  }
});

// node_modules/algosdk/dist/esm/src/logic/langspec.json
var langspec_default;
var init_langspec = __esm({
  "node_modules/algosdk/dist/esm/src/logic/langspec.json"() {
    langspec_default = {
      EvalMaxVersion: 6,
      LogicSigVersion: 5,
      Ops: [
        {
          Opcode: 0,
          Name: "err",
          Cost: 1,
          Size: 1,
          Doc: "Fail immediately.",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 1,
          Name: "sha256",
          Args: "B",
          Returns: "B",
          Cost: 35,
          Size: 1,
          Doc: "SHA256 hash of value A, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 2,
          Name: "keccak256",
          Args: "B",
          Returns: "B",
          Cost: 130,
          Size: 1,
          Doc: "Keccak256 hash of value A, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 3,
          Name: "sha512_256",
          Args: "B",
          Returns: "B",
          Cost: 45,
          Size: 1,
          Doc: "SHA512_256 hash of value A, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 4,
          Name: "ed25519verify",
          Args: "BBB",
          Returns: "U",
          Cost: 1900,
          Size: 1,
          Doc: 'for (data A, signature B, pubkey C) verify the signature of ("ProgData" || program_hash || data) against the pubkey => {0 or 1}',
          DocExtra: "The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at the second-to-last element on the stack, preceded by the data which was signed at the third-to-last element on the stack.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 5,
          Name: "ecdsa_verify",
          Args: "BBBBB",
          Returns: "U",
          Cost: 1700,
          Size: 2,
          Doc: "for (data A, signature B, C and pubkey D, E) verify the signature of the data against the pubkey => {0 or 1}",
          DocExtra: "The 32 byte Y-component of a public key is the last element on the stack, preceded by X-component of a pubkey, preceded by S and R components of a signature, preceded by the data that is fifth element on the stack. All values are big-endian encoded. The signed data must be 32 bytes long, and signatures in lower-S form are only accepted.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 6,
          Name: "ecdsa_pk_decompress",
          Args: "B",
          Returns: "BB",
          Cost: 650,
          Size: 2,
          Doc: "decompress pubkey A into components X, Y",
          DocExtra: "The 33 byte public key in a compressed form to be decompressed into X and Y (top) components. All values are big-endian encoded.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 7,
          Name: "ecdsa_pk_recover",
          Args: "BUBB",
          Returns: "BB",
          Cost: 2e3,
          Size: 2,
          Doc: "for (data A, recovery id B, signature C, D) recover a public key",
          DocExtra: "S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack and used to deriver a public key. All values are big-endian encoded. The signed data must be 32 bytes long.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 8,
          Name: "+",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A plus B. Fail on overflow.",
          DocExtra: "Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `addw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 9,
          Name: "-",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A minus B. Fail if B > A.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 10,
          Name: "/",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A divided by B (truncated division). Fail if B == 0.",
          DocExtra: "`divmodw` is available to divide the two-element values produced by `mulw` and `addw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 11,
          Name: "*",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A times B. Fail on overflow.",
          DocExtra: "Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `mulw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 12,
          Name: "<",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A less than B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 13,
          Name: ">",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A greater than B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 14,
          Name: "<=",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A less than or equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 15,
          Name: ">=",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A greater than or equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 16,
          Name: "&&",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not zero and B is not zero => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 17,
          Name: "||",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not zero or B is not zero => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 18,
          Name: "==",
          Args: "..",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 19,
          Name: "!=",
          Args: "..",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 20,
          Name: "!",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A == 0 yields 1; else 0",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 21,
          Name: "len",
          Args: "B",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "yields length of byte value A",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 22,
          Name: "itob",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "converts uint64 A to big endian bytes",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 23,
          Name: "btoi",
          Args: "B",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "converts bytes A as big endian to uint64",
          DocExtra: "`btoi` fails if the input is longer than 8 bytes.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 24,
          Name: "%",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A modulo B. Fail if B == 0.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 25,
          Name: "|",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-or B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 26,
          Name: "&",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-and B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 27,
          Name: "^",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-xor B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 28,
          Name: "~",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "bitwise invert value A",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 29,
          Name: "mulw",
          Args: "UU",
          Returns: "UU",
          Cost: 1,
          Size: 1,
          Doc: "A times B as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 30,
          Name: "addw",
          Args: "UU",
          Returns: "UU",
          Cost: 1,
          Size: 1,
          Doc: "A plus B as a 128-bit result. X is the carry-bit, Y is the low-order 64 bits.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 31,
          Name: "divmodw",
          Args: "UUUU",
          Returns: "UUUU",
          Cost: 20,
          Size: 1,
          Doc: "W,X = (A,B / C,D); Y,Z = (A,B modulo C,D)",
          DocExtra: "The notation J,K indicates that two uint64 values J and K are interpreted as a uint128 value, with J as the high uint64 and K the low.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 32,
          Name: "intcblock",
          Cost: 1,
          Size: 0,
          Doc: "prepare block of uint64 constants for use by intc",
          DocExtra: "`intcblock` loads following program bytes into an array of integer constants in the evaluator. These integer constants can be referred to by `intc` and `intc_*` which will push the value onto the stack. Subsequent calls to `intcblock` reset and replace the integer constants available to the script.",
          ImmediateNote: "{varuint length} [{varuint value}, ...]",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 33,
          Name: "intc",
          Returns: "U",
          Cost: 1,
          Size: 2,
          Doc: "Ith constant from intcblock",
          ImmediateNote: "{uint8 int constant index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 34,
          Name: "intc_0",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 0 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 35,
          Name: "intc_1",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 1 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 36,
          Name: "intc_2",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 2 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 37,
          Name: "intc_3",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 3 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 38,
          Name: "bytecblock",
          Cost: 1,
          Size: 0,
          Doc: "prepare block of byte-array constants for use by bytec",
          DocExtra: "`bytecblock` loads the following program bytes into an array of byte-array constants in the evaluator. These constants can be referred to by `bytec` and `bytec_*` which will push the value onto the stack. Subsequent calls to `bytecblock` reset and replace the bytes constants available to the script.",
          ImmediateNote: "{varuint length} [({varuint value length} bytes), ...]",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 39,
          Name: "bytec",
          Returns: "B",
          Cost: 1,
          Size: 2,
          Doc: "Ith constant from bytecblock",
          ImmediateNote: "{uint8 byte constant index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 40,
          Name: "bytec_0",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 0 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 41,
          Name: "bytec_1",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 1 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 42,
          Name: "bytec_2",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 2 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 43,
          Name: "bytec_3",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 3 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 44,
          Name: "arg",
          Returns: "B",
          Cost: 1,
          Size: 2,
          Doc: "Nth LogicSig argument",
          ImmediateNote: "{uint8 arg index N}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 45,
          Name: "arg_0",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 0",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 46,
          Name: "arg_1",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 1",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 47,
          Name: "arg_2",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 2",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 48,
          Name: "arg_3",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 3",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 49,
          Name: "txn",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of current transaction",
          DocExtra: "FirstValidTime causes the program to fail. The field is reserved for future use.",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 50,
          Name: "global",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "global field F",
          ImmediateNote: "{uint8 global field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 51,
          Name: "gtxn",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the Tth transaction in the current group",
          DocExtra: "for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group, `gtxn i field` is equivalent to `txn field`.",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 52,
          Name: "load",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "Ith scratch space value. All scratch spaces are 0 at program start.",
          ImmediateNote: "{uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 53,
          Name: "store",
          Args: ".",
          Cost: 1,
          Size: 2,
          Doc: "store A to the Ith scratch space",
          ImmediateNote: "{uint8 position in scratch space to store to}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 54,
          Name: "txna",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F of the current transaction",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 55,
          Name: "gtxna",
          Returns: ".",
          Cost: 1,
          Size: 4,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F from the Tth transaction in the current group",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 56,
          Name: "gtxns",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the Ath transaction in the current group",
          DocExtra: "for notes on transaction fields available, see `txn`. If top of stack is _i_, `gtxns field` is equivalent to `gtxn _i_ field`. gtxns exists so that _i_ can be calculated, often based on the index of the current transaction.",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 57,
          Name: "gtxnsa",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F from the Ath transaction in the current group",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 58,
          Name: "gload",
          Returns: ".",
          Cost: 1,
          Size: 3,
          Doc: "Ith scratch space value of the Tth transaction in the current group",
          DocExtra: "`gload` fails unless the requested transaction is an ApplicationCall and T < GroupIndex.",
          ImmediateNote: "{uint8 transaction group index} {uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 59,
          Name: "gloads",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "Ith scratch space value of the Ath transaction in the current group",
          DocExtra: "`gloads` fails unless the requested transaction is an ApplicationCall and A < GroupIndex.",
          ImmediateNote: "{uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 60,
          Name: "gaid",
          Returns: "U",
          Cost: 1,
          Size: 2,
          Doc: "ID of the asset or application created in the Tth transaction of the current group",
          DocExtra: "`gaid` fails unless the requested transaction created an asset or application and T < GroupIndex.",
          ImmediateNote: "{uint8 transaction group index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 61,
          Name: "gaids",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "ID of the asset or application created in the Ath transaction of the current group",
          DocExtra: "`gaids` fails unless the requested transaction created an asset or application and A < GroupIndex.",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 62,
          Name: "loads",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "Ath scratch space value.  All scratch spaces are 0 at program start.",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 63,
          Name: "stores",
          Args: "U.",
          Cost: 1,
          Size: 1,
          Doc: "store B to the Ath scratch space",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 64,
          Name: "bnz",
          Args: "U",
          Cost: 1,
          Size: 3,
          Doc: "branch to TARGET if value A is not zero",
          DocExtra: "The `bnz` instruction opcode 0x40 is followed by two immediate data bytes which are a high byte first and low byte second which together form a 16 bit offset which the instruction may branch to. For a bnz instruction at `pc`, if the last element of the stack is not zero then branch to instruction at `pc + 3 + N`, else proceed to next instruction at `pc + 3`. Branch targets must be aligned instructions. (e.g. Branching to the second byte of a 2 byte op will be rejected.) Starting at v4, the offset is treated as a signed 16 bit integer allowing for backward branches and looping. In prior version (v1 to v3), branch offsets are limited to forward branches only, 0-0x7fff.\n\nAt v2 it became allowed to branch to the end of the program exactly after the last instruction: bnz to byte N (with 0-indexing) was illegal for a TEAL program with N bytes before v2, and is legal after it. This change eliminates the need for a last instruction of no-op as a branch target at the end. (Branching beyond the end--in other words, to a byte larger than N--is still illegal and will cause the program to fail.)",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 65,
          Name: "bz",
          Args: "U",
          Cost: 1,
          Size: 3,
          Doc: "branch to TARGET if value A is zero",
          DocExtra: "See `bnz` for details on how branches work. `bz` inverts the behavior of `bnz`.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 66,
          Name: "b",
          Cost: 1,
          Size: 3,
          Doc: "branch unconditionally to TARGET",
          DocExtra: "See `bnz` for details on how branches work. `b` always jumps to the offset.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 67,
          Name: "return",
          Args: "U",
          Cost: 1,
          Size: 1,
          Doc: "use A as success value; end",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 68,
          Name: "assert",
          Args: "U",
          Cost: 1,
          Size: 1,
          Doc: "immediately fail unless A is a non-zero number",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 72,
          Name: "pop",
          Args: ".",
          Cost: 1,
          Size: 1,
          Doc: "discard A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 73,
          Name: "dup",
          Args: ".",
          Returns: "..",
          Cost: 1,
          Size: 1,
          Doc: "duplicate A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 74,
          Name: "dup2",
          Args: "..",
          Returns: "....",
          Cost: 1,
          Size: 1,
          Doc: "duplicate A and B",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 75,
          Name: "dig",
          Args: ".",
          Returns: "..",
          Cost: 1,
          Size: 2,
          Doc: "Nth value from the top of the stack. dig 0 is equivalent to dup",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 76,
          Name: "swap",
          Args: "..",
          Returns: "..",
          Cost: 1,
          Size: 1,
          Doc: "swaps A and B on stack",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 77,
          Name: "select",
          Args: "..U",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "selects one of two values based on top-of-stack: B if C != 0, else A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 78,
          Name: "cover",
          Args: ".",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "remove top of stack, and place it deeper in the stack such that N elements are above it. Fails if stack depth <= N.",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 79,
          Name: "uncover",
          Args: ".",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "remove the value at depth N in the stack and shift above items down so the Nth deep value is on top of the stack. Fails if stack depth <= N.",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 80,
          Name: "concat",
          Args: "BB",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "join A and B",
          DocExtra: "`concat` fails if the result would be greater than 4096 bytes.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 81,
          Name: "substring",
          Args: "B",
          Returns: "B",
          Cost: 1,
          Size: 3,
          Doc: "A range of bytes from A starting at S up to but not including E. If E < S, or either is larger than the array length, the program fails",
          ImmediateNote: "{uint8 start position} {uint8 end position}",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 82,
          Name: "substring3",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "A range of bytes from A starting at B up to but not including C. If C < B, or either is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 83,
          Name: "getbit",
          Args: ".U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "Bth bit of (byte-array or integer) A.",
          DocExtra: "see explanation of bit ordering in setbit",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 84,
          Name: "setbit",
          Args: ".UU",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C",
          DocExtra: "When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 85,
          Name: "getbyte",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "Bth byte of A, as an integer",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 86,
          Name: "setbyte",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "Copy of A with the Bth byte set to small integer (between 0..255) C",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 87,
          Name: "extract",
          Args: "B",
          Returns: "B",
          Cost: 1,
          Size: 3,
          Doc: "A range of bytes from A starting at S up to but not including S+L. If L is 0, then extract to the end of the string. If S or S+L is larger than the array length, the program fails",
          ImmediateNote: "{uint8 start position} {uint8 length}",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 88,
          Name: "extract3",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "A range of bytes from A starting at B up to but not including B+C. If B+C is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 89,
          Name: "extract_uint16",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A uint16 formed from a range of big-endian bytes from A starting at B up to but not including B+2. If B+2 is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 90,
          Name: "extract_uint32",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A uint32 formed from a range of big-endian bytes from A starting at B up to but not including B+4. If B+4 is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 91,
          Name: "extract_uint64",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A uint64 formed from a range of big-endian bytes from A starting at B up to but not including B+8. If B+8 is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 96,
          Name: "balance",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "get balance for account A, in microalgos. The balance is observed after the effects of previous transactions in the group, and after the fee for the current transaction is deducted.",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 97,
          Name: "app_opted_in",
          Args: ".U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if account A is opted in to application B, else 0",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: 1 if opted in and 0 otherwise.",
          Groups: ["State Access"]
        },
        {
          Opcode: 98,
          Name: "app_local_get",
          Args: ".B",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "local state of the key B in the current application in account A",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return: value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 99,
          Name: "app_local_get_ex",
          Args: ".UB",
          Returns: ".U",
          Cost: 1,
          Size: 1,
          Doc: "X is the local state of application B, key C in account A. Y is 1 if key existed, else 0",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 100,
          Name: "app_global_get",
          Args: "B",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "global state of the key A in the current application",
          DocExtra: "params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 101,
          Name: "app_global_get_ex",
          Args: "UB",
          Returns: ".U",
          Cost: 1,
          Size: 1,
          Doc: "X is the global state of application A, key B. Y is 1 if key existed, else 0",
          DocExtra: "params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 102,
          Name: "app_local_put",
          Args: ".B.",
          Cost: 1,
          Size: 1,
          Doc: "write C to key B in account A's local state of the current application",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), state key, value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 103,
          Name: "app_global_put",
          Args: "B.",
          Cost: 1,
          Size: 1,
          Doc: "write B to key A in the global state of the current application",
          Groups: ["State Access"]
        },
        {
          Opcode: 104,
          Name: "app_local_del",
          Args: ".B",
          Cost: 1,
          Size: 1,
          Doc: "delete key B from account A's local state of the current application",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), state key.\n\nDeleting a key which is already absent has no effect on the application local state. (In particular, it does _not_ cause the program to fail.)",
          Groups: ["State Access"]
        },
        {
          Opcode: 105,
          Name: "app_global_del",
          Args: "B",
          Cost: 1,
          Size: 1,
          Doc: "delete key A from the global state of the current application",
          DocExtra: "params: state key.\n\nDeleting a key which is already absent has no effect on the application global state. (In particular, it does _not_ cause the program to fail.)",
          Groups: ["State Access"]
        },
        {
          Opcode: 112,
          Name: "asset_holding_get",
          Args: ".U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: ["AssetBalance", "AssetFrozen"],
          ArgEnumTypes: "UU",
          Doc: "X is field F from account A's holding of asset B. Y is 1 if A is opted into B, else 0",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ address), asset id (or, since v4, a Txn.ForeignAssets offset). Return: did_exist flag (1 if the asset existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 asset holding field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 113,
          Name: "asset_params_get",
          Args: "U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "AssetTotal",
            "AssetDecimals",
            "AssetDefaultFrozen",
            "AssetUnitName",
            "AssetName",
            "AssetURL",
            "AssetMetadataHash",
            "AssetManager",
            "AssetReserve",
            "AssetFreeze",
            "AssetClawback",
            "AssetCreator"
          ],
          ArgEnumTypes: "UUUBBBBBBBBB",
          Doc: "X is field F from asset A. Y is 1 if A exists, else 0",
          DocExtra: "params: Txn.ForeignAssets offset (or, since v4, an _available_ asset id. Return: did_exist flag (1 if the asset existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 asset params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 114,
          Name: "app_params_get",
          Args: "U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "AppApprovalProgram",
            "AppClearStateProgram",
            "AppGlobalNumUint",
            "AppGlobalNumByteSlice",
            "AppLocalNumUint",
            "AppLocalNumByteSlice",
            "AppExtraProgramPages",
            "AppCreator",
            "AppAddress"
          ],
          ArgEnumTypes: "BBUUUUUBB",
          Doc: "X is field F from app A. Y is 1 if A exists, else 0",
          DocExtra: "params: Txn.ForeignApps offset or an _available_ app id. Return: did_exist flag (1 if the application existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 app params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 115,
          Name: "acct_params_get",
          Args: ".",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          Doc: "X is field F from account A. Y is 1 if A owns positive algos, else 0",
          ImmediateNote: "{uint8 account params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 120,
          Name: "min_balance",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "get minimum required balance for account A, in microalgos. Required balance is affected by [ASA](https://developer.algorand.org/docs/features/asa/#assets-overview) and [App](https://developer.algorand.org/docs/features/asc1/stateful/#minimum-balance-requirement-for-a-smart-contract) usage. When creating or opting into an app, the minimum balance grows before the app code runs, therefore the increase is visible there. When deleting or closing out, the minimum balance decreases after the app executes.",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 128,
          Name: "pushbytes",
          Returns: "B",
          Cost: 1,
          Size: 0,
          Doc: "immediate BYTES",
          DocExtra: "pushbytes args are not added to the bytecblock during assembly processes",
          ImmediateNote: "{varuint length} {bytes}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 129,
          Name: "pushint",
          Returns: "U",
          Cost: 1,
          Size: 0,
          Doc: "immediate UINT",
          DocExtra: "pushint args are not added to the intcblock during assembly processes",
          ImmediateNote: "{varuint int}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 136,
          Name: "callsub",
          Cost: 1,
          Size: 3,
          Doc: "branch unconditionally to TARGET, saving the next instruction on the call stack",
          DocExtra: "The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 137,
          Name: "retsub",
          Cost: 1,
          Size: 1,
          Doc: "pop the top instruction from the call stack and branch to it",
          DocExtra: "The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 144,
          Name: "shl",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A times 2^B, modulo 2^64",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 145,
          Name: "shr",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A divided by 2^B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 146,
          Name: "sqrt",
          Args: "U",
          Returns: "U",
          Cost: 4,
          Size: 1,
          Doc: "The largest integer I such that I^2 <= A",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 147,
          Name: "bitlen",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4",
          DocExtra: "bitlen interprets arrays as big-endian integers, unlike setbit/getbit",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 148,
          Name: "exp",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A raised to the Bth power. Fail if A == B == 0 and on overflow",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 149,
          Name: "expw",
          Args: "UU",
          Returns: "UU",
          Cost: 10,
          Size: 1,
          Doc: "A raised to the Bth power as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low. Fail if A == B == 0 or if the results exceeds 2^128-1",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 150,
          Name: "bsqrt",
          Args: "B",
          Returns: "B",
          Cost: 40,
          Size: 1,
          Doc: "The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 151,
          Name: "divw",
          Args: "UUU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A,B / C. Fail if C == 0 or if result overflows.",
          DocExtra: "The notation A,B indicates that A and B are interpreted as a uint128 value, with A as the high uint64 and B the low.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 160,
          Name: "b+",
          Args: "BB",
          Returns: "B",
          Cost: 10,
          Size: 1,
          Doc: "A plus B. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 161,
          Name: "b-",
          Args: "BB",
          Returns: "B",
          Cost: 10,
          Size: 1,
          Doc: "A minus B. A and B are interpreted as big-endian unsigned integers. Fail on underflow.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 162,
          Name: "b/",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A divided by B (truncated division). A and B are interpreted as big-endian unsigned integers. Fail if B is zero.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 163,
          Name: "b*",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A times B. A and B are interpreted as big-endian unsigned integers.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 164,
          Name: "b<",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is less than B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 165,
          Name: "b>",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is greater than B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 166,
          Name: "b<=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is less than or equal to B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 167,
          Name: "b>=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is greater than or equal to B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 168,
          Name: "b==",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is equal to B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 169,
          Name: "b!=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "0 if A is equal to B, else 1. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 170,
          Name: "b%",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A modulo B. A and B are interpreted as big-endian unsigned integers. Fail if B is zero.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 171,
          Name: "b|",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-or B. A and B are zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 172,
          Name: "b&",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-and B. A and B are zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 173,
          Name: "b^",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-xor B. A and B are zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 174,
          Name: "b~",
          Args: "B",
          Returns: "B",
          Cost: 4,
          Size: 1,
          Doc: "A with all bits inverted",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 175,
          Name: "bzero",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "zero filled byte-array of length A",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 176,
          Name: "log",
          Args: "B",
          Cost: 1,
          Size: 1,
          Doc: "write A to log state of the current application",
          DocExtra: "`log` fails if called more than MaxLogCalls times in a program, or if the sum of logged bytes exceeds 1024 bytes.",
          Groups: ["State Access"]
        },
        {
          Opcode: 177,
          Name: "itxn_begin",
          Cost: 1,
          Size: 1,
          Doc: "begin preparation of a new inner transaction in a new transaction group",
          DocExtra: "`itxn_begin` initializes Sender to the application address; Fee to the minimum allowable, taking into account MinTxnFee and credit from overpaying in earlier transactions; FirstValid/LastValid to the values in the invoking transaction, and all other fields to zero or empty values.",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 178,
          Name: "itxn_field",
          Args: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "set field F of the current inner transaction to A",
          DocExtra: "`itxn_field` fails if A is of the wrong type for F, including a byte array of the wrong size for use as an address when F is an address field. `itxn_field` also fails if A is an account, asset, or app that is not _available_, or an attempt is made extend an array field beyond the limit imposed by consensus parameters. (Addresses set into asset params of acfg transactions need not be _available_.)",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 179,
          Name: "itxn_submit",
          Cost: 1,
          Size: 1,
          Doc: "execute the current inner transaction group. Fail if executing this group would exceed the inner transaction limit, or if any transaction in the group fails.",
          DocExtra: "`itxn_submit` resets the current transaction so that it can not be resubmitted. A new `itxn_begin` is required to prepare another inner transaction.",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 180,
          Name: "itxn",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the last inner transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 181,
          Name: "itxna",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F of the last inner transaction",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 182,
          Name: "itxn_next",
          Cost: 1,
          Size: 1,
          Doc: "begin preparation of a new inner transaction in the same transaction group",
          DocExtra: "`itxn_next` initializes the transaction exactly as `itxn_begin` does",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 183,
          Name: "gitxn",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the Tth transaction in the last inner group submitted",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 184,
          Name: "gitxna",
          Returns: ".",
          Cost: 1,
          Size: 4,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F from the Tth transaction in the last inner group submitted",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 192,
          Name: "txnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ath value of the array field F of the current transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 193,
          Name: "gtxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ath value of the array field F from the Tth transaction in the current group",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 194,
          Name: "gtxnsas",
          Args: "UU",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Bth value of the array field F from the Ath transaction in the current group",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 195,
          Name: "args",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "Ath LogicSig argument",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 196,
          Name: "gloadss",
          Args: "UU",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "Bth scratch space value of the Ath transaction in the current group",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 197,
          Name: "itxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "Ath value of the array field F of the last inner transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 198,
          Name: "gitxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          Doc: "Ath value of the array field F from the Tth transaction in the last inner group submitted",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        }
      ]
    };
  }
});

// node_modules/algosdk/dist/esm/src/logic/logic.js
var logic_exports = {};
__export(logic_exports, {
  checkByteConstBlock: () => checkByteConstBlock,
  checkIntConstBlock: () => checkIntConstBlock,
  checkProgram: () => checkProgram,
  checkPushByteOp: () => checkPushByteOp,
  checkPushIntOp: () => checkPushIntOp,
  langspecEvalMaxVersion: () => langspecEvalMaxVersion,
  langspecLogicSigVersion: () => langspecLogicSigVersion,
  parseUvarint: () => parseUvarint,
  readProgram: () => readProgram
});
function parseUvarint(array) {
  let x = 0;
  let s = 0;
  for (let i = 0; i < array.length; i++) {
    const b = array[i];
    if (b < 128) {
      if (i > 9 || i === 9 && b > 1) {
        return [0, -(i + 1)];
      }
      return [x | b << s, i + 1];
    }
    x += (b & 127) << s;
    s += 7;
  }
  return [0, 0];
}
function readIntConstBlock(program, pc) {
  let size = 1;
  const parsed = parseUvarint(program.slice(pc + size));
  const numInts = parsed[0];
  let bytesUsed = parsed[1];
  if (bytesUsed <= 0) {
    throw new Error(`could not decode int const block size at pc=${pc + size}`);
  }
  const ints = [];
  size += bytesUsed;
  for (let i = 0; i < numInts; i++) {
    if (pc + size >= program.length) {
      throw new Error("intcblock ran past end of program");
    }
    let numberFound;
    [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));
    if (bytesUsed <= 0) {
      throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);
    }
    ints.push(numberFound);
    size += bytesUsed;
  }
  return [size, ints];
}
function readByteConstBlock(program, pc) {
  let size = 1;
  const parsed = parseUvarint(program.slice(pc + size));
  const numInts = parsed[0];
  let bytesUsed = parsed[1];
  if (bytesUsed <= 0) {
    throw new Error(`could not decode []byte const block size at pc=${pc + size}`);
  }
  const byteArrays = [];
  size += bytesUsed;
  for (let i = 0; i < numInts; i++) {
    if (pc + size >= program.length) {
      throw new Error("bytecblock ran past end of program");
    }
    let itemLen;
    [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
    if (bytesUsed <= 0) {
      throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);
    }
    size += bytesUsed;
    if (pc + size + itemLen > program.length) {
      throw new Error("bytecblock ran past end of program");
    }
    const byteArray = program.slice(pc + size, pc + size + itemLen);
    byteArrays.push(byteArray);
    size += itemLen;
  }
  return [size, byteArrays];
}
function readPushIntOp(program, pc) {
  let size = 1;
  const [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));
  if (bytesUsed <= 0) {
    throw new Error(`could not decode push int const at pc=${pc + size}`);
  }
  size += bytesUsed;
  return [size, numberFound];
}
function readPushByteOp(program, pc) {
  let size = 1;
  const [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
  if (bytesUsed <= 0) {
    throw new Error(`could not decode push []byte const size at pc=${pc + size}`);
  }
  size += bytesUsed;
  if (pc + size + itemLen > program.length) {
    throw new Error("pushbytes ran past end of program");
  }
  const byteArray = program.slice(pc + size, pc + size + itemLen);
  size += itemLen;
  return [size, byteArray];
}
function readProgram(program, args) {
  const intcblockOpcode = 32;
  const bytecblockOpcode = 38;
  const pushbytesOpcode = 128;
  const pushintOpcode = 129;
  if (!program) {
    throw new Error("empty program");
  }
  if (typeof args === "undefined") {
    args = [];
  }
  if (!Array.isArray(args)) {
    throw new Error("invalid arguments");
  }
  const [version, vlen] = parseUvarint(program);
  if (vlen <= 0) {
    throw new Error("version parsing error");
  }
  if (version > langspec_default.EvalMaxVersion) {
    throw new Error("unsupported version");
  }
  let cost = 0;
  let { length } = program;
  for (const arg of args) {
    length += arg.length;
  }
  if (length > maxLength) {
    throw new Error("program too long");
  }
  if (!opcodes) {
    opcodes = {};
    for (const op of langspec_default.Ops) {
      opcodes[op.Opcode] = op;
    }
  }
  let pc = vlen;
  let ints = [];
  let byteArrays = [];
  while (pc < program.length) {
    const op = opcodes[program[pc]];
    if (op === void 0) {
      throw new Error("invalid instruction");
    }
    cost += op.Cost;
    let size = op.Size;
    if (size === 0) {
      switch (op.Opcode) {
        case intcblockOpcode: {
          let foundInts;
          [size, foundInts] = readIntConstBlock(program, pc);
          ints = ints.concat(foundInts);
          break;
        }
        case bytecblockOpcode: {
          let foundByteArrays;
          [size, foundByteArrays] = readByteConstBlock(program, pc);
          byteArrays = byteArrays.concat(foundByteArrays);
          break;
        }
        case pushintOpcode: {
          let foundInt;
          [size, foundInt] = readPushIntOp(program, pc);
          ints.push(foundInt);
          break;
        }
        case pushbytesOpcode: {
          let foundByteArray;
          [size, foundByteArray] = readPushByteOp(program, pc);
          byteArrays.push(foundByteArray);
          break;
        }
        default: {
          throw new Error("invalid instruction");
        }
      }
    }
    pc += size;
  }
  if (version < 4 && cost > maxCost) {
    throw new Error("program too costly for version < 4. consider using v4.");
  }
  return [ints, byteArrays, true];
}
function checkProgram(program, args) {
  const [, , success] = readProgram(program, args);
  return success;
}
function checkIntConstBlock(program, pc) {
  const [size] = readIntConstBlock(program, pc);
  return size;
}
function checkByteConstBlock(program, pc) {
  const [size] = readByteConstBlock(program, pc);
  return size;
}
function checkPushIntOp(program, pc) {
  const [size] = readPushIntOp(program, pc);
  return size;
}
function checkPushByteOp(program, pc) {
  const [size] = readPushByteOp(program, pc);
  return size;
}
var opcodes, maxCost, maxLength, langspecEvalMaxVersion, langspecLogicSigVersion;
var init_logic = __esm({
  "node_modules/algosdk/dist/esm/src/logic/logic.js"() {
    init_langspec();
    maxCost = 2e4;
    maxLength = 1e3;
    langspecEvalMaxVersion = langspec_default.EvalMaxVersion;
    langspecLogicSigVersion = langspec_default.LogicSigVersion;
  }
});

// node_modules/algosdk/dist/esm/src/multisig.js
function createMultisigTransaction(txn, { version, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const subsigs = pks.map((pk) => ({ pk: Buffer.from(pk) }));
  const msig = {
    v: version,
    thr: threshold,
    subsig: subsigs
  };
  const txnForEncoding = txn.get_obj_for_encoding();
  const signedTxn = {
    msig,
    txn: txnForEncoding
  };
  const msigAddr = fromMultisigPreImg({
    version,
    threshold,
    pks
  });
  if (encodeAddress(txnForEncoding.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = Buffer.from(msigAddr);
  }
  return new Uint8Array(encode2(signedTxn));
}
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version, threshold, pks }) {
  const encodedMsig = createMultisigTransaction(txn, {
    version,
    threshold,
    addrs: pks.map((pk) => encodeAddress(pk))
  });
  const signedTxn = decode2(encodedMsig);
  let keyExist = false;
  signedTxn.msig.subsig.forEach((subsig, i) => {
    if (bytesEqual(subsig.pk, myPk)) {
      keyExist = true;
      signedTxn.msig.subsig[i].s = rawSig;
    }
  });
  if (keyExist === false) {
    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
  }
  const msigAddr = fromMultisigPreImg({
    version,
    threshold,
    pks
  });
  if (encodeAddress(signedTxn.txn.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = Buffer.from(msigAddr);
  }
  return new Uint8Array(encode2(signedTxn));
}
function mergeMultisigTransactions(multisigTxnBlobs) {
  if (multisigTxnBlobs.length < 2) {
    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
  }
  const refSigTx = decode2(multisigTxnBlobs[0]);
  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();
  const refAuthAddr = refSigTx.sgnr ? encodeAddress(refSigTx.sgnr) : void 0;
  const refPreImage = {
    version: refSigTx.msig.v,
    threshold: refSigTx.msig.thr,
    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
  };
  const refMsigAddr = encodeAddress(fromMultisigPreImg(refPreImage));
  let newSubsigs = refSigTx.msig.subsig;
  for (let i = 0; i < multisigTxnBlobs.length; i++) {
    const unisig = decode2(multisigTxnBlobs[i]);
    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
    if (unisigAlgoTxn.txID() !== refTxID) {
      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
    }
    const authAddr = unisig.sgnr ? encodeAddress(unisig.sgnr) : void 0;
    if (refAuthAddr !== authAddr) {
      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
    }
    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    const preimg = {
      version: unisig.msig.v,
      threshold: unisig.msig.thr,
      pks: unisig.msig.subsig.map((subsig) => subsig.pk)
    };
    const msgigAddr = encodeAddress(fromMultisigPreImg(preimg));
    if (refMsigAddr !== msgigAddr) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {
      const current = refSigTx.msig.subsig[index];
      if (current.s) {
        if (uniSubsig.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {
          throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
        }
        return {
          pk: current.pk,
          s: current.s
        };
      }
      if (uniSubsig.s) {
        return {
          pk: current.pk,
          s: uniSubsig.s
        };
      }
      return current;
    });
  }
  const msig = {
    v: refSigTx.msig.v,
    thr: refSigTx.msig.thr,
    subsig: newSubsigs
  };
  const signedTxn = {
    msig,
    txn: refSigTx.txn
  };
  if (typeof refAuthAddr !== "undefined") {
    signedTxn.sgnr = Buffer.from(decodeAddress(refAuthAddr).publicKey);
  }
  return new Uint8Array(encode2(signedTxn));
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version = msig.v;
  const threshold = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold) {
    return false;
  }
  let pk;
  try {
    pk = fromMultisigPreImg({ version, threshold, pks });
  } catch (e) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold) {
    return false;
  }
  return true;
}
function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
  const expectedFromRaw = fromMultisigPreImgAddrs({
    version,
    threshold,
    addrs
  });
  if (!Object.prototype.hasOwnProperty.call(txn, "from")) {
    txn.from = expectedFromRaw;
  }
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const txnAlreadyBuilt = txn instanceof Transaction;
  let algoTxn;
  let blob;
  if (txnAlreadyBuilt) {
    algoTxn = txn;
    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, { version, threshold, pks }, sk);
  } else {
    algoTxn = new MultisigTransaction(txn);
    blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);
  }
  return {
    txID: algoTxn.txID().toString(),
    blob
  };
}
function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode2(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignTxn({ version, threshold, pks }, sk);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function appendSignRawMultisigSignature(multisigTxnBlob, { version, threshold, addrs }, signerAddr, signature) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode2(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({ version, threshold, pks }, signerAddr, signature);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function multisigAddress({ version, threshold, addrs }) {
  return fromMultisigPreImgAddrs({ version, threshold, addrs });
}
var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG, MULTISIG_MERGE_MISMATCH_ERROR_MSG, MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG, MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG, MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG, MULTISIG_KEY_NOT_EXIST_ERROR_MSG, MULTISIG_NO_MUTATE_ERROR_MSG, MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG, MULTISIG_SIGNATURE_LENGTH_ERROR_MSG, MultisigTransaction;
var init_multisig = __esm({
  "node_modules/algosdk/dist/esm/src/multisig.js"() {
    init_naclWrappers();
    init_address();
    init_encoding();
    init_transaction();
    init_utils();
    MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
    MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
    MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
    MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
    MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
    MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
    MULTISIG_NO_MUTATE_ERROR_MSG = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
    MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.";
    MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
    MultisigTransaction = class extends Transaction {
      addLease() {
        throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
      }
      addRekey() {
        throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
      }
      signTxn(sk) {
        throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);
      }
      partialSignTxn({ version, threshold, pks }, sk) {
        const myPk = keyPairFromSecretKey(sk).publicKey;
        return createMultisigTransactionWithSignature(this, { rawSig: this.rawSignTxn(sk), myPk }, { version, threshold, pks });
      }
      partialSignWithMultisigSignature(metadata, signerAddr, signature) {
        if (!isValidSignatureLength(signature.length)) {
          throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
        }
        return createMultisigTransactionWithSignature(this, {
          rawSig: signature,
          myPk: decodeAddress(signerAddr).publicKey
        }, metadata);
      }
      static from_obj_for_encoding(txnForEnc) {
        return super.from_obj_for_encoding(txnForEnc);
      }
    };
  }
});

// node_modules/algosdk/dist/esm/src/logicsig.js
var logicsig_exports = {};
__export(logicsig_exports, {
  LogicSig: () => LogicSig,
  LogicSigAccount: () => LogicSigAccount,
  logicSigFromByte: () => logicSigFromByte,
  makeLogicSig: () => makeLogicSig,
  sanityCheckProgram: () => sanityCheckProgram,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram
});
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x) => blankSpaceOrd <= x && x <= tildeOrd;
  const isAsciiPrintable = program.every((x) => x === lineBreakOrd || isPrintable(x));
  if (isAsciiPrintable) {
    const programStr = Buffer.from(program).toString();
    if (isValidAddress(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (Buffer.from(programStr, "base64").toString("base64") === programStr)
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
function makeLogicSig(program, args) {
  return new LogicSig(program, args);
}
function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
  if (!lsig.verify(lsigAddress)) {
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  }
  const signedTxn = {
    lsig: lsig.get_obj_for_encoding(),
    txn: txn.get_obj_for_encoding()
  };
  if (!bytesEqual(lsigAddress, txn.from.publicKey)) {
    signedTxn.sgnr = Buffer.from(lsigAddress);
  }
  return {
    txID: txn.txID().toString(),
    blob: encode2(signedTxn)
  };
}
function signLogicSigTransactionObject(txn, lsigObject) {
  let lsig;
  let lsigAddress;
  if (lsigObject instanceof LogicSigAccount) {
    lsig = lsigObject.lsig;
    lsigAddress = decodeAddress(lsigObject.address()).publicKey;
  } else {
    lsig = lsigObject;
    if (lsig.sig) {
      lsigAddress = txn.from.publicKey;
    } else if (lsig.msig) {
      const msigMetadata = {
        version: lsig.msig.v,
        threshold: lsig.msig.thr,
        pks: lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      lsigAddress = fromMultisigPreImg(msigMetadata);
    } else {
      lsigAddress = decodeAddress(lsig.address()).publicKey;
    }
  }
  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
}
function signLogicSigTransaction(txn, lsigObject) {
  const algoTxn = instantiateTxnIfNeeded(txn);
  return signLogicSigTransactionObject(algoTxn, lsigObject);
}
function logicSigFromByte(encoded) {
  return LogicSig.fromByte(encoded);
}
function tealSign(sk, data, programHash) {
  const parts = concatArrays(decodeAddress(programHash).publicKey, data);
  const toBeSigned = Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
  return sign(toBeSigned, sk);
}
function tealSignFromProgram(sk, data, program) {
  const lsig = new LogicSig(program);
  const contractAddress = lsig.address();
  return tealSign(sk, data, contractAddress);
}
var LogicSig, LogicSigAccount, SIGN_PROGRAM_DATA_PREFIX;
var init_logicsig = __esm({
  "node_modules/algosdk/dist/esm/src/logicsig.js"() {
    init_naclWrappers();
    init_address();
    init_encoding();
    init_multisig();
    init_utils();
    init_transaction();
    init_address();
    LogicSig = class {
      constructor(program, programArgs) {
        this.tag = Buffer.from("Program");
        if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {
          throw new TypeError("Invalid arguments");
        }
        let args;
        if (programArgs != null)
          args = programArgs.map((arg) => new Uint8Array(arg));
        sanityCheckProgram(program);
        this.logic = program;
        this.args = args;
        this.sig = void 0;
        this.msig = void 0;
      }
      get_obj_for_encoding() {
        const obj = {
          l: this.logic
        };
        if (this.args) {
          obj.arg = this.args;
        }
        if (this.sig) {
          obj.sig = this.sig;
        } else if (this.msig) {
          obj.msig = this.msig;
        }
        return obj;
      }
      static from_obj_for_encoding(encoded) {
        const lsig = new LogicSig(encoded.l, encoded.arg);
        lsig.sig = encoded.sig;
        lsig.msig = encoded.msig;
        return lsig;
      }
      verify(publicKey) {
        if (this.sig && this.msig) {
          return false;
        }
        try {
          sanityCheckProgram(this.logic);
        } catch (e) {
          return false;
        }
        const toBeSigned = concatArrays(this.tag, this.logic);
        if (!this.sig && !this.msig) {
          const hash = genericHash(toBeSigned);
          return arrayEqual(hash, publicKey);
        }
        if (this.sig) {
          return verify(toBeSigned, this.sig, publicKey);
        }
        return verifyMultisig(toBeSigned, this.msig, publicKey);
      }
      address() {
        const toBeSigned = concatArrays(this.tag, this.logic);
        const hash = genericHash(toBeSigned);
        return encodeAddress(new Uint8Array(hash));
      }
      sign(secretKey, msig) {
        if (msig == null) {
          this.sig = this.signProgram(secretKey);
        } else {
          const subsigs = msig.addrs.map((addr) => ({
            pk: decodeAddress(addr).publicKey
          }));
          this.msig = {
            v: msig.version,
            thr: msig.threshold,
            subsig: subsigs
          };
          const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
          this.msig.subsig[index].s = sig;
        }
      }
      appendToMultisig(secretKey) {
        if (this.msig === void 0) {
          throw new Error("no multisig present");
        }
        const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
        this.msig.subsig[index].s = sig;
      }
      signProgram(secretKey) {
        const toBeSigned = concatArrays(this.tag, this.logic);
        const sig = sign(toBeSigned, secretKey);
        return sig;
      }
      singleSignMultisig(secretKey, msig) {
        let index = -1;
        const myPk = keyPairFromSecretKey(secretKey).publicKey;
        for (let i = 0; i < msig.subsig.length; i++) {
          const { pk } = msig.subsig[i];
          if (arrayEqual(pk, myPk)) {
            index = i;
            break;
          }
        }
        if (index === -1) {
          throw new Error("invalid secret key");
        }
        const sig = this.signProgram(secretKey);
        return [sig, index];
      }
      toByte() {
        return encode2(this.get_obj_for_encoding());
      }
      static fromByte(encoded) {
        const decodedObj = decode2(encoded);
        return LogicSig.from_obj_for_encoding(decodedObj);
      }
    };
    LogicSigAccount = class {
      constructor(program, args) {
        this.lsig = new LogicSig(program, args);
        this.sigkey = void 0;
      }
      get_obj_for_encoding() {
        const obj = {
          lsig: this.lsig.get_obj_for_encoding()
        };
        if (this.sigkey) {
          obj.sigkey = this.sigkey;
        }
        return obj;
      }
      static from_obj_for_encoding(encoded) {
        const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);
        lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
        lsigAccount.sigkey = encoded.sigkey;
        return lsigAccount;
      }
      toByte() {
        return encode2(this.get_obj_for_encoding());
      }
      static fromByte(encoded) {
        const decodedObj = decode2(encoded);
        return LogicSigAccount.from_obj_for_encoding(decodedObj);
      }
      isDelegated() {
        return !!(this.lsig.sig || this.lsig.msig);
      }
      verify() {
        const addr = this.address();
        return this.lsig.verify(decodeAddress(addr).publicKey);
      }
      address() {
        if (this.lsig.sig && this.lsig.msig) {
          throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
        }
        if (this.lsig.sig) {
          if (!this.sigkey) {
            throw new Error("Signing key for delegated account is missing");
          }
          return encodeAddress(this.sigkey);
        }
        if (this.lsig.msig) {
          const msigMetadata = {
            version: this.lsig.msig.v,
            threshold: this.lsig.msig.thr,
            pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
          };
          return encodeAddress(fromMultisigPreImg(msigMetadata));
        }
        return this.lsig.address();
      }
      signMultisig(msig, secretKey) {
        this.lsig.sign(secretKey, msig);
      }
      appendToMultisig(secretKey) {
        this.lsig.appendToMultisig(secretKey);
      }
      sign(secretKey) {
        this.lsig.sign(secretKey);
        this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
      }
    };
    SIGN_PROGRAM_DATA_PREFIX = Buffer.from("ProgData");
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/templates.js
var require_templates = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/templates.js"(exports2, module2) {
    var address = (init_address(), __toCommonJS(address_exports));
    function putUvarint(buf, x) {
      let i = 0;
      while (x > 128) {
        buf.push(x & 255 | 128);
        x >>= 7;
        i += 1;
      }
      buf.push(x & 255);
      return i + 1;
    }
    var valTypes = {
      INT: 1,
      ADDRESS: 2,
      BASE64: 3
    };
    function inject(orig, offsets, values, valueTypes) {
      if (offsets.length !== values.length || offsets.length !== valueTypes.length) {
        throw new Error("Lengths do not match");
      }
      let res = orig;
      function replace(arr, newVal, offset, placeholderLength) {
        const beforeReplacement = arr.slice(0, offset);
        const afterReplacement = arr.slice(offset + placeholderLength, arr.length);
        const chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];
        return Buffer.concat(chunks);
      }
      for (let i = 0; i < offsets.length; i++) {
        let decodedLength = 0;
        let val = values[i];
        const valType = valueTypes[i];
        switch (valType) {
          case valTypes.INT:
            const intBuf = [];
            decodedLength = putUvarint(intBuf, val);
            res = replace(res, intBuf, offsets[i], 1);
            break;
          case valTypes.ADDRESS:
            val = address.decodeAddress(val);
            res = replace(res, val.publicKey, offsets[i], 32);
            break;
          case valTypes.BASE64:
            const lenBuf = [];
            val = Buffer.from(val, "base64");
            putUvarint(lenBuf, val.length);
            val = Buffer.concat([Buffer.from(lenBuf), val]);
            res = replace(res, val, offsets[i], 33);
            break;
          default:
            throw new Error("unrecognized value type");
        }
        if (decodedLength !== 0) {
          for (let o = 0; o < offsets.length; o++) {
            offsets[o] += decodedLength - 1;
          }
        }
      }
      return res;
    }
    module2.exports = { inject, valTypes };
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/dynamicfee.js
var require_dynamicfee = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/dynamicfee.js"(exports2, module2) {
    var address = (init_address(), __toCommonJS(address_exports));
    var encoding = (init_encoding(), __toCommonJS(encoding_exports));
    var group = (init_group(), __toCommonJS(group_exports));
    var logic = (init_logic(), __toCommonJS(logic_exports));
    var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
    var nacl2 = (init_naclWrappers(), __toCommonJS(naclWrappers_exports));
    var templates = require_templates();
    var transaction = (init_transaction(), __toCommonJS(transaction_exports));
    var DynamicFee = class {
      constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {
        if (!Number.isSafeInteger(amount) || amount < 0)
          throw Error("amount must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(firstValid) || firstValid < 0)
          throw Error("firstValid must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(lastValid) || lastValid < 0)
          throw Error("lastValid must be a positive number and smaller than 2^53-1");
        if (typeof closeRemainder === "undefined") {
          closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;
        }
        if (typeof lease === "undefined") {
          const leaseBytes = nacl2.randomBytes(32);
          lease = Buffer.from(leaseBytes).toString("base64");
        }
        const referenceProgramB64 = "ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          5,
          6,
          7,
          11,
          44,
          76
        ];
        const injectionVector = [
          amount,
          firstValid,
          lastValid,
          receiver,
          closeRemainder,
          lease
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS,
          templates.valTypes.ADDRESS,
          templates.valTypes.BASE64
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = new logicSig.LogicSig(injectedBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function signDynamicFee(contract, secretKey, genesisHash) {
      const programOutputs = logic.readProgram(contract, void 0);
      const ints = programOutputs[0];
      const byteArrays = programOutputs[1];
      const keys = nacl2.keyPairFromSecretKey(secretKey);
      const from = address.encodeAddress(keys.publicKey);
      const to = address.encodeAddress(byteArrays[0]);
      const fee = 0;
      const amount = ints[2];
      const closeRemainderTo = address.encodeAddress(byteArrays[1]);
      const firstRound = ints[3];
      const lastRound = ints[4];
      const lease = new Uint8Array(byteArrays[2]);
      const txn = {
        from,
        to,
        fee,
        amount,
        closeRemainderTo,
        firstRound,
        lastRound,
        genesisHash,
        type: "pay",
        lease
      };
      const lsig = new logicSig.LogicSig(contract, void 0);
      lsig.sign(secretKey);
      return { txn, lsig };
    }
    function getDynamicFeeTransactions(txn, lsig, privateKey, fee) {
      if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {
        throw new Error("invalid signature");
      }
      txn.fee = fee;
      if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {
        txn.fee = transaction.ALGORAND_MIN_TX_FEE;
      }
      const keys = nacl2.keyPairFromSecretKey(privateKey);
      const from = address.encodeAddress(keys.publicKey);
      const { lease } = txn;
      delete txn.lease;
      const txnObj = new transaction.Transaction(txn);
      txnObj.addLease(lease, fee);
      const feePayTxn = {
        from,
        to: txn.from,
        fee,
        amount: txnObj.fee,
        firstRound: txn.firstRound,
        lastRound: txn.lastRound,
        genesisHash: txn.genesisHash,
        type: "pay"
      };
      const feePayTxnObj = new transaction.Transaction(feePayTxn);
      feePayTxnObj.addLease(lease, fee);
      const txnGroup = group.assignGroupID([feePayTxnObj, txnObj], void 0);
      const feePayTxnWithGroup = txnGroup[0];
      const txnObjWithGroup = txnGroup[1];
      const lstx = {
        lsig: lsig.get_obj_for_encoding(),
        txn: txnObjWithGroup.get_obj_for_encoding()
      };
      const stx1 = feePayTxnWithGroup.signTxn(privateKey);
      const stx2 = encoding.encode(lstx);
      const concatStx = new Uint8Array(stx1.length + stx2.length);
      concatStx.set(stx1);
      concatStx.set(stx2, stx1.length);
      return concatStx;
    }
    module2.exports = {
      DynamicFee,
      getDynamicFeeTransactions,
      signDynamicFee
    };
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key, message) {
          return new HmacSha256(key, is2242, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key) {
          return new HmacSha256(key, is2242);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createHmacOutputMethod(type, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f & g ^ ~f & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is2242, sharedMemory) {
        var i, type = typeof key;
        if (type === "string") {
          var bytes = [], length = key.length, index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is2242, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW2 = typeof window === "object";
      var root2 = WINDOW2 ? window : {};
      if (root2.JS_SHA3_NO_WINDOW) {
        WINDOW2 = false;
      }
      var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
      var NODE_JS2 = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      } else if (WEB_WORKER2) {
        root2 = self;
      }
      var COMMON_JS2 = !root2.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var ARRAY_BUFFER2 = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT2 = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES2 = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER2 && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod2 = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method2, createMethod3, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES2.length; ++i2) {
          var type = OUTPUT_TYPES2[i2];
          method2[type] = createMethod3(bits2, padding, type);
        }
        return method2;
      };
      var createMethod2 = function(bits2, padding) {
        var method2 = createOutputMethod2(bits2, padding, "hex");
        method2.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        return createOutputMethods(method2, createOutputMethod2, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method2 = createShakeOutputMethod(bits2, padding, "hex");
        method2.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method2.update = function(message, outputBits) {
          return method2.create(outputBits).update(message);
        };
        return createOutputMethods(method2, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method2 = createCshakeOutputMethod(bits2, padding, "hex");
        method2.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method2.update = function(message, outputBits, n, s) {
          return method2.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method2, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method2 = createKmacOutputMethod(bits2, padding, "hex");
        method2.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method2.update = function(key, message, outputBits, s) {
          return method2.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method2, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm2 = algorithms[i];
        var bits = algorithm2.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm2.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm2.createMethod(bits[j], algorithm2.padding);
          if (algorithm2.name !== "sha3") {
            var newMethodName = algorithm2.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks2 = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks2[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks2[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks2[i2 >> 2] |= message[index] << SHIFT2[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i2 >> 2] |= code << SHIFT2[i2++ & 3];
              } else if (code < 2048) {
                blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks2[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks2[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks2[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks2[0] = blocks2[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks2[i2] = 0;
          }
        }
        blocks2[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks2[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS2) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root2[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD2) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/htlc.js
var require_htlc = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/htlc.js"(exports2, module2) {
    var sha256 = require_sha256();
    var { keccak256 } = require_sha3();
    var logic = (init_logic(), __toCommonJS(logic_exports));
    var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
    var templates = require_templates();
    var transaction = (init_transaction(), __toCommonJS(transaction_exports));
    var HTLC = class {
      constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        let referenceProgramB64 = "";
        if (hashFunction === "sha256") {
          referenceProgramB64 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==";
        } else if (hashFunction === "keccak256") {
          referenceProgramB64 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==";
        } else {
          throw Error("hash function unrecognized");
        }
        const hashImageBytes = Buffer.from(hashImage, "base64");
        if (hashImageBytes.length !== 32)
          throw Error("hash image must be 32 bytes");
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          3,
          6,
          10,
          42,
          76
        ];
        const injectionVector = [maxFee, expiryRound, receiver, hashImage, owner];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS,
          templates.valTypes.BASE64,
          templates.valTypes.ADDRESS
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = new logicSig.LogicSig(injectedBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {
      const preImageBytes = Buffer.from(preImageAsBase64, "base64");
      const readResult = logic.readProgram(contract, void 0);
      const ints = readResult[0];
      const byteArrays = readResult[1];
      const expectedHashedOutput = byteArrays[1];
      const hashFunction = contract[contract.length - 15];
      if (hashFunction === 1) {
        const hash = sha256.create();
        hash.update(preImageBytes);
        const actualHashedOutput = Buffer.from(hash.hex(), "hex");
        if (!actualHashedOutput.equals(expectedHashedOutput)) {
          throw new Error("sha256 hash of preimage did not match stored contract hash");
        }
      } else if (hashFunction === 2) {
        const hash = keccak256.create();
        hash.update(preImageBytes);
        const actualHashedOutput = Buffer.from(hash.hex(), "hex");
        if (!actualHashedOutput.equals(expectedHashedOutput)) {
          throw new Error("keccak256 hash of preimage did not match stored contract hash");
        }
      } else {
        throw new Error("hash function in contract unrecognized");
      }
      const args = [preImageBytes];
      const lsig = new logicSig.LogicSig(contract, args);
      delete txn.to;
      const maxFee = ints[0];
      const tempTxn = new transaction.Transaction(txn);
      if (tempTxn.fee > maxFee) {
        throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${maxFee.toString()}`);
      }
      return logicSig.signLogicSigTransaction(txn, lsig);
    }
    module2.exports = {
      HTLC,
      signTransactionWithHTLCUnlock
    };
  }
});

// node_modules/algosdk/dist/esm/src/types/transactions/encoded.js
var init_encoded = __esm({
  "node_modules/algosdk/dist/esm/src/types/transactions/encoded.js"() {
  }
});

// node_modules/algosdk/dist/esm/src/types/transactions/index.js
var init_transactions = __esm({
  "node_modules/algosdk/dist/esm/src/types/transactions/index.js"() {
    init_base();
    init_encoded();
  }
});

// node_modules/algosdk/dist/esm/src/makeTxn.js
var makeTxn_exports = {};
__export(makeTxn_exports, {
  OnApplicationComplete: () => OnApplicationComplete,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn: () => makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn: () => makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxn: () => makeAssetConfigTxn,
  makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxn: () => makeAssetCreateTxn,
  makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxn: () => makeAssetDestroyTxn,
  makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxn: () => makeAssetFreezeTxn,
  makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxn: () => makeAssetTransferTxn,
  makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
  makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makePaymentTxn: () => makePaymentTxn,
  makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject
});
function makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {
  const o = {
    from,
    to,
    amount,
    closeRemainderTo,
    note,
    suggestedParams,
    type: TransactionType.pay,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makePaymentTxn(from, to, fee, amount, closeRemainderTo, firstRound, lastRound, note, genesisHash, genesisID, rekeyTo) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo);
}
function makePaymentTxnWithSuggestedParamsFromObject(o) {
  return makePaymentTxnWithSuggestedParams(o.from, o.to, o.amount, o.closeRemainderTo, o.note, o.suggestedParams, o.rekeyTo);
}
function makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
  const o = {
    from,
    note,
    voteKey,
    selectionKey,
    voteFirst,
    voteLast,
    voteKeyDilution,
    suggestedParams,
    type: TransactionType.keyreg,
    reKeyTo: rekeyTo,
    nonParticipation,
    stateProofKey
  };
  return new Transaction(o);
}
function makeKeyRegistrationTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation, stateProofKey);
}
function makeKeyRegistrationTxnWithSuggestedParamsFromObject(o) {
  return makeKeyRegistrationTxnWithSuggestedParams(o.from, o.note, o.voteKey, o.selectionKey, o.voteFirst, o.voteLast, o.voteKeyDilution, o.suggestedParams, o.rekeyTo, o.nonParticipation, o.stateProofKey);
}
function makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo) {
  const o = {
    from,
    note,
    suggestedParams,
    assetTotal: total,
    assetDecimals: decimals,
    assetDefaultFrozen: defaultFrozen,
    assetUnitName: unitName,
    assetName,
    assetURL,
    assetMetadataHash,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetCreateTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, rekeyTo) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo);
}
function makeAssetCreateTxnWithSuggestedParamsFromObject(o) {
  return makeAssetCreateTxnWithSuggestedParams(o.from, o.note, o.total, o.decimals, o.defaultFrozen, o.manager, o.reserve, o.freeze, o.clawback, o.unitName, o.assetName, o.assetURL, o.assetMetadataHash, o.suggestedParams, o.rekeyTo);
}
function makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking = true, rekeyTo) {
  if (strictEmptyAddressChecking && (manager === void 0 || reserve === void 0 || freeze === void 0 || clawback === void 0)) {
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  }
  const o = {
    from,
    suggestedParams,
    assetIndex,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetConfigTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking = true, rekeyTo) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking, rekeyTo);
}
function makeAssetConfigTxnWithSuggestedParamsFromObject(o) {
  return makeAssetConfigTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.manager, o.reserve, o.freeze, o.clawback, o.suggestedParams, o.strictEmptyAddressChecking, o.rekeyTo);
}
function makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    from,
    suggestedParams,
    assetIndex,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetDestroyTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, rekeyTo) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo);
}
function makeAssetDestroyTxnWithSuggestedParamsFromObject(o) {
  return makeAssetDestroyTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo) {
  const o = {
    from,
    type: TransactionType.afrz,
    freezeAccount: freezeTarget,
    assetIndex,
    freezeState,
    note,
    suggestedParams,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetFreezeTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, freezeTarget, freezeState, rekeyTo) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo);
}
function makeAssetFreezeTxnWithSuggestedParamsFromObject(o) {
  return makeAssetFreezeTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.freezeTarget, o.freezeState, o.suggestedParams, o.rekeyTo);
}
function makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    type: TransactionType.axfer,
    from,
    to,
    amount,
    suggestedParams,
    assetIndex,
    note,
    assetRevocationTarget: revocationTarget,
    closeRemainderTo,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeAssetTransferTxn(from, to, closeRemainderTo, revocationTarget, fee, amount, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, rekeyTo) {
  const suggestedParams = {
    genesisHash,
    genesisID,
    firstRound,
    lastRound,
    fee
  };
  return makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo);
}
function makeAssetTransferTxnWithSuggestedParamsFromObject(o) {
  return makeAssetTransferTxnWithSuggestedParams(o.from, o.to, o.closeRemainderTo, o.revocationTarget, o.amount, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeApplicationCreateTxn(from, suggestedParams, onComplete, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, extraPages) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex: 0,
    appOnComplete: onComplete,
    appLocalInts: numLocalInts,
    appLocalByteSlices: numLocalByteSlices,
    appGlobalInts: numGlobalInts,
    appGlobalByteSlices: numGlobalByteSlices,
    appApprovalProgram: approvalProgram,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo,
    extraPages
  };
  return new Transaction(o);
}
function makeApplicationCreateTxnFromObject(o) {
  return makeApplicationCreateTxn(o.from, o.suggestedParams, o.onComplete, o.approvalProgram, o.clearProgram, o.numLocalInts, o.numLocalByteSlices, o.numGlobalInts, o.numGlobalByteSlices, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.extraPages);
}
function makeApplicationUpdateTxn(from, suggestedParams, appIndex, approvalProgram, clearProgram, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appApprovalProgram: approvalProgram,
    appOnComplete: OnApplicationComplete.UpdateApplicationOC,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationUpdateTxnFromObject(o) {
  return makeApplicationUpdateTxn(o.from, o.suggestedParams, o.appIndex, o.approvalProgram, o.clearProgram, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
}
function makeApplicationDeleteTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.DeleteApplicationOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationDeleteTxnFromObject(o) {
  return makeApplicationDeleteTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
}
function makeApplicationOptInTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.OptInOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationOptInTxnFromObject(o) {
  return makeApplicationOptInTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
}
function makeApplicationCloseOutTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.CloseOutOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationCloseOutTxnFromObject(o) {
  return makeApplicationCloseOutTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
}
function makeApplicationClearStateTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.ClearStateOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationClearStateTxnFromObject(o) {
  return makeApplicationClearStateTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
}
function makeApplicationNoOpTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.NoOpOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction(o);
}
function makeApplicationNoOpTxnFromObject(o) {
  return makeApplicationNoOpTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
}
function makeApplicationCallTxnFromObject(options) {
  const o = {
    type: TransactionType.appl,
    from: options.from,
    suggestedParams: options.suggestedParams,
    appIndex: options.appIndex,
    appOnComplete: options.onComplete,
    appLocalInts: options.numLocalInts,
    appLocalByteSlices: options.numLocalByteSlices,
    appGlobalInts: options.numGlobalInts,
    appGlobalByteSlices: options.numGlobalByteSlices,
    appApprovalProgram: options.approvalProgram,
    appClearProgram: options.clearProgram,
    appArgs: options.appArgs,
    appAccounts: options.accounts,
    appForeignApps: options.foreignApps,
    appForeignAssets: options.foreignAssets,
    note: options.note,
    lease: options.lease,
    reKeyTo: options.rekeyTo,
    extraPages: options.extraPages
  };
  return new Transaction(o);
}
var init_makeTxn = __esm({
  "node_modules/algosdk/dist/esm/src/makeTxn.js"() {
    init_transaction();
    init_base();
    init_transactions();
    init_base();
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/limitorder.js
var require_limitorder = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/limitorder.js"(exports2, module2) {
    var address = (init_address(), __toCommonJS(address_exports));
    var makeTxn = (init_makeTxn(), __toCommonJS(makeTxn_exports));
    var group = (init_group(), __toCommonJS(group_exports));
    var logic = (init_logic(), __toCommonJS(logic_exports));
    var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
    var nacl2 = (init_naclWrappers(), __toCommonJS(naclWrappers_exports));
    var templates = require_templates();
    var utils = (init_utils(), __toCommonJS(utils_exports));
    var LimitOrder = class {
      constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {
        if (!Number.isSafeInteger(assetid) || assetid < 0)
          throw Error("assetid must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(ratn) || ratn < 0)
          throw Error("ratn must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(ratd) || ratd < 0)
          throw Error("ratd must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(minTrade) || minTrade < 0)
          throw Error("minTrade must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        const referenceProgramB64 = "ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          5,
          7,
          9,
          10,
          11,
          12,
          16
        ];
        const injectionVector = [
          maxFee,
          minTrade,
          assetid,
          ratd,
          ratn,
          expiryRound,
          owner
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = new logicSig.LogicSig(injectedBytes, void 0);
        this.address = lsig.address();
        this.owner = owner;
        this.assetid = assetid;
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {
      const buyerKeyPair = nacl2.keyPairFromSecretKey(secretKey);
      const buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);
      const programOutputs = logic.readProgram(contract, void 0);
      const ints = programOutputs[0];
      const byteArrays = programOutputs[1];
      let noCloseRemainder;
      let noAssetRevocationTarget;
      const contractAssetID = ints[6];
      const contractOwner = address.encodeAddress(byteArrays[0]);
      const lsig = logicSig.makeLogicSig(contract, void 0);
      const contractAddress = lsig.address();
      const algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, void 0, genesisHash, void 0);
      const assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, void 0, genesisHash, void 0, contractAssetID);
      const txns = [algosForAssets, assetsForAlgos];
      const txGroup = group.assignGroupID(txns);
      const ratd = ints[7];
      const ratn = ints[8];
      if (assetAmount * ratd < microAlgoAmount * ratn) {
        throw new Error(`bad payment ratio, ${assetAmount.toString()}*${ratd.toString()} !>= ${microAlgoAmount.toString()}*${ratn.toString()}`);
      }
      const minTrade = ints[4];
      if (microAlgoAmount < minTrade) {
        throw new Error(`payment amount ${microAlgoAmount.toString()} less than minimum trade ${minTrade.toString()}`);
      }
      const maxFee = ints[2];
      if (txGroup[0].fee > maxFee) {
        throw new Error(`final fee of payment transaction ${txGroup[0].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);
      }
      if (txGroup[1].fee > maxFee) {
        throw new Error(`final fee of asset transaction ${txGroup[1].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);
      }
      const algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);
      const assetsForAlgosSigned = txGroup[1].signTxn(secretKey);
      return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);
    }
    module2.exports = {
      LimitOrder,
      getSwapAssetsTransaction
    };
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/split.js
var require_split = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/split.js"(exports2, module2) {
    var address = (init_address(), __toCommonJS(address_exports));
    var makeTxn = (init_makeTxn(), __toCommonJS(makeTxn_exports));
    var group = (init_group(), __toCommonJS(group_exports));
    var logicsig = (init_logicsig(), __toCommonJS(logicsig_exports));
    var logic = (init_logic(), __toCommonJS(logic_exports));
    var templates = require_templates();
    var utils = (init_utils(), __toCommonJS(utils_exports));
    var Split = class {
      constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {
        if (!Number.isSafeInteger(rat2) || rat2 < 0)
          throw Error("rat2 must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(rat1) || rat1 < 0)
          throw Error("rat1 must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(minPay) || minPay < 0)
          throw Error("minPay must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        const referenceProgramB64 = "ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          4,
          7,
          8,
          9,
          10,
          14,
          47,
          80
        ];
        const injectionVector = [
          maxFee,
          expiryRound,
          rat2,
          rat1,
          minPay,
          owner,
          receiverOne,
          receiverTwo
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS,
          templates.valTypes.ADDRESS,
          templates.valTypes.ADDRESS
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = logicsig.makeLogicSig(injectedBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {
      const programOutputs = logic.readProgram(contract, void 0);
      const ints = programOutputs[0];
      const byteArrays = programOutputs[1];
      let rat2 = ints[6];
      let rat1 = ints[5];
      let amountForReceiverOne = 0;
      const gcdFn = (a, b) => {
        if (typeof a !== "number" || typeof b !== "number")
          throw new Error("gcd operates only on positive integers");
        if (!b) {
          return a;
        }
        return gcdFn(b, a % b);
      };
      const gcd = gcdFn(rat2, rat1);
      rat2 = Math.floor(rat2 / gcd);
      rat1 = Math.floor(rat1 / gcd);
      const ratio = rat1 / rat2;
      amountForReceiverOne = Math.round(amount / (1 + ratio));
      const amountForReceiverTwo = amount - amountForReceiverOne;
      if (rat1 * amountForReceiverOne !== rat2 * amountForReceiverTwo) {
        throw Error("could not split funds in a way that satisfied the contract ratio");
      }
      const logicSig = logicsig.makeLogicSig(contract, void 0);
      const from = logicSig.address();
      const receiverOne = address.encodeAddress(byteArrays[1]);
      const receiverTwo = address.encodeAddress(byteArrays[2]);
      const tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, void 0, firstRound, lastRound, void 0, genesisHash);
      const tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, void 0, firstRound, lastRound, void 0, genesisHash);
      const txns = [tx1, tx2];
      const txGroup = group.assignGroupID(txns);
      const signedTxns = txGroup.map((txn) => logicsig.signLogicSigTransactionObject(txn, logicsig).blob);
      return utils.concatArrays(signedTxns[0], signedTxns[1]);
    }
    module2.exports = {
      Split,
      getSplitFundsTransaction
    };
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/periodicpayment.js
var require_periodicpayment = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/periodicpayment.js"(exports2, module2) {
    var address = (init_address(), __toCommonJS(address_exports));
    var makeTxn = (init_makeTxn(), __toCommonJS(makeTxn_exports));
    var logic = (init_logic(), __toCommonJS(logic_exports));
    var logicSig = (init_logicsig(), __toCommonJS(logicsig_exports));
    var nacl2 = (init_naclWrappers(), __toCommonJS(naclWrappers_exports));
    var templates = require_templates();
    var PeriodicPayment = class {
      constructor(receiver, amount, withdrawalWindow, period, expiryRound, maxFee, lease) {
        this.receiver = receiver;
        if (!Number.isSafeInteger(amount) || amount < 0)
          throw Error("amount must be a positive number and smaller than 2^53-1");
        this.amount = amount;
        if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0)
          throw Error("withdrawalWindow must be a positive number and smaller than 2^53-1");
        this.withdrawalWindow = withdrawalWindow;
        if (!Number.isSafeInteger(period) || period < 0)
          throw Error("period must be a positive number and smaller than 2^53-1");
        this.period = period;
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        this.expiryRound = expiryRound;
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        this.maxFee = maxFee;
        if (lease === void 0) {
          const leaseBytes = nacl2.randomBytes(32);
          this.lease = Buffer.from(leaseBytes).toString("base64");
        } else {
          this.lease = lease;
        }
        this.programBytes = this.getProgram();
        const lsig = new logicSig.LogicSig(this.programBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        const referenceProgramB64 = "ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          4,
          5,
          7,
          8,
          9,
          12,
          46
        ];
        const injectionVector = [
          this.maxFee,
          this.period,
          this.withdrawalWindow,
          this.amount,
          this.expiryRound,
          this.lease,
          this.receiver
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.BASE64,
          templates.valTypes.ADDRESS
        ];
        return templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
      }
      getAddress() {
        return this.address;
      }
    };
    function getPeriodicPaymentWithdrawalTransaction(contract, fee, firstValid, genesisHash) {
      const readResult = logic.readProgram(contract, void 0);
      const ints = readResult[0];
      const byteArrays = readResult[1];
      const period = ints[2];
      const duration = ints[4];
      const amount = ints[5];
      if (firstValid % period !== 0) {
        throw new Error(`firstValid round ${firstValid.toString()} was not a multiple of contract period ${period.toString()}`);
      }
      const receiverBytes = byteArrays[1];
      const receiver = address.encodeAddress(receiverBytes);
      const leaseBuffer = byteArrays[0];
      const lease = new Uint8Array(leaseBuffer);
      const lastValid = firstValid + duration;
      const to = receiver;
      let noCloseRemainder;
      let noNote;
      const lsig = logicSig.makeLogicSig(contract, void 0);
      const from = lsig.address();
      const txn = {
        from,
        to,
        fee,
        amount,
        closeRemainderTo: noCloseRemainder,
        firstRound: firstValid,
        lastRound: lastValid,
        note: noNote,
        genesisHash,
        genesisID: "",
        type: "pay",
        lease
      };
      const tempTxn = makeTxn.makePaymentTxn(from, to, fee, amount, noCloseRemainder, firstValid, lastValid, noNote, genesisHash, "");
      if (tempTxn.fee > ints[1]) {
        throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${ints[1].toString()}`);
      }
      return logicSig.signLogicSigTransaction(txn, lsig);
    }
    module2.exports = {
      PeriodicPayment,
      getPeriodicPaymentWithdrawalTransaction
    };
  }
});

// node_modules/algosdk/dist/esm/src/logicTemplates/index.js
var require_logicTemplates = __commonJS({
  "node_modules/algosdk/dist/esm/src/logicTemplates/index.js"(exports2, module2) {
    var dynamicFeeTemplate = require_dynamicfee();
    var htlcTemplate = require_htlc();
    var limitOrderTemplate = require_limitorder();
    var splitTemplate = require_split();
    var periodicPayTemplate = require_periodicpayment();
    module2.exports = {
      DynamicFee: dynamicFeeTemplate.DynamicFee,
      getDynamicFeeTransactions: dynamicFeeTemplate.getDynamicFeeTransactions,
      signDynamicFee: dynamicFeeTemplate.signDynamicFee,
      HTLC: htlcTemplate.HTLC,
      signTransactionWithHTLCUnlock: htlcTemplate.signTransactionWithHTLCUnlock,
      LimitOrder: limitOrderTemplate.LimitOrder,
      getSwapAssetsTransaction: limitOrderTemplate.getSwapAssetsTransaction,
      Split: splitTemplate.Split,
      getSplitFundsTransaction: splitTemplate.getSplitFundsTransaction,
      PeriodicPayment: periodicPayTemplate.PeriodicPayment,
      getPeriodicPaymentWithdrawalTransaction: periodicPayTemplate.getPeriodicPaymentWithdrawalTransaction
    };
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports2, module2) {
    if (typeof module2 !== "undefined") {
      module2.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
    module2.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode4 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode3 = function encode4(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode4,
      encode: encode3,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root2 = chain[i];
        if (root2 === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var parse = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/superagent/lib/is-object.js
var require_is_object = __commonJS({
  "node_modules/superagent/lib/is-object.js"(exports2, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isObject(obj) {
      return obj !== null && _typeof(obj) === "object";
    }
    module2.exports = isObject;
  }
});

// node_modules/superagent/lib/request-base.js
var require_request_base = __commonJS({
  "node_modules/superagent/lib/request-base.js"(exports2, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var isObject = require_is_object();
    module2.exports = RequestBase;
    function RequestBase(object) {
      if (object)
        return mixin(object);
    }
    function mixin(object) {
      for (var key in RequestBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key))
          object[key] = RequestBase.prototype[key];
      }
      return object;
    }
    RequestBase.prototype.clearTimeout = function() {
      clearTimeout(this._timer);
      clearTimeout(this._responseTimeoutTimer);
      clearTimeout(this._uploadTimeoutTimer);
      delete this._timer;
      delete this._responseTimeoutTimer;
      delete this._uploadTimeoutTimer;
      return this;
    };
    RequestBase.prototype.parse = function(fn) {
      this._parser = fn;
      return this;
    };
    RequestBase.prototype.responseType = function(value) {
      this._responseType = value;
      return this;
    };
    RequestBase.prototype.serialize = function(fn) {
      this._serializer = fn;
      return this;
    };
    RequestBase.prototype.timeout = function(options) {
      if (!options || _typeof(options) !== "object") {
        this._timeout = options;
        this._responseTimeout = 0;
        this._uploadTimeout = 0;
        return this;
      }
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option)) {
          switch (option) {
            case "deadline":
              this._timeout = options.deadline;
              break;
            case "response":
              this._responseTimeout = options.response;
              break;
            case "upload":
              this._uploadTimeout = options.upload;
              break;
            default:
              console.warn("Unknown timeout option", option);
          }
        }
      }
      return this;
    };
    RequestBase.prototype.retry = function(count, fn) {
      if (arguments.length === 0 || count === true)
        count = 1;
      if (count <= 0)
        count = 0;
      this._maxRetries = count;
      this._retries = 0;
      this._retryCallback = fn;
      return this;
    };
    var ERROR_CODES = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]);
    var STATUS_CODES = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
    RequestBase.prototype._shouldRetry = function(err, res) {
      if (!this._maxRetries || this._retries++ >= this._maxRetries) {
        return false;
      }
      if (this._retryCallback) {
        try {
          var override = this._retryCallback(err, res);
          if (override === true)
            return true;
          if (override === false)
            return false;
        } catch (err_) {
          console.error(err_);
        }
      }
      if (res && res.status && STATUS_CODES.has(res.status))
        return true;
      if (err) {
        if (err.code && ERROR_CODES.has(err.code))
          return true;
        if (err.timeout && err.code === "ECONNABORTED")
          return true;
        if (err.crossDomain)
          return true;
      }
      return false;
    };
    RequestBase.prototype._retry = function() {
      this.clearTimeout();
      if (this.req) {
        this.req = null;
        this.req = this.request();
      }
      this._aborted = false;
      this.timedout = false;
      this.timedoutError = null;
      return this._end();
    };
    RequestBase.prototype.then = function(resolve, reject) {
      var _this = this;
      if (!this._fullfilledPromise) {
        var self2 = this;
        if (this._endCalled) {
          console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
        }
        this._fullfilledPromise = new Promise(function(resolve2, reject2) {
          self2.on("abort", function() {
            if (_this._maxRetries && _this._maxRetries > _this._retries) {
              return;
            }
            if (_this.timedout && _this.timedoutError) {
              reject2(_this.timedoutError);
              return;
            }
            var err = new Error("Aborted");
            err.code = "ABORTED";
            err.status = _this.status;
            err.method = _this.method;
            err.url = _this.url;
            reject2(err);
          });
          self2.end(function(err, res) {
            if (err)
              reject2(err);
            else
              resolve2(res);
          });
        });
      }
      return this._fullfilledPromise.then(resolve, reject);
    };
    RequestBase.prototype.catch = function(cb) {
      return this.then(void 0, cb);
    };
    RequestBase.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    RequestBase.prototype.ok = function(cb) {
      if (typeof cb !== "function")
        throw new Error("Callback required");
      this._okCallback = cb;
      return this;
    };
    RequestBase.prototype._isResponseOK = function(res) {
      if (!res) {
        return false;
      }
      if (this._okCallback) {
        return this._okCallback(res);
      }
      return res.status >= 200 && res.status < 300;
    };
    RequestBase.prototype.get = function(field) {
      return this._header[field.toLowerCase()];
    };
    RequestBase.prototype.getHeader = RequestBase.prototype.get;
    RequestBase.prototype.set = function(field, value) {
      if (isObject(field)) {
        for (var key in field) {
          if (Object.prototype.hasOwnProperty.call(field, key))
            this.set(key, field[key]);
        }
        return this;
      }
      this._header[field.toLowerCase()] = value;
      this.header[field] = value;
      return this;
    };
    RequestBase.prototype.unset = function(field) {
      delete this._header[field.toLowerCase()];
      delete this.header[field];
      return this;
    };
    RequestBase.prototype.field = function(name, value) {
      if (name === null || void 0 === name) {
        throw new Error(".field(name, val) name can not be empty");
      }
      if (this._data) {
        throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject(name)) {
        for (var key in name) {
          if (Object.prototype.hasOwnProperty.call(name, key))
            this.field(key, name[key]);
        }
        return this;
      }
      if (Array.isArray(value)) {
        for (var i in value) {
          if (Object.prototype.hasOwnProperty.call(value, i))
            this.field(name, value[i]);
        }
        return this;
      }
      if (value === null || void 0 === value) {
        throw new Error(".field(name, val) val can not be empty");
      }
      if (typeof value === "boolean") {
        value = String(value);
      }
      this._getFormData().append(name, value);
      return this;
    };
    RequestBase.prototype.abort = function() {
      if (this._aborted) {
        return this;
      }
      this._aborted = true;
      if (this.xhr)
        this.xhr.abort();
      if (this.req)
        this.req.abort();
      this.clearTimeout();
      this.emit("abort");
      return this;
    };
    RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
      switch (options.type) {
        case "basic":
          this.set("Authorization", "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
          break;
        case "auto":
          this.username = user;
          this.password = pass;
          break;
        case "bearer":
          this.set("Authorization", "Bearer ".concat(user));
          break;
        default:
          break;
      }
      return this;
    };
    RequestBase.prototype.withCredentials = function(on) {
      if (on === void 0)
        on = true;
      this._withCredentials = on;
      return this;
    };
    RequestBase.prototype.redirects = function(n) {
      this._maxRedirects = n;
      return this;
    };
    RequestBase.prototype.maxResponseSize = function(n) {
      if (typeof n !== "number") {
        throw new TypeError("Invalid argument");
      }
      this._maxResponseSize = n;
      return this;
    };
    RequestBase.prototype.toJSON = function() {
      return {
        method: this.method,
        url: this.url,
        data: this._data,
        headers: this._header
      };
    };
    RequestBase.prototype.send = function(data) {
      var isObject_ = isObject(data);
      var type = this._header["content-type"];
      if (this._formData) {
        throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject_ && !this._data) {
        if (Array.isArray(data)) {
          this._data = [];
        } else if (!this._isHost(data)) {
          this._data = {};
        }
      } else if (data && this._data && this._isHost(this._data)) {
        throw new Error("Can't merge these send calls");
      }
      if (isObject_ && isObject(this._data)) {
        for (var key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key))
            this._data[key] = data[key];
        }
      } else if (typeof data === "string") {
        if (!type)
          this.type("form");
        type = this._header["content-type"];
        if (type)
          type = type.toLowerCase().trim();
        if (type === "application/x-www-form-urlencoded") {
          this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
        } else {
          this._data = (this._data || "") + data;
        }
      } else {
        this._data = data;
      }
      if (!isObject_ || this._isHost(data)) {
        return this;
      }
      if (!type)
        this.type("json");
      return this;
    };
    RequestBase.prototype.sortQuery = function(sort) {
      this._sort = typeof sort === "undefined" ? true : sort;
      return this;
    };
    RequestBase.prototype._finalizeQueryString = function() {
      var query = this._query.join("&");
      if (query) {
        this.url += (this.url.includes("?") ? "&" : "?") + query;
      }
      this._query.length = 0;
      if (this._sort) {
        var index = this.url.indexOf("?");
        if (index >= 0) {
          var queryArray = this.url.slice(index + 1).split("&");
          if (typeof this._sort === "function") {
            queryArray.sort(this._sort);
          } else {
            queryArray.sort();
          }
          this.url = this.url.slice(0, index) + "?" + queryArray.join("&");
        }
      }
    };
    RequestBase.prototype._appendQueryString = function() {
      console.warn("Unsupported");
    };
    RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
      if (this._aborted) {
        return;
      }
      var err = new Error("".concat(reason + timeout, "ms exceeded"));
      err.timeout = timeout;
      err.code = "ECONNABORTED";
      err.errno = errno;
      this.timedout = true;
      this.timedoutError = err;
      this.abort();
      this.callback(err);
    };
    RequestBase.prototype._setTimeouts = function() {
      var self2 = this;
      if (this._timeout && !this._timer) {
        this._timer = setTimeout(function() {
          self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
        }, this._timeout);
      }
      if (this._responseTimeout && !this._responseTimeoutTimer) {
        this._responseTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Response timeout of ", self2._responseTimeout, "ETIMEDOUT");
        }, this._responseTimeout);
      }
    };
  }
});

// node_modules/superagent/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/superagent/lib/utils.js"(exports2) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    exports2.type = function(str) {
      return str.split(/ *; */).shift();
    };
    exports2.params = function(val) {
      var obj = {};
      var _iterator = _createForOfIteratorHelper(val.split(/ *; */)), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var str = _step.value;
          var parts = str.split(/ *= */);
          var key = parts.shift();
          var _val = parts.shift();
          if (key && _val)
            obj[key] = _val;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return obj;
    };
    exports2.parseLinks = function(val) {
      var obj = {};
      var _iterator2 = _createForOfIteratorHelper(val.split(/ *, */)), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var str = _step2.value;
          var parts = str.split(/ *; */);
          var url = parts[0].slice(1, -1);
          var rel = parts[1].split(/ *= */)[1].slice(1, -1);
          obj[rel] = url;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return obj;
    };
    exports2.cleanHeader = function(header, changesOrigin) {
      delete header["content-type"];
      delete header["content-length"];
      delete header["transfer-encoding"];
      delete header.host;
      if (changesOrigin) {
        delete header.authorization;
        delete header.cookie;
      }
      return header;
    };
  }
});

// node_modules/superagent/lib/response-base.js
var require_response_base = __commonJS({
  "node_modules/superagent/lib/response-base.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = ResponseBase;
    function ResponseBase(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in ResponseBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key))
          obj[key] = ResponseBase.prototype[key];
      }
      return obj;
    }
    ResponseBase.prototype.get = function(field) {
      return this.header[field.toLowerCase()];
    };
    ResponseBase.prototype._setHeaderProperties = function(header) {
      var ct = header["content-type"] || "";
      this.type = utils.type(ct);
      var params = utils.params(ct);
      for (var key in params) {
        if (Object.prototype.hasOwnProperty.call(params, key))
          this[key] = params[key];
      }
      this.links = {};
      try {
        if (header.link) {
          this.links = utils.parseLinks(header.link);
        }
      } catch (_unused) {
      }
    };
    ResponseBase.prototype._setStatusProperties = function(status) {
      var type = status / 100 | 0;
      this.statusCode = status;
      this.status = this.statusCode;
      this.statusType = type;
      this.info = type === 1;
      this.ok = type === 2;
      this.redirect = type === 3;
      this.clientError = type === 4;
      this.serverError = type === 5;
      this.error = type === 4 || type === 5 ? this.toError() : false;
      this.created = status === 201;
      this.accepted = status === 202;
      this.noContent = status === 204;
      this.badRequest = status === 400;
      this.unauthorized = status === 401;
      this.notAcceptable = status === 406;
      this.forbidden = status === 403;
      this.notFound = status === 404;
      this.unprocessableEntity = status === 422;
    };
  }
});

// node_modules/superagent/lib/agent-base.js
var require_agent_base = __commonJS({
  "node_modules/superagent/lib/agent-base.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function Agent() {
      this._defaults = [];
    }
    ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(fn) {
      Agent.prototype[fn] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._defaults.push({
          fn,
          args
        });
        return this;
      };
    });
    Agent.prototype._setDefaults = function(req) {
      this._defaults.forEach(function(def) {
        req[def.fn].apply(req, _toConsumableArray(def.args));
      });
    };
    module2.exports = Agent;
  }
});

// node_modules/superagent/lib/client.js
var require_client = __commonJS({
  "node_modules/superagent/lib/client.js"(exports2, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var root2;
    if (typeof window !== "undefined") {
      root2 = window;
    } else if (typeof self === "undefined") {
      console.warn("Using browser-only version of superagent in non-browser environment");
      root2 = void 0;
    } else {
      root2 = self;
    }
    var Emitter = require_component_emitter();
    var safeStringify = require_fast_safe_stringify();
    var qs = require_lib();
    var RequestBase = require_request_base();
    var isObject = require_is_object();
    var ResponseBase = require_response_base();
    var Agent = require_agent_base();
    function noop() {
    }
    module2.exports = function(method2, url) {
      if (typeof url === "function") {
        return new exports2.Request("GET", method2).end(url);
      }
      if (arguments.length === 1) {
        return new exports2.Request("GET", method2);
      }
      return new exports2.Request(method2, url);
    };
    exports2 = module2.exports;
    var request2 = exports2;
    exports2.Request = Request;
    request2.getXHR = function() {
      if (root2.XMLHttpRequest && (!root2.location || root2.location.protocol !== "file:" || !root2.ActiveXObject)) {
        return new XMLHttpRequest();
      }
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch (_unused) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.6.0");
      } catch (_unused2) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.3.0");
      } catch (_unused3) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch (_unused4) {
      }
      throw new Error("Browser-only version of superagent could not find XHR");
    };
    var trim = "".trim ? function(s) {
      return s.trim();
    } : function(s) {
      return s.replace(/(^\s*|\s*$)/g, "");
    };
    function serialize(obj) {
      if (!isObject(obj))
        return obj;
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          pushEncodedKeyValuePair(pairs, key, obj[key]);
      }
      return pairs.join("&");
    }
    function pushEncodedKeyValuePair(pairs, key, val) {
      if (val === void 0)
        return;
      if (val === null) {
        pairs.push(encodeURI(key));
        return;
      }
      if (Array.isArray(val)) {
        val.forEach(function(v) {
          pushEncodedKeyValuePair(pairs, key, v);
        });
      } else if (isObject(val)) {
        for (var subkey in val) {
          if (Object.prototype.hasOwnProperty.call(val, subkey))
            pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
        }
      } else {
        pairs.push(encodeURI(key) + "=" + encodeURIComponent(val));
      }
    }
    request2.serializeObject = serialize;
    function parseString(str) {
      var obj = {};
      var pairs = str.split("&");
      var pair;
      var pos;
      for (var i = 0, len = pairs.length; i < len; ++i) {
        pair = pairs[i];
        pos = pair.indexOf("=");
        if (pos === -1) {
          obj[decodeURIComponent(pair)] = "";
        } else {
          obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
        }
      }
      return obj;
    }
    request2.parseString = parseString;
    request2.types = {
      html: "text/html",
      json: "application/json",
      xml: "text/xml",
      urlencoded: "application/x-www-form-urlencoded",
      form: "application/x-www-form-urlencoded",
      "form-data": "application/x-www-form-urlencoded"
    };
    request2.serialize = {
      "application/x-www-form-urlencoded": qs.stringify,
      "application/json": safeStringify
    };
    request2.parse = {
      "application/x-www-form-urlencoded": parseString,
      "application/json": JSON.parse
    };
    function parseHeader(str) {
      var lines = str.split(/\r?\n/);
      var fields = {};
      var index;
      var line;
      var field;
      var val;
      for (var i = 0, len = lines.length; i < len; ++i) {
        line = lines[i];
        index = line.indexOf(":");
        if (index === -1) {
          continue;
        }
        field = line.slice(0, index).toLowerCase();
        val = trim(line.slice(index + 1));
        fields[field] = val;
      }
      return fields;
    }
    function isJSON(mime) {
      return /[/+]json($|[^-\w])/i.test(mime);
    }
    function Response(req) {
      this.req = req;
      this.xhr = this.req.xhr;
      this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || typeof this.xhr.responseType === "undefined" ? this.xhr.responseText : null;
      this.statusText = this.req.xhr.statusText;
      var status = this.xhr.status;
      if (status === 1223) {
        status = 204;
      }
      this._setStatusProperties(status);
      this.headers = parseHeader(this.xhr.getAllResponseHeaders());
      this.header = this.headers;
      this.header["content-type"] = this.xhr.getResponseHeader("content-type");
      this._setHeaderProperties(this.header);
      if (this.text === null && req._responseType) {
        this.body = this.xhr.response;
      } else {
        this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
      }
    }
    ResponseBase(Response.prototype);
    Response.prototype._parseBody = function(str) {
      var parse = request2.parse[this.type];
      if (this.req._parser) {
        return this.req._parser(this, str);
      }
      if (!parse && isJSON(this.type)) {
        parse = request2.parse["application/json"];
      }
      return parse && str && (str.length > 0 || str instanceof Object) ? parse(str) : null;
    };
    Response.prototype.toError = function() {
      var req = this.req;
      var method2 = req.method;
      var url = req.url;
      var msg = "cannot ".concat(method2, " ").concat(url, " (").concat(this.status, ")");
      var err = new Error(msg);
      err.status = this.status;
      err.method = method2;
      err.url = url;
      return err;
    };
    request2.Response = Response;
    function Request(method2, url) {
      var self2 = this;
      this._query = this._query || [];
      this.method = method2;
      this.url = url;
      this.header = {};
      this._header = {};
      this.on("end", function() {
        var err = null;
        var res = null;
        try {
          res = new Response(self2);
        } catch (err_) {
          err = new Error("Parser is unable to parse the response");
          err.parse = true;
          err.original = err_;
          if (self2.xhr) {
            err.rawResponse = typeof self2.xhr.responseType === "undefined" ? self2.xhr.responseText : self2.xhr.response;
            err.status = self2.xhr.status ? self2.xhr.status : null;
            err.statusCode = err.status;
          } else {
            err.rawResponse = null;
            err.status = null;
          }
          return self2.callback(err);
        }
        self2.emit("response", res);
        var new_err;
        try {
          if (!self2._isResponseOK(res)) {
            new_err = new Error(res.statusText || res.text || "Unsuccessful HTTP response");
          }
        } catch (err_) {
          new_err = err_;
        }
        if (new_err) {
          new_err.original = err;
          new_err.response = res;
          new_err.status = res.status;
          self2.callback(new_err, res);
        } else {
          self2.callback(null, res);
        }
      });
    }
    Emitter(Request.prototype);
    RequestBase(Request.prototype);
    Request.prototype.type = function(type) {
      this.set("Content-Type", request2.types[type] || type);
      return this;
    };
    Request.prototype.accept = function(type) {
      this.set("Accept", request2.types[type] || type);
      return this;
    };
    Request.prototype.auth = function(user, pass, options) {
      if (arguments.length === 1)
        pass = "";
      if (_typeof(pass) === "object" && pass !== null) {
        options = pass;
        pass = "";
      }
      if (!options) {
        options = {
          type: typeof btoa === "function" ? "basic" : "auto"
        };
      }
      var encoder = function encoder2(string) {
        if (typeof btoa === "function") {
          return btoa(string);
        }
        throw new Error("Cannot use basic auth, btoa is not a function");
      };
      return this._auth(user, pass, options, encoder);
    };
    Request.prototype.query = function(val) {
      if (typeof val !== "string")
        val = serialize(val);
      if (val)
        this._query.push(val);
      return this;
    };
    Request.prototype.attach = function(field, file, options) {
      if (file) {
        if (this._data) {
          throw new Error("superagent can't mix .send() and .attach()");
        }
        this._getFormData().append(field, file, options || file.name);
      }
      return this;
    };
    Request.prototype._getFormData = function() {
      if (!this._formData) {
        this._formData = new root2.FormData();
      }
      return this._formData;
    };
    Request.prototype.callback = function(err, res) {
      if (this._shouldRetry(err, res)) {
        return this._retry();
      }
      var fn = this._callback;
      this.clearTimeout();
      if (err) {
        if (this._maxRetries)
          err.retries = this._retries - 1;
        this.emit("error", err);
      }
      fn(err, res);
    };
    Request.prototype.crossDomainError = function() {
      var err = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
      err.crossDomain = true;
      err.status = this.status;
      err.method = this.method;
      err.url = this.url;
      this.callback(err);
    };
    Request.prototype.agent = function() {
      console.warn("This is not supported in browser version of superagent");
      return this;
    };
    Request.prototype.ca = Request.prototype.agent;
    Request.prototype.buffer = Request.prototype.ca;
    Request.prototype.write = function() {
      throw new Error("Streaming is not supported in browser version of superagent");
    };
    Request.prototype.pipe = Request.prototype.write;
    Request.prototype._isHost = function(obj) {
      return obj && _typeof(obj) === "object" && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== "[object Object]";
    };
    Request.prototype.end = function(fn) {
      if (this._endCalled) {
        console.warn("Warning: .end() was called twice. This is not supported in superagent");
      }
      this._endCalled = true;
      this._callback = fn || noop;
      this._finalizeQueryString();
      this._end();
    };
    Request.prototype._setUploadTimeout = function() {
      var self2 = this;
      if (this._uploadTimeout && !this._uploadTimeoutTimer) {
        this._uploadTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Upload timeout of ", self2._uploadTimeout, "ETIMEDOUT");
        }, this._uploadTimeout);
      }
    };
    Request.prototype._end = function() {
      if (this._aborted)
        return this.callback(new Error("The request has been aborted even before .end() was called"));
      var self2 = this;
      this.xhr = request2.getXHR();
      var xhr = this.xhr;
      var data = this._formData || this._data;
      this._setTimeouts();
      xhr.onreadystatechange = function() {
        var readyState = xhr.readyState;
        if (readyState >= 2 && self2._responseTimeoutTimer) {
          clearTimeout(self2._responseTimeoutTimer);
        }
        if (readyState !== 4) {
          return;
        }
        var status;
        try {
          status = xhr.status;
        } catch (_unused5) {
          status = 0;
        }
        if (!status) {
          if (self2.timedout || self2._aborted)
            return;
          return self2.crossDomainError();
        }
        self2.emit("end");
      };
      var handleProgress = function handleProgress2(direction, e) {
        if (e.total > 0) {
          e.percent = e.loaded / e.total * 100;
          if (e.percent === 100) {
            clearTimeout(self2._uploadTimeoutTimer);
          }
        }
        e.direction = direction;
        self2.emit("progress", e);
      };
      if (this.hasListeners("progress")) {
        try {
          xhr.addEventListener("progress", handleProgress.bind(null, "download"));
          if (xhr.upload) {
            xhr.upload.addEventListener("progress", handleProgress.bind(null, "upload"));
          }
        } catch (_unused6) {
        }
      }
      if (xhr.upload) {
        this._setUploadTimeout();
      }
      try {
        if (this.username && this.password) {
          xhr.open(this.method, this.url, true, this.username, this.password);
        } else {
          xhr.open(this.method, this.url, true);
        }
      } catch (err) {
        return this.callback(err);
      }
      if (this._withCredentials)
        xhr.withCredentials = true;
      if (!this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof data !== "string" && !this._isHost(data)) {
        var contentType = this._header["content-type"];
        var _serialize = this._serializer || request2.serialize[contentType ? contentType.split(";")[0] : ""];
        if (!_serialize && isJSON(contentType)) {
          _serialize = request2.serialize["application/json"];
        }
        if (_serialize)
          data = _serialize(data);
      }
      for (var field in this.header) {
        if (this.header[field] === null)
          continue;
        if (Object.prototype.hasOwnProperty.call(this.header, field))
          xhr.setRequestHeader(field, this.header[field]);
      }
      if (this._responseType) {
        xhr.responseType = this._responseType;
      }
      this.emit("request", this);
      xhr.send(typeof data === "undefined" ? null : data);
    };
    request2.agent = function() {
      return new Agent();
    };
    ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method2) {
      Agent.prototype[method2.toLowerCase()] = function(url, fn) {
        var req = new request2.Request(method2, url);
        this._setDefaults(req);
        if (fn) {
          req.end(fn);
        }
        return req;
      };
    });
    Agent.prototype.del = Agent.prototype.delete;
    request2.get = function(url, data, fn) {
      var req = request2("GET", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.query(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request2.head = function(url, data, fn) {
      var req = request2("HEAD", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.query(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request2.options = function(url, data, fn) {
      var req = request2("OPTIONS", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    function del(url, data, fn) {
      var req = request2("DELETE", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    }
    request2.del = del;
    request2.delete = del;
    request2.patch = function(url, data, fn) {
      var req = request2("PATCH", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request2.post = function(url, data, fn) {
      var req = request2("POST", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request2.put = function(url, data, fn) {
      var req = request2("PUT", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
  }
});

// node_modules/algosdk/dist/esm/src/client/urlTokenBaseHTTPClient.js
var request, URLTokenBaseHTTPClient;
var init_urlTokenBaseHTTPClient = __esm({
  "node_modules/algosdk/dist/esm/src/client/urlTokenBaseHTTPClient.js"() {
    request = __toESM(require_client());
    URLTokenBaseHTTPClient = class {
      constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
        this.defaultHeaders = defaultHeaders;
        const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
        const baseServerURL = new URL(fixedBaseServer);
        if (typeof port !== "undefined") {
          baseServerURL.port = port.toString();
        }
        if (baseServerURL.protocol.length === 0) {
          throw new Error("Invalid base server URL, protocol must be defined.");
        }
        this.baseURL = baseServerURL;
        this.tokenHeader = tokenHeader;
      }
      addressWithPath(relativePath) {
        let fixedRelativePath;
        if (relativePath.startsWith("./")) {
          fixedRelativePath = relativePath;
        } else if (relativePath.startsWith("/")) {
          fixedRelativePath = `.${relativePath}`;
        } else {
          fixedRelativePath = `./${relativePath}`;
        }
        const address = new URL(fixedRelativePath, this.baseURL);
        return address.toString();
      }
      static superagentToHTTPClientResponse(res) {
        if (res.body instanceof ArrayBuffer) {
          res.body = new Uint8Array(res.body);
        }
        return res;
      }
      static formatSuperagentError(err) {
        if (err.response) {
          try {
            const decoded = JSON.parse(Buffer.from(err.response.body).toString());
            err.message = `Network request error. Received status ${err.response.status}: ${decoded.message}`;
          } catch (err2) {
          }
        }
        return err;
      }
      async get(relativePath, query, requestHeaders = {}) {
        const r = request.get(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).responseType("arraybuffer").query(query);
        try {
          const res = await r;
          return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
        } catch (err) {
          throw URLTokenBaseHTTPClient.formatSuperagentError(err);
        }
      }
      async post(relativePath, data, query, requestHeaders = {}) {
        const r = request.post(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).query(query).serialize((o) => o).responseType("arraybuffer").send(Buffer.from(data));
        try {
          const res = await r;
          return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
        } catch (err) {
          throw URLTokenBaseHTTPClient.formatSuperagentError(err);
        }
      }
      async delete(relativePath, data, query, requestHeaders = {}) {
        const r = request.delete(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).query(query).serialize((o) => o).responseType("arraybuffer").send(Buffer.from(data));
        try {
          const res = await r;
          return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
        } catch (err) {
          throw URLTokenBaseHTTPClient.formatSuperagentError(err);
        }
      }
    };
  }
});

// node_modules/algosdk/dist/esm/src/client/client.js
var client_exports = {};
__export(client_exports, {
  default: () => HTTPClient
});
function removeFalsyOrEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0)
        delete obj[key];
    }
  }
  return obj;
}
function tolowerCaseKeys(o) {
  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});
}
function getAcceptFormat(query) {
  if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
    switch (query.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  } else
    return "application/json";
}
var HTTPClient;
var init_client = __esm({
  "node_modules/algosdk/dist/esm/src/client/client.js"() {
    init_utils();
    init_urlTokenBaseHTTPClient();
    HTTPClient = class {
      constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
        if (baseServer !== void 0) {
          this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
        } else {
          this.bc = bcOrTokenHeader;
        }
      }
      static parseJSON(text, status, jsonOptions = {}) {
        try {
          if (Object.keys(jsonOptions).length === 0) {
            return text && JSON.parse(text);
          }
          return text && parseJSON(text, jsonOptions);
        } catch (err_) {
          const err = err_;
          err.rawResponse = text || null;
          err.statusCode = status;
          throw err;
        }
      }
      static serializeData(data, requestHeaders) {
        if (!data) {
          return new Uint8Array(0);
        }
        if (requestHeaders["content-type"] === "application/json") {
          return new Uint8Array(Buffer.from(JSON.stringify(data)));
        }
        if (typeof data === "string") {
          return new Uint8Array(Buffer.from(data));
        }
        if (data instanceof Uint8Array) {
          return data;
        }
        throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
      }
      static prepareResponse(res, format, jsonOptions = {}) {
        let { body } = res;
        let text;
        if (format !== "application/msgpack") {
          text = body && Buffer.from(body).toString() || "";
        }
        if (format === "application/json") {
          body = HTTPClient.parseJSON(text, res.status, jsonOptions);
        }
        return {
          ...res,
          body,
          text,
          ok: Math.trunc(res.status / 100) === 2
        };
      }
      static prepareResponseError(err) {
        if (err.response) {
          err.response = HTTPClient.prepareResponse(err.response, "application/json");
          err.status = err.response.status;
        }
        return err;
      }
      async get(relativePath, query, requestHeaders = {}, jsonOptions = {}) {
        const format = getAcceptFormat(query);
        const fullHeaders = { ...requestHeaders, accept: format };
        try {
          const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);
          return HTTPClient.prepareResponse(res, format, jsonOptions);
        } catch (err) {
          throw HTTPClient.prepareResponseError(err);
        }
      }
      async post(relativePath, data, requestHeaders = {}, query) {
        const fullHeaders = {
          "content-type": "application/json",
          ...tolowerCaseKeys(requestHeaders)
        };
        try {
          const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);
          return HTTPClient.prepareResponse(res, "application/json");
        } catch (err) {
          throw HTTPClient.prepareResponseError(err);
        }
      }
      async delete(relativePath, data, requestHeaders = {}) {
        const fullHeaders = {
          "content-type": "application/json",
          ...tolowerCaseKeys(requestHeaders)
        };
        const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
        return HTTPClient.prepareResponse(res, "application/json");
      }
    };
  }
});

// node_modules/algosdk/dist/esm/src/client/v2/jsonrequest.js
var JSONRequest;
var init_jsonrequest = __esm({
  "node_modules/algosdk/dist/esm/src/client/v2/jsonrequest.js"() {
    init_intDecoding();
    JSONRequest = class {
      constructor(client, intDecoding) {
        this.c = client;
        this.query = {};
        this.intDecoding = intDecoding || intDecoding_default.DEFAULT;
      }
      prepare(body) {
        return body;
      }
      async do(headers = {}) {
        const jsonOptions = {};
        if (this.intDecoding !== "default") {
          jsonOptions.intDecoding = this.intDecoding;
        }
        const res = await this.c.get(this.path(), this.query, headers, jsonOptions);
        return this.prepare(res.body);
      }
      setIntDecoding(method2) {
        if (method2 !== "default" && method2 !== "safe" && method2 !== "mixed" && method2 !== "bigint")
          throw new Error(`Invalid method for int decoding: ${method2}`);
        this.intDecoding = method2;
        return this;
      }
    };
  }
});

// node_modules/algosdk/dist/esm/src/client/v2/algod/sendRawTransaction.js
var sendRawTransaction_exports = {};
__export(sendRawTransaction_exports, {
  default: () => SendRawTransaction,
  setSendTransactionHeaders: () => setSendTransactionHeaders
});
function setSendTransactionHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/x-binary";
  }
  return hdrs;
}
function isByteArray(array) {
  return array && array.byteLength !== void 0;
}
var SendRawTransaction;
var init_sendRawTransaction = __esm({
  "node_modules/algosdk/dist/esm/src/client/v2/algod/sendRawTransaction.js"() {
    init_jsonrequest();
    init_utils();
    SendRawTransaction = class extends JSONRequest {
      constructor(c, stxOrStxs) {
        super(c);
        let forPosting = stxOrStxs;
        if (Array.isArray(stxOrStxs)) {
          if (!stxOrStxs.every(isByteArray)) {
            throw new TypeError("Array elements must be byte arrays");
          }
          forPosting = concatArrays(...stxOrStxs);
        } else if (!isByteArray(forPosting)) {
          throw new TypeError("Argument must be byte array");
        }
        this.txnBytesToPost = forPosting;
      }
      path() {
        return "/v2/transactions";
      }
      async do(headers = {}) {
        const txHeaders = setSendTransactionHeaders(headers);
        const res = await this.c.post(this.path(), Buffer.from(this.txnBytesToPost), txHeaders);
        return res.body;
      }
    };
  }
});

// node_modules/algosdk/dist/esm/src/client/algod.js
var require_algod = __commonJS({
  "node_modules/algosdk/dist/esm/src/client/algod.js"(exports2, module2) {
    var { default: HTTPClient2 } = (init_client(), __toCommonJS(client_exports));
    var { setSendTransactionHeaders: setSendTransactionHeaders2 } = (init_sendRawTransaction(), __toCommonJS(sendRawTransaction_exports));
    function Algod(token = "", baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
      let tokenHeader = token;
      if (typeof tokenHeader === "string") {
        tokenHeader = { "X-Algo-API-Token": tokenHeader };
      }
      const c = new HTTPClient2(tokenHeader, baseServer, port, headers);
      function noteb64ToNote(o) {
        if (!(o.noteb64 === void 0 || o.noteb64 === null)) {
          o.note = Buffer.from(o.noteb64, "base64");
        }
        return o;
      }
      this.status = async (headerObj = {}) => {
        const res = await c.get("/v1/status", {}, headerObj);
        return res.body;
      };
      this.healthCheck = async (headerObj = {}) => {
        const res = await c.get("/health", {}, headerObj);
        if (!res.ok) {
          throw new Error(`Health response: ${res.status}`);
        }
        return {};
      };
      this.statusAfterBlock = async (roundNumber, headerObj = {}) => {
        if (!Number.isInteger(roundNumber))
          throw Error("roundNumber should be an integer");
        const res = await c.get(`/v1/status/wait-for-block-after/${roundNumber}`, {}, headerObj);
        return res.body;
      };
      this.pendingTransactions = async (maxTxns, headerObj = {}) => {
        if (!Number.isInteger(maxTxns))
          throw Error("maxTxns should be an integer");
        const res = await c.get("/v1/transactions/pending", { max: maxTxns }, headerObj);
        if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== void 0) {
          for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {
            res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);
          }
        }
        return res.body;
      };
      this.versions = async (headerObj = {}) => {
        const res = await c.get("/versions", {}, headerObj);
        return res.body;
      };
      this.ledgerSupply = async (headerObj = {}) => {
        const res = await c.get("/v1/ledger/supply", {}, headerObj);
        return res.body;
      };
      this.transactionByAddress = async (addr, first = null, last = null, maxTxns = null, headerObj = {}) => {
        if (first !== null && !Number.isInteger(first)) {
          throw Error("first round should be an integer");
        }
        if (last !== null && !Number.isInteger(last)) {
          throw Error("last round should be an integer");
        }
        const res = await c.get(`/v1/account/${addr}/transactions`, { firstRound: first, lastRound: last, max: maxTxns }, headerObj);
        if (res.statusCode === 200 && res.body.transactions !== void 0) {
          for (let i = 0; i < res.body.transactions.length; i++) {
            res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
          }
        }
        return res.body;
      };
      this.transactionByAddressAndDate = async (addr, fromDate, toDate, maxTxns = null, headerObj = {}) => {
        const res = await c.get(`/v1/account/${addr}/transactions`, { fromDate, toDate, max: maxTxns }, headerObj);
        if (res.statusCode === 200 && res.body.transactions !== void 0) {
          for (let i = 0; i < res.body.transactions.length; i++) {
            res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
          }
        }
        return res.body;
      };
      this.transactionById = async (txid, headerObj = {}) => {
        const res = await c.get(`/v1/transaction/${txid}`, {}, headerObj);
        if (res.statusCode === 200) {
          res.body = noteb64ToNote(res.body);
        }
        return res.body;
      };
      this.transactionInformation = async (addr, txid, headerObj = {}) => {
        const res = await c.get(`/v1/account/${addr}/transaction/${txid}`, {}, headerObj);
        if (res.statusCode === 200) {
          res.body = noteb64ToNote(res.body);
        }
        return res.body;
      };
      this.pendingTransactionInformation = async (txid, headerObj = {}) => {
        const res = await c.get(`/v1/transactions/pending/${txid}`, {}, headerObj);
        if (res.statusCode === 200) {
          res.body = noteb64ToNote(res.body);
        }
        return res.body;
      };
      this.accountInformation = async (addr, headerObj = {}) => {
        const res = await c.get(`/v1/account/${addr}`, {}, headerObj);
        return res.body;
      };
      this.assetInformation = async (index, headerObj = {}) => {
        const res = await c.get(`/v1/asset/${index}`, {}, headerObj);
        return res.body;
      };
      this.suggestedFee = async (headerObj = {}) => {
        const res = await c.get("/v1/transactions/fee", {}, headerObj);
        return res.body;
      };
      this.sendRawTransaction = async (txn, headerObj = {}) => {
        const txHeaders = setSendTransactionHeaders2(headerObj);
        const res = await c.post("/v1/transactions", Buffer.from(txn), txHeaders);
        return res.body;
      };
      this.sendRawTransactions = async (txns, headerObj = {}) => {
        const txHeaders = setSendTransactionHeaders2(headerObj);
        const merged = Array.prototype.concat(...txns.map((arr) => Array.from(arr)));
        const res = await c.post("/v1/transactions", Buffer.from(merged), txHeaders);
        return res.body;
      };
      this.getTransactionParams = async (headerObj = {}) => {
        const res = await c.get("/v1/transactions/params", {}, headerObj);
        return res.body;
      };
      this.suggestParams = async (headerObj = {}) => {
        const result = await this.getTransactionParams(headerObj);
        return {
          flatFee: false,
          fee: result.fee,
          firstRound: result.lastRound,
          lastRound: result.lastRound + 1e3,
          genesisID: result.genesisID,
          genesisHash: result.genesishashb64
        };
      };
      this.block = async (roundNumber, headerObj = {}) => {
        if (!Number.isInteger(roundNumber))
          throw Error("roundNumber should be an integer");
        const res = await c.get(`/v1/block/${roundNumber}`, {}, headerObj);
        if (res.statusCode === 200 && res.body.txns.transactions !== void 0) {
          for (let i = 0; i < res.body.txns.transactions.length; i++) {
            res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);
          }
        }
        return res.body;
      };
    }
    module2.exports = { Algod };
  }
});

// dep:algosdk
var algosdk_exports = {};
__export(algosdk_exports, {
  ABIAddressType: () => ABIAddressType,
  ABIArrayDynamicType: () => ABIArrayDynamicType,
  ABIArrayStaticType: () => ABIArrayStaticType,
  ABIBoolType: () => ABIBoolType,
  ABIByteType: () => ABIByteType,
  ABIContract: () => ABIContract,
  ABIInterface: () => ABIInterface,
  ABIMethod: () => ABIMethod,
  ABIReferenceType: () => ABIReferenceType,
  ABIStringType: () => ABIStringType,
  ABITransactionType: () => ABITransactionType,
  ABITupleType: () => ABITupleType,
  ABIType: () => ABIType,
  ABIUfixedType: () => ABIUfixedType,
  ABIUintType: () => ABIUintType,
  ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
  Algodv2: () => AlgodClient,
  AtomicTransactionComposer: () => AtomicTransactionComposer,
  AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
  DryrunResult: () => DryrunResult,
  ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
  Indexer: () => IndexerClient,
  IntDecoding: () => intDecoding_default,
  Kmd: () => Kmd,
  LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
  LogicSigAccount: () => LogicSigAccount,
  LogicTemplates: () => LogicTemplates,
  MAX_LEN: () => MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
  OnApplicationComplete: () => OnApplicationComplete,
  SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
  SourceMap: () => SourceMap,
  Transaction: () => Transaction,
  TransactionType: () => TransactionType,
  abiCheckTransactionType: () => abiCheckTransactionType,
  abiTypeIsReference: () => abiTypeIsReference,
  abiTypeIsTransaction: () => abiTypeIsTransaction,
  algosToMicroalgos: () => algosToMicroalgos,
  appendSignMultisigTransaction: () => appendSignMultisigTransaction,
  appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
  assignGroupID: () => assignGroupID,
  bigIntToBytes: () => bigIntToBytes,
  bytesToBigInt: () => bytesToBigInt,
  computeGroupID: () => computeGroupID,
  createDryrun: () => createDryrun,
  createMultisigTransaction: () => createMultisigTransaction,
  decodeAddress: () => decodeAddress,
  decodeObj: () => decodeObj,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUint64: () => decodeUint64,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  default: () => algosdk_default,
  encodeAddress: () => encodeAddress,
  encodeObj: () => encodeObj,
  encodeUint64: () => encodeUint64,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  generateAccount: () => generateAccount,
  getApplicationAddress: () => getApplicationAddress,
  getMethodByName: () => getMethodByName,
  instantiateTxnIfNeeded: () => instantiateTxnIfNeeded,
  isTransactionWithSigner: () => isTransactionWithSigner,
  isValidAddress: () => isValidAddress,
  logicSigFromByte: () => logicSigFromByte,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn: () => makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn: () => makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxn: () => makeAssetConfigTxn,
  makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxn: () => makeAssetCreateTxn,
  makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxn: () => makeAssetDestroyTxn,
  makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxn: () => makeAssetFreezeTxn,
  makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxn: () => makeAssetTransferTxn,
  makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
  makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
  makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSig: () => makeLogicSig,
  makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
  makePaymentTxn: () => makePaymentTxn,
  makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
  mergeMultisigTransactions: () => mergeMultisigTransactions,
  microalgosToAlgos: () => microalgosToAlgos,
  mnemonicFromSeed: () => mnemonicFromSeed,
  mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
  mnemonicToSecretKey: () => mnemonicToSecretKey,
  modelsv2: () => types_exports,
  multisigAddress: () => multisigAddress,
  secretKeyToMnemonic: () => secretKeyToMnemonic,
  seedFromMnemonic: () => seedFromMnemonic,
  signBid: () => signBid,
  signBytes: () => signBytes,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  signMultisigTransaction: () => signMultisigTransaction,
  signTransaction: () => signTransaction,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram,
  verifyBytes: () => verifyBytes,
  verifyMultisig: () => verifyMultisig,
  waitForConfirmation: () => waitForConfirmation
});

// node_modules/algosdk/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  ABIAddressType: () => ABIAddressType,
  ABIArrayDynamicType: () => ABIArrayDynamicType,
  ABIArrayStaticType: () => ABIArrayStaticType,
  ABIBoolType: () => ABIBoolType,
  ABIByteType: () => ABIByteType,
  ABIContract: () => ABIContract,
  ABIInterface: () => ABIInterface,
  ABIMethod: () => ABIMethod,
  ABIReferenceType: () => ABIReferenceType,
  ABIStringType: () => ABIStringType,
  ABITransactionType: () => ABITransactionType,
  ABITupleType: () => ABITupleType,
  ABIType: () => ABIType,
  ABIUfixedType: () => ABIUfixedType,
  ABIUintType: () => ABIUintType,
  ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
  Algodv2: () => AlgodClient,
  AtomicTransactionComposer: () => AtomicTransactionComposer,
  AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
  DryrunResult: () => DryrunResult,
  ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
  Indexer: () => IndexerClient,
  IntDecoding: () => intDecoding_default,
  Kmd: () => Kmd,
  LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
  LogicSigAccount: () => LogicSigAccount,
  LogicTemplates: () => LogicTemplates,
  MAX_LEN: () => MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
  OnApplicationComplete: () => OnApplicationComplete,
  SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
  SourceMap: () => SourceMap,
  Transaction: () => Transaction,
  TransactionType: () => TransactionType,
  abiCheckTransactionType: () => abiCheckTransactionType,
  abiTypeIsReference: () => abiTypeIsReference,
  abiTypeIsTransaction: () => abiTypeIsTransaction,
  algosToMicroalgos: () => algosToMicroalgos,
  appendSignMultisigTransaction: () => appendSignMultisigTransaction,
  appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
  assignGroupID: () => assignGroupID,
  bigIntToBytes: () => bigIntToBytes,
  bytesToBigInt: () => bytesToBigInt,
  computeGroupID: () => computeGroupID,
  createDryrun: () => createDryrun,
  createMultisigTransaction: () => createMultisigTransaction,
  decodeAddress: () => decodeAddress,
  decodeObj: () => decodeObj,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUint64: () => decodeUint64,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  default: () => esm_default,
  encodeAddress: () => encodeAddress,
  encodeObj: () => encodeObj,
  encodeUint64: () => encodeUint64,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  generateAccount: () => generateAccount,
  getApplicationAddress: () => getApplicationAddress,
  getMethodByName: () => getMethodByName,
  instantiateTxnIfNeeded: () => instantiateTxnIfNeeded,
  isTransactionWithSigner: () => isTransactionWithSigner,
  isValidAddress: () => isValidAddress,
  logicSigFromByte: () => logicSigFromByte,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn: () => makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn: () => makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxn: () => makeAssetConfigTxn,
  makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxn: () => makeAssetCreateTxn,
  makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxn: () => makeAssetDestroyTxn,
  makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxn: () => makeAssetFreezeTxn,
  makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxn: () => makeAssetTransferTxn,
  makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
  makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
  makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSig: () => makeLogicSig,
  makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
  makePaymentTxn: () => makePaymentTxn,
  makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
  mergeMultisigTransactions: () => mergeMultisigTransactions,
  microalgosToAlgos: () => microalgosToAlgos,
  mnemonicFromSeed: () => mnemonicFromSeed,
  mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
  mnemonicToSecretKey: () => mnemonicToSecretKey,
  modelsv2: () => types_exports,
  multisigAddress: () => multisigAddress,
  secretKeyToMnemonic: () => secretKeyToMnemonic,
  seedFromMnemonic: () => seedFromMnemonic,
  signBid: () => signBid,
  signBytes: () => signBytes,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  signMultisigTransaction: () => signMultisigTransaction,
  signTransaction: () => signTransaction,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram,
  verifyBytes: () => verifyBytes,
  verifyMultisig: () => verifyMultisig,
  waitForConfirmation: () => waitForConfirmation
});

// node_modules/algosdk/dist/esm/src/main.js
var main_exports = {};
__export(main_exports, {
  ABIAddressType: () => ABIAddressType,
  ABIArrayDynamicType: () => ABIArrayDynamicType,
  ABIArrayStaticType: () => ABIArrayStaticType,
  ABIBoolType: () => ABIBoolType,
  ABIByteType: () => ABIByteType,
  ABIContract: () => ABIContract,
  ABIInterface: () => ABIInterface,
  ABIMethod: () => ABIMethod,
  ABIReferenceType: () => ABIReferenceType,
  ABIStringType: () => ABIStringType,
  ABITransactionType: () => ABITransactionType,
  ABITupleType: () => ABITupleType,
  ABIType: () => ABIType,
  ABIUfixedType: () => ABIUfixedType,
  ABIUintType: () => ABIUintType,
  ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE: () => ALGORAND_MIN_TX_FEE,
  Algodv2: () => AlgodClient,
  AtomicTransactionComposer: () => AtomicTransactionComposer,
  AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
  DryrunResult: () => DryrunResult,
  ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
  Indexer: () => IndexerClient,
  IntDecoding: () => intDecoding_default,
  Kmd: () => Kmd,
  LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
  LogicSigAccount: () => LogicSigAccount,
  LogicTemplates: () => LogicTemplates,
  MAX_LEN: () => MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
  OnApplicationComplete: () => OnApplicationComplete,
  SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
  SourceMap: () => SourceMap,
  Transaction: () => Transaction,
  TransactionType: () => TransactionType,
  abiCheckTransactionType: () => abiCheckTransactionType,
  abiTypeIsReference: () => abiTypeIsReference,
  abiTypeIsTransaction: () => abiTypeIsTransaction,
  algosToMicroalgos: () => algosToMicroalgos,
  appendSignMultisigTransaction: () => appendSignMultisigTransaction,
  appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
  assignGroupID: () => assignGroupID,
  bigIntToBytes: () => bigIntToBytes,
  bytesToBigInt: () => bytesToBigInt,
  computeGroupID: () => computeGroupID,
  createDryrun: () => createDryrun,
  createMultisigTransaction: () => createMultisigTransaction,
  decodeAddress: () => decodeAddress,
  decodeObj: () => decodeObj,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUint64: () => decodeUint64,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  encodeAddress: () => encodeAddress,
  encodeObj: () => encodeObj,
  encodeUint64: () => encodeUint64,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  generateAccount: () => generateAccount,
  getApplicationAddress: () => getApplicationAddress,
  getMethodByName: () => getMethodByName,
  instantiateTxnIfNeeded: () => instantiateTxnIfNeeded,
  isTransactionWithSigner: () => isTransactionWithSigner,
  isValidAddress: () => isValidAddress,
  logicSigFromByte: () => logicSigFromByte,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn: () => makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn: () => makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn: () => makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn: () => makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn: () => makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn: () => makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn: () => makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxn: () => makeAssetConfigTxn,
  makeAssetConfigTxnWithSuggestedParams: () => makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxn: () => makeAssetCreateTxn,
  makeAssetCreateTxnWithSuggestedParams: () => makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxn: () => makeAssetDestroyTxn,
  makeAssetDestroyTxnWithSuggestedParams: () => makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxn: () => makeAssetFreezeTxn,
  makeAssetFreezeTxnWithSuggestedParams: () => makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxn: () => makeAssetTransferTxn,
  makeAssetTransferTxnWithSuggestedParams: () => makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
  makeKeyRegistrationTxn: () => makeKeyRegistrationTxn,
  makeKeyRegistrationTxnWithSuggestedParams: () => makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSig: () => makeLogicSig,
  makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
  makePaymentTxn: () => makePaymentTxn,
  makePaymentTxnWithSuggestedParams: () => makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
  mergeMultisigTransactions: () => mergeMultisigTransactions,
  microalgosToAlgos: () => microalgosToAlgos,
  mnemonicFromSeed: () => mnemonicFromSeed,
  mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
  mnemonicToSecretKey: () => mnemonicToSecretKey,
  modelsv2: () => types_exports,
  multisigAddress: () => multisigAddress,
  secretKeyToMnemonic: () => secretKeyToMnemonic,
  seedFromMnemonic: () => seedFromMnemonic,
  signBid: () => signBid,
  signBytes: () => signBytes,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  signMultisigTransaction: () => signMultisigTransaction,
  signTransaction: () => signTransaction,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram,
  verifyBytes: () => verifyBytes,
  verifyMultisig: () => verifyMultisig,
  waitForConfirmation: () => waitForConfirmation
});
init_naclWrappers();
init_address();
init_encoding();
init_transaction();
var LogicTemplatesCommonJSExport = __toESM(require_logicTemplates());

// node_modules/algosdk/dist/esm/src/bid.js
init_address();
init_encoding();
init_naclWrappers();
init_utils();
var Bid = class {
  constructor({ bidderKey, bidAmount, bidID, auctionKey, auctionID, maxPrice }) {
    this.name = "Bid";
    this.tag = Buffer.from([97, 66]);
    const decodedBidderKey = decodeAddress(bidderKey);
    const decodedAuctionKey = decodeAddress(auctionKey);
    if (!Number.isSafeInteger(bidAmount) || bidAmount < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(bidID) || bidID < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(auctionID) || auctionID < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, {
      bidderKey: decodedBidderKey,
      bidAmount,
      bidID,
      auctionKey: decodedAuctionKey,
      auctionID,
      maxPrice
    });
  }
  get_obj_for_encoding() {
    return {
      bidder: Buffer.from(this.bidderKey.publicKey),
      cur: this.bidAmount,
      price: this.maxPrice,
      id: this.bidID,
      auc: Buffer.from(this.auctionKey.publicKey),
      aid: this.auctionID
    };
  }
  signBid(sk) {
    const encodedMsg = encode2(this.get_obj_for_encoding());
    const toBeSigned = Buffer.from(concatArrays(this.tag, encodedMsg));
    const sig = sign(toBeSigned, sk);
    const sBid = {
      sig: Buffer.from(sig),
      bid: this.get_obj_for_encoding()
    };
    const note = {
      t: "b",
      b: sBid
    };
    return new Uint8Array(encode2(note));
  }
};

// node_modules/algosdk/dist/esm/src/convert.js
var MICROALGOS_TO_ALGOS_RATIO = 1e6;
var INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
function microalgosToAlgos(microalgos) {
  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
    throw new Error(INVALID_MICROALGOS_ERROR_MSG);
  }
  return microalgos / MICROALGOS_TO_ALGOS_RATIO;
}
function algosToMicroalgos(algos) {
  const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
  return Math.round(microalgos);
}

// node_modules/algosdk/dist/esm/src/main.js
init_utils();
__reExport(main_exports, __toESM(require_algod()));

// node_modules/algosdk/dist/esm/src/client/v2/serviceClient.js
init_client();
init_intDecoding();
function convertTokenStringToTokenHeader(token = "", headerIdentifier) {
  const tokenHeader = {};
  tokenHeader[headerIdentifier] = token;
  return tokenHeader;
}
function isBaseHTTPClient(tbc) {
  return typeof tbc.get === "function";
}
var ServiceClient = class {
  constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
    if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
      this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
    } else {
      let tokenHeader;
      if (typeof tokenHeaderOrStrOrBaseClient === "string") {
        tokenHeader = convertTokenStringToTokenHeader(tokenHeaderOrStrOrBaseClient, tokenHeaderIdentifier);
      } else {
        tokenHeader = tokenHeaderOrStrOrBaseClient;
      }
      this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
    }
    this.intDecoding = intDecoding_default.DEFAULT;
  }
  setIntEncoding(method2) {
    this.intDecoding = method2;
  }
  getIntEncoding() {
    return this.intDecoding;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/accountInformation.js
init_jsonrequest();
var AccountInformation = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/accountAssetInformation.js
init_jsonrequest();
var AccountAssetInformation = class extends JSONRequest {
  constructor(c, intDecoding, account, assetID) {
    super(c, intDecoding);
    this.account = account;
    this.assetID = assetID;
    this.account = account;
    this.assetID = assetID;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/accountApplicationInformation.js
init_jsonrequest();
var AccountApplicationInformation = class extends JSONRequest {
  constructor(c, intDecoding, account, applicationID) {
    super(c, intDecoding);
    this.account = account;
    this.applicationID = applicationID;
    this.account = account;
    this.applicationID = applicationID;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/block.js
init_encoding();
init_jsonrequest();
var Block = class extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
    this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/compile.js
init_jsonrequest();
function setHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
var Compile = class extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
    this.source = source;
  }
  path() {
    return `/v2/teal/compile`;
  }
  sourcemap(map = true) {
    this.query.sourcemap = map;
    return this;
  }
  async do(headers = {}) {
    const txHeaders = setHeaders(headers);
    const res = await this.c.post(this.path(), Buffer.from(this.source), txHeaders, this.query);
    return res.body;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/dryrun.js
init_jsonrequest();
init_encoding();
var Dryrun = class extends JSONRequest {
  constructor(c, dr) {
    super(c);
    this.blob = encode2(dr.get_obj_for_encoding(true));
  }
  path() {
    return "/v2/teal/dryrun";
  }
  async do(headers = {}) {
    const txHeaders = setHeaders(headers);
    const res = await this.c.post(this.path(), Buffer.from(this.blob), txHeaders);
    return res.body;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/genesis.js
init_jsonrequest();
var Genesis = class extends JSONRequest {
  path() {
    return "/genesis";
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/getAssetByID.js
init_jsonrequest();
var GetAssetByID = class extends JSONRequest {
  constructor(c, intDecoding, index) {
    super(c, intDecoding);
    this.index = index;
    this.index = index;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/getApplicationByID.js
init_jsonrequest();
var GetApplicationByID = class extends JSONRequest {
  constructor(c, intDecoding, index) {
    super(c, intDecoding);
    this.index = index;
    this.index = index;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/getBlockHash.js
init_jsonrequest();
var GetBlockHash = class extends JSONRequest {
  constructor(c, intDecoding, roundNumber) {
    super(c, intDecoding);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/healthCheck.js
init_jsonrequest();
var HealthCheck = class extends JSONRequest {
  path() {
    return "/health";
  }
  async do(headers = {}) {
    const res = await this.c.get(this.path(), {}, headers);
    if (!res.ok) {
      throw new Error(`Health response: ${res.status}`);
    }
    return {};
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/pendingTransactionInformation.js
init_jsonrequest();
init_encoding();
var PendingTransactionInformation = class extends JSONRequest {
  constructor(c, txid) {
    super(c);
    this.txid = txid;
    this.txid = txid;
    this.query.format = "msgpack";
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/pendingTransactions.js
init_jsonrequest();
init_encoding();
var PendingTransactions = class extends JSONRequest {
  constructor(c) {
    super(c);
    this.query.format = "msgpack";
  }
  path() {
    return "/v2/transactions/pending";
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/pendingTransactionsByAddress.js
init_jsonrequest();
init_encoding();
var PendingTransactionsByAddress = class extends JSONRequest {
  constructor(c, address) {
    super(c);
    this.address = address;
    this.address = address;
    this.query.format = "msgpack";
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode2(body);
    }
    return void 0;
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/getTransactionProof.js
init_jsonrequest();
var GetTransactionProof = class extends JSONRequest {
  constructor(c, intDecoding, round, txID) {
    super(c, intDecoding);
    this.round = round;
    this.txID = txID;
    this.round = round;
    this.txID = txID;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  hashType(hashType) {
    this.query.hashtype = hashType;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/algod.js
init_sendRawTransaction();

// node_modules/algosdk/dist/esm/src/client/v2/algod/status.js
init_jsonrequest();
var Status = class extends JSONRequest {
  path() {
    return "/v2/status";
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/statusAfterBlock.js
init_jsonrequest();
var StatusAfterBlock = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    if (!Number.isInteger(round))
      throw Error("round should be an integer");
    this.round = round;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/suggestedParams.js
init_jsonrequest();
var SuggestedParamsRequest = class extends JSONRequest {
  path() {
    return "/v2/transactions/params";
  }
  prepare(body) {
    return {
      flatFee: false,
      fee: body.fee,
      firstRound: body["last-round"],
      lastRound: body["last-round"] + 1e3,
      genesisID: body["genesis-id"],
      genesisHash: body["genesis-hash"]
    };
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/supply.js
init_jsonrequest();
var Supply = class extends JSONRequest {
  path() {
    return "/v2/ledger/supply";
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/versions.js
init_jsonrequest();
var Versions = class extends JSONRequest {
  path() {
    return "/versions";
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/lightBlockHeaderProof.js
init_jsonrequest();
var LightBlockHeaderProof = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/stateproof.js
init_jsonrequest();
var StateProof = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/algod.js
var AlgodClient = class extends ServiceClient {
  constructor(tokenOrBaseClient, baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
    super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  healthCheck() {
    return new HealthCheck(this.c);
  }
  versionsCheck() {
    return new Versions(this.c);
  }
  sendRawTransaction(stxOrStxs) {
    return new SendRawTransaction(this.c, stxOrStxs);
  }
  accountInformation(account) {
    return new AccountInformation(this.c, this.intDecoding, account);
  }
  accountAssetInformation(account, index) {
    return new AccountAssetInformation(this.c, this.intDecoding, account, index);
  }
  accountApplicationInformation(account, index) {
    return new AccountApplicationInformation(this.c, this.intDecoding, account, index);
  }
  block(roundNumber) {
    return new Block(this.c, roundNumber);
  }
  getBlockHash(roundNumber) {
    return new GetBlockHash(this.c, this.intDecoding, roundNumber);
  }
  pendingTransactionInformation(txid) {
    return new PendingTransactionInformation(this.c, txid);
  }
  pendingTransactionsInformation() {
    return new PendingTransactions(this.c);
  }
  pendingTransactionByAddress(address) {
    return new PendingTransactionsByAddress(this.c, address);
  }
  status() {
    return new Status(this.c, this.intDecoding);
  }
  statusAfterBlock(round) {
    return new StatusAfterBlock(this.c, this.intDecoding, round);
  }
  getTransactionParams() {
    return new SuggestedParamsRequest(this.c);
  }
  supply() {
    return new Supply(this.c, this.intDecoding);
  }
  compile(source) {
    return new Compile(this.c, source);
  }
  dryrun(dr) {
    return new Dryrun(this.c, dr);
  }
  getAssetByID(index) {
    return new GetAssetByID(this.c, this.intDecoding, index);
  }
  getApplicationByID(index) {
    return new GetApplicationByID(this.c, this.intDecoding, index);
  }
  genesis() {
    return new Genesis(this.c, this.intDecoding);
  }
  getTransactionProof(round, txID) {
    return new GetTransactionProof(this.c, this.intDecoding, round, txID);
  }
  getLightBlockHeaderProof(round) {
    return new LightBlockHeaderProof(this.c, this.intDecoding, round);
  }
  getStateProof(round) {
    return new StateProof(this.c, this.intDecoding, round);
  }
};

// node_modules/algosdk/dist/esm/src/client/kmd.js
init_transaction();
var Kmd = class extends ServiceClient {
  constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
    super("X-KMD-API-Token", token, baseServer, port, headers);
  }
  async versions() {
    const res = await this.c.get("/versions");
    return res.body;
  }
  async listWallets() {
    const res = await this.c.get("/v1/wallets");
    return res.body;
  }
  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
    const req = {
      wallet_name: walletName,
      wallet_driver_name: walletDriverName,
      wallet_password: walletPassword,
      master_derivation_key: Buffer.from(walletMDK).toString("base64")
    };
    const res = await this.c.post("/v1/wallet", req);
    return res.body;
  }
  async initWalletHandle(walletID, walletPassword) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/wallet/init", req);
    return res.body;
  }
  async releaseWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/release", req);
    return res.body;
  }
  async renewWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/renew", req);
    return res.body;
  }
  async renameWallet(walletID, walletPassword, newWalletName) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword,
      wallet_name: newWalletName
    };
    const res = await this.c.post("/v1/wallet/rename", req);
    return res.body;
  }
  async getWallet(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/info", req);
    return res.body;
  }
  async exportMasterDerivationKey(walletHandle, walletPassword) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/master-key/export", req);
    return {
      master_derivation_key: Buffer.from(res.body.master_derivation_key, "base64")
    };
  }
  async importKey(walletHandle, secretKey) {
    const req = {
      wallet_handle_token: walletHandle,
      private_key: Buffer.from(secretKey).toString("base64")
    };
    const res = await this.c.post("/v1/key/import", req);
    return res.body;
  }
  async exportKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/key/export", req);
    return { private_key: Buffer.from(res.body.private_key, "base64") };
  }
  async generateKey(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle,
      display_mnemonic: false
    };
    const res = await this.c.post("/v1/key", req);
    return res.body;
  }
  async deleteKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/key", req);
    return res.body;
  }
  async listKeys(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/key/list", req);
    return res.body;
  }
  async signTransaction(walletHandle, walletPassword, transaction) {
    const tx = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: Buffer.from(tx.toByte()).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
    const tx = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: Buffer.from(tx.toByte()).toString("base64"),
      public_key: Buffer.from(publicKey).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  async listMultisig(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/multisig/list", req);
    return res.body;
  }
  async importMultisig(walletHandle, version, threshold, pks) {
    const req = {
      wallet_handle_token: walletHandle,
      multisig_version: version,
      threshold,
      pks
    };
    const res = await this.c.post("/v1/multisig/import", req);
    return res.body;
  }
  async exportMultisig(walletHandle, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr
    };
    const res = await this.c.post("/v1/multisig/export", req);
    return res.body;
  }
  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
    const tx = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      transaction: Buffer.from(tx.toByte()).toString("base64"),
      public_key: Buffer.from(pk).toString("base64"),
      partial_multisig: partial,
      wallet_password: pw
    };
    const res = await this.c.post("/v1/multisig/sign", req);
    return res.body;
  }
  async deleteMultisig(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/multisig", req);
    return res.body;
  }
};

// node_modules/algosdk/dist/esm/src/main.js
init_intDecoding();

// node_modules/algosdk/dist/esm/src/client/v2/indexer/makeHealthCheck.js
init_jsonrequest();
var MakeHealthCheck = class extends JSONRequest {
  path() {
    return "/health";
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetBalances.js
init_jsonrequest();
var LookupAssetBalances = class extends JSONRequest {
  constructor(c, intDecoding, index) {
    super(c, intDecoding);
    this.index = index;
    this.index = index;
  }
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetTransactions.js
init_jsonrequest();

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountTransactions.js
init_jsonrequest();
function base64StringFunnel(data) {
  if (typeof data === "string") {
    return data;
  }
  return Buffer.from(data).toString("base64");
}
var LookupAccountTransactions = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetTransactions.js
var LookupAssetTransactions = class extends JSONRequest {
  constructor(c, intDecoding, index) {
    super(c, intDecoding);
    this.index = index;
    this.index = index;
  }
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  address(address) {
    this.query.address = address;
    return this;
  }
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupBlock.js
init_jsonrequest();
var LookupBlock = class extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupTransactionByID.js
init_jsonrequest();
var LookupTransactionByID = class extends JSONRequest {
  constructor(c, intDecoding, txID) {
    super(c, intDecoding);
    this.txID = txID;
    this.txID = txID;
  }
  path() {
    return `/v2/transactions/${this.txID}`;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountByID.js
init_jsonrequest();
var LookupAccountByID = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountAssets.js
init_jsonrequest();
var LookupAccountAssets = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  assetId(index) {
    this.query["asset-id"] = index;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountCreatedAssets.js
init_jsonrequest();
var LookupAccountCreatedAssets = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  assetID(index) {
    this.query["asset-id"] = index;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountAppLocalStates.js
init_jsonrequest();
var LookupAccountAppLocalStates = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  applicationID(index) {
    this.query["application-id"] = index;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAccountCreatedApplications.js
init_jsonrequest();
var LookupAccountCreatedApplications = class extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  applicationID(index) {
    this.query["application-id"] = index;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupAssetByID.js
init_jsonrequest();
var LookupAssetByID = class extends JSONRequest {
  constructor(c, intDecoding, index) {
    super(c, intDecoding);
    this.index = index;
    this.index = index;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupApplications.js
init_jsonrequest();
var LookupApplications = class extends JSONRequest {
  constructor(c, intDecoding, index) {
    super(c, intDecoding);
    this.index = index;
    this.index = index;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/lookupApplicationLogs.js
init_jsonrequest();
var LookupApplicationLogs = class extends JSONRequest {
  constructor(c, intDecoding, appID) {
    super(c, intDecoding);
    this.appID = appID;
    this.appID = appID;
  }
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  sender(senderAddress) {
    this.query["sender-address"] = senderAddress;
    return this;
  }
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/searchAccounts.js
init_jsonrequest();
var SearchAccounts = class extends JSONRequest {
  path() {
    return "/v2/accounts";
  }
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  authAddr(authAddr) {
    this.query["auth-addr"] = authAddr;
    return this;
  }
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/searchForTransactions.js
init_jsonrequest();
var SearchForTransactions = class extends JSONRequest {
  path() {
    return "/v2/transactions";
  }
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  round(round) {
    this.query.round = round;
    return this;
  }
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  address(address) {
    this.query.address = address;
    return this;
  }
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/searchForAssets.js
init_jsonrequest();
var SearchForAssets = class extends JSONRequest {
  path() {
    return "/v2/assets";
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  name(name) {
    this.query.name = name;
    return this;
  }
  unit(unit) {
    this.query.unit = unit;
    return this;
  }
  index(index) {
    this.query["asset-id"] = index;
    return this;
  }
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/searchForApplications.js
init_jsonrequest();
var SearchForApplications = class extends JSONRequest {
  path() {
    return "/v2/applications";
  }
  index(index) {
    this.query["application-id"] = index;
    return this;
  }
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/indexer/indexer.js
var IndexerClient = class extends ServiceClient {
  constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
    super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  makeHealthCheck() {
    return new MakeHealthCheck(this.c, this.intDecoding);
  }
  lookupAssetBalances(index) {
    return new LookupAssetBalances(this.c, this.intDecoding, index);
  }
  lookupAssetTransactions(index) {
    return new LookupAssetTransactions(this.c, this.intDecoding, index);
  }
  lookupAccountTransactions(account) {
    return new LookupAccountTransactions(this.c, this.intDecoding, account);
  }
  lookupBlock(round) {
    return new LookupBlock(this.c, this.intDecoding, round);
  }
  lookupTransactionByID(txID) {
    return new LookupTransactionByID(this.c, this.intDecoding, txID);
  }
  lookupAccountByID(account) {
    return new LookupAccountByID(this.c, this.intDecoding, account);
  }
  lookupAccountAssets(account) {
    return new LookupAccountAssets(this.c, this.intDecoding, account);
  }
  lookupAccountCreatedAssets(account) {
    return new LookupAccountCreatedAssets(this.c, this.intDecoding, account);
  }
  lookupAccountAppLocalStates(account) {
    return new LookupAccountAppLocalStates(this.c, this.intDecoding, account);
  }
  lookupAccountCreatedApplications(account) {
    return new LookupAccountCreatedApplications(this.c, this.intDecoding, account);
  }
  lookupAssetByID(index) {
    return new LookupAssetByID(this.c, this.intDecoding, index);
  }
  lookupApplications(index) {
    return new LookupApplications(this.c, this.intDecoding, index);
  }
  lookupApplicationLogs(appID) {
    return new LookupApplicationLogs(this.c, this.intDecoding, appID);
  }
  searchAccounts() {
    return new SearchAccounts(this.c, this.intDecoding);
  }
  searchForTransactions() {
    return new SearchForTransactions(this.c, this.intDecoding);
  }
  searchForAssets() {
    return new SearchForAssets(this.c, this.intDecoding);
  }
  searchForApplications() {
    return new SearchForApplications(this.c, this.intDecoding);
  }
};

// node_modules/algosdk/dist/esm/src/wait.js
async function waitForConfirmation(client, txid, waitRounds) {
  const status = await client.status().do();
  if (typeof status === "undefined") {
    throw new Error("Unable to get node status");
  }
  const startRound = status["last-round"] + 1;
  let currentRound = startRound;
  while (currentRound < startRound + waitRounds) {
    let poolError = false;
    try {
      const pendingInfo = await client.pendingTransactionInformation(txid).do();
      if (pendingInfo["confirmed-round"]) {
        return pendingInfo;
      }
      if (pendingInfo["pool-error"]) {
        poolError = true;
        throw new Error(`Transaction Rejected: ${pendingInfo["pool-error"]}`);
      }
    } catch (err) {
      if (poolError) {
        throw err;
      }
    }
    await client.statusAfterBlock(currentRound).do();
    currentRound += 1;
  }
  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
}

// node_modules/algosdk/dist/esm/src/main.js
init_address();

// node_modules/algosdk/dist/esm/src/encoding/bigint.js
function bigIntToBytes(bi, size) {
  let hex = bi.toString(16);
  if (hex.length !== size * 2) {
    hex = hex.padStart(size * 2, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {
    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);
  }
  return byteArray;
}
function bytesToBigInt(bytes) {
  let res = BigInt(0);
  const buf = Buffer.from(bytes);
  for (let i = 0; i < bytes.length; i++) {
    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);
  }
  return res;
}

// node_modules/algosdk/dist/esm/src/main.js
init_uint64();

// node_modules/algosdk/dist/esm/src/account.js
init_naclWrappers();
init_address();
function generateAccount() {
  const keys = keyPair();
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}

// node_modules/algosdk/dist/esm/src/client/v2/algod/models/types.js
var types_exports = {};
__export(types_exports, {
  Account: () => Account,
  AccountApplicationResponse: () => AccountApplicationResponse,
  AccountAssetResponse: () => AccountAssetResponse,
  AccountParticipation: () => AccountParticipation,
  AccountStateDelta: () => AccountStateDelta,
  Application: () => Application,
  ApplicationLocalState: () => ApplicationLocalState,
  ApplicationParams: () => ApplicationParams,
  ApplicationStateSchema: () => ApplicationStateSchema,
  Asset: () => Asset,
  AssetHolding: () => AssetHolding,
  AssetParams: () => AssetParams,
  BlockResponse: () => BlockResponse,
  BuildVersion: () => BuildVersion,
  CatchpointAbortResponse: () => CatchpointAbortResponse,
  CatchpointStartResponse: () => CatchpointStartResponse,
  CompileResponse: () => CompileResponse,
  DisassembleResponse: () => DisassembleResponse,
  DryrunRequest: () => DryrunRequest,
  DryrunResponse: () => DryrunResponse,
  DryrunSource: () => DryrunSource,
  DryrunState: () => DryrunState,
  DryrunTxnResult: () => DryrunTxnResult,
  ErrorResponse: () => ErrorResponse,
  EvalDelta: () => EvalDelta,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue,
  LightBlockHeaderProof: () => LightBlockHeaderProof2,
  NodeStatusResponse: () => NodeStatusResponse,
  PendingTransactionResponse: () => PendingTransactionResponse,
  PendingTransactionsResponse: () => PendingTransactionsResponse,
  PostTransactionsResponse: () => PostTransactionsResponse,
  StateProof: () => StateProof2,
  StateProofMessage: () => StateProofMessage,
  SupplyResponse: () => SupplyResponse,
  TealKeyValue: () => TealKeyValue,
  TealValue: () => TealValue,
  TransactionParametersResponse: () => TransactionParametersResponse,
  TransactionProofResponse: () => TransactionProofResponse,
  Version: () => Version
});

// node_modules/algosdk/dist/esm/src/client/v2/algod/models/base.js
function _is_primitive(val) {
  return val === void 0 || val == null || typeof val !== "object" && typeof val !== "function";
}
function _get_obj_for_encoding(val, binary) {
  let targetPropValue;
  if (val instanceof Uint8Array) {
    targetPropValue = binary ? val : Buffer.from(val).toString("base64");
  } else if (typeof val.get_obj_for_encoding === "function") {
    targetPropValue = val.get_obj_for_encoding(binary);
  } else if (Array.isArray(val)) {
    targetPropValue = [];
    for (const elem of val) {
      targetPropValue.push(_get_obj_for_encoding(elem, binary));
    }
  } else if (typeof val === "object") {
    const obj = {};
    for (const prop of Object.keys(val)) {
      obj[prop] = _get_obj_for_encoding(val[prop], binary);
    }
    targetPropValue = obj;
  } else if (_is_primitive(val)) {
    targetPropValue = val;
  } else {
    throw new Error(`Unsupported value: ${String(val)}`);
  }
  return targetPropValue;
}
var BaseModel = class {
  get_obj_for_encoding(binary = false) {
    const obj = {};
    for (const prop of Object.keys(this.attribute_map)) {
      const name = this.attribute_map[prop];
      const value = this[prop];
      if (typeof value !== "undefined") {
        obj[name] = value === null ? null : _get_obj_for_encoding(value, binary);
      }
    }
    return obj;
  }
};

// node_modules/algosdk/dist/esm/src/client/v2/algod/models/types.js
var Account = class extends BaseModel {
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, participation, rewardBase, sigType }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.minBalance = minBalance;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      minBalance: "min-balance",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type"
    };
  }
};
var AccountApplicationResponse = class extends BaseModel {
  constructor(round, appLocalState, createdApp) {
    super();
    this.round = round;
    this.appLocalState = appLocalState;
    this.createdApp = createdApp;
    this.attribute_map = {
      round: "round",
      appLocalState: "app-local-state",
      createdApp: "created-app"
    };
  }
};
var AccountAssetResponse = class extends BaseModel {
  constructor(round, assetHolding, createdAsset) {
    super();
    this.round = round;
    this.assetHolding = assetHolding;
    this.createdAsset = createdAsset;
    this.attribute_map = {
      round: "round",
      assetHolding: "asset-holding",
      createdAsset: "created-asset"
    };
  }
};
var AccountParticipation = class extends BaseModel {
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
};
var AccountStateDelta = class extends BaseModel {
  constructor(address, delta) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
};
var Application = class extends BaseModel {
  constructor(id, params) {
    super();
    this.id = id;
    this.params = params;
    this.attribute_map = {
      id: "id",
      params: "params"
    };
  }
};
var ApplicationLocalState = class extends BaseModel {
  constructor(id, schema, keyValue) {
    super();
    this.id = id;
    this.schema = schema;
    this.keyValue = keyValue;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      keyValue: "key-value"
    };
  }
};
var ApplicationParams = class extends BaseModel {
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "global-state",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
};
var ApplicationStateSchema = class extends BaseModel {
  constructor(numUint, numByteSlice) {
    super();
    this.numUint = numUint;
    this.numByteSlice = numByteSlice;
    this.attribute_map = {
      numUint: "num-uint",
      numByteSlice: "num-byte-slice"
    };
  }
};
var Asset = class extends BaseModel {
  constructor(index, params) {
    super();
    this.index = index;
    this.params = params;
    this.attribute_map = {
      index: "index",
      params: "params"
    };
  }
};
var AssetHolding = class extends BaseModel {
  constructor(amount, assetId, isFrozen) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen"
    };
  }
};
var AssetParams = class extends BaseModel {
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
};
var BlockResponse = class extends BaseModel {
  constructor(block, cert) {
    super();
    this.block = block;
    this.cert = cert;
    this.attribute_map = {
      block: "block",
      cert: "cert"
    };
  }
};
var BuildVersion = class extends BaseModel {
  constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
    super();
    this.branch = branch;
    this.buildNumber = buildNumber;
    this.channel = channel;
    this.commitHash = commitHash;
    this.major = major;
    this.minor = minor;
    this.attribute_map = {
      branch: "branch",
      buildNumber: "build_number",
      channel: "channel",
      commitHash: "commit_hash",
      major: "major",
      minor: "minor"
    };
  }
};
var CatchpointAbortResponse = class extends BaseModel {
  constructor(catchupMessage) {
    super();
    this.catchupMessage = catchupMessage;
    this.attribute_map = {
      catchupMessage: "catchup-message"
    };
  }
};
var CatchpointStartResponse = class extends BaseModel {
  constructor(catchupMessage) {
    super();
    this.catchupMessage = catchupMessage;
    this.attribute_map = {
      catchupMessage: "catchup-message"
    };
  }
};
var CompileResponse = class extends BaseModel {
  constructor(hash, result, sourcemap) {
    super();
    this.hash = hash;
    this.result = result;
    this.sourcemap = sourcemap;
    this.attribute_map = {
      hash: "hash",
      result: "result",
      sourcemap: "sourcemap"
    };
  }
};
var DisassembleResponse = class extends BaseModel {
  constructor(result) {
    super();
    this.result = result;
    this.attribute_map = {
      result: "result"
    };
  }
};
var DryrunRequest = class extends BaseModel {
  constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
    super();
    this.accounts = accounts;
    this.apps = apps;
    this.latestTimestamp = latestTimestamp;
    this.protocolVersion = protocolVersion;
    this.round = round;
    this.sources = sources;
    this.txns = txns;
    this.attribute_map = {
      accounts: "accounts",
      apps: "apps",
      latestTimestamp: "latest-timestamp",
      protocolVersion: "protocol-version",
      round: "round",
      sources: "sources",
      txns: "txns"
    };
  }
};
var DryrunResponse = class extends BaseModel {
  constructor(error, protocolVersion, txns) {
    super();
    this.error = error;
    this.protocolVersion = protocolVersion;
    this.txns = txns;
    this.attribute_map = {
      error: "error",
      protocolVersion: "protocol-version",
      txns: "txns"
    };
  }
};
var DryrunSource = class extends BaseModel {
  constructor(fieldName, source, txnIndex, appIndex) {
    super();
    this.fieldName = fieldName;
    this.source = source;
    this.txnIndex = txnIndex;
    this.appIndex = appIndex;
    this.attribute_map = {
      fieldName: "field-name",
      source: "source",
      txnIndex: "txn-index",
      appIndex: "app-index"
    };
  }
};
var DryrunState = class extends BaseModel {
  constructor({ line, pc, stack, error, scratch }) {
    super();
    this.line = line;
    this.pc = pc;
    this.stack = stack;
    this.error = error;
    this.scratch = scratch;
    this.attribute_map = {
      line: "line",
      pc: "pc",
      stack: "stack",
      error: "error",
      scratch: "scratch"
    };
  }
};
var DryrunTxnResult = class extends BaseModel {
  constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, cost, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
    super();
    this.disassembly = disassembly;
    this.appCallMessages = appCallMessages;
    this.appCallTrace = appCallTrace;
    this.budgetAdded = budgetAdded;
    this.budgetConsumed = budgetConsumed;
    this.cost = cost;
    this.globalDelta = globalDelta;
    this.localDeltas = localDeltas;
    this.logicSigDisassembly = logicSigDisassembly;
    this.logicSigMessages = logicSigMessages;
    this.logicSigTrace = logicSigTrace;
    this.logs = logs;
    this.attribute_map = {
      disassembly: "disassembly",
      appCallMessages: "app-call-messages",
      appCallTrace: "app-call-trace",
      budgetAdded: "budget-added",
      budgetConsumed: "budget-consumed",
      cost: "cost",
      globalDelta: "global-delta",
      localDeltas: "local-deltas",
      logicSigDisassembly: "logic-sig-disassembly",
      logicSigMessages: "logic-sig-messages",
      logicSigTrace: "logic-sig-trace",
      logs: "logs"
    };
  }
};
var ErrorResponse = class extends BaseModel {
  constructor(message, data) {
    super();
    this.message = message;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
};
var EvalDelta = class extends BaseModel {
  constructor(action, bytes, uint) {
    super();
    this.action = action;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
};
var EvalDeltaKeyValue = class extends BaseModel {
  constructor(key, value) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
};
var LightBlockHeaderProof2 = class extends BaseModel {
  constructor(index, proof, treedepth) {
    super();
    this.index = index;
    this.proof = typeof proof === "string" ? new Uint8Array(Buffer.from(proof, "base64")) : proof;
    this.treedepth = treedepth;
    this.attribute_map = {
      index: "index",
      proof: "proof",
      treedepth: "treedepth"
    };
  }
};
var NodeStatusResponse = class extends BaseModel {
  constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointTotalAccounts, catchpointTotalBlocks, catchpointVerifiedAccounts, lastCatchpoint }) {
    super();
    this.catchupTime = catchupTime;
    this.lastRound = lastRound;
    this.lastVersion = lastVersion;
    this.nextVersion = nextVersion;
    this.nextVersionRound = nextVersionRound;
    this.nextVersionSupported = nextVersionSupported;
    this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
    this.timeSinceLastRound = timeSinceLastRound;
    this.catchpoint = catchpoint;
    this.catchpointAcquiredBlocks = catchpointAcquiredBlocks;
    this.catchpointProcessedAccounts = catchpointProcessedAccounts;
    this.catchpointTotalAccounts = catchpointTotalAccounts;
    this.catchpointTotalBlocks = catchpointTotalBlocks;
    this.catchpointVerifiedAccounts = catchpointVerifiedAccounts;
    this.lastCatchpoint = lastCatchpoint;
    this.attribute_map = {
      catchupTime: "catchup-time",
      lastRound: "last-round",
      lastVersion: "last-version",
      nextVersion: "next-version",
      nextVersionRound: "next-version-round",
      nextVersionSupported: "next-version-supported",
      stoppedAtUnsupportedRound: "stopped-at-unsupported-round",
      timeSinceLastRound: "time-since-last-round",
      catchpoint: "catchpoint",
      catchpointAcquiredBlocks: "catchpoint-acquired-blocks",
      catchpointProcessedAccounts: "catchpoint-processed-accounts",
      catchpointTotalAccounts: "catchpoint-total-accounts",
      catchpointTotalBlocks: "catchpoint-total-blocks",
      catchpointVerifiedAccounts: "catchpoint-verified-accounts",
      lastCatchpoint: "last-catchpoint"
    };
  }
};
var PendingTransactionResponse = class extends BaseModel {
  constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
    super();
    this.poolError = poolError;
    this.txn = txn;
    this.applicationIndex = applicationIndex;
    this.assetClosingAmount = assetClosingAmount;
    this.assetIndex = assetIndex;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.globalStateDelta = globalStateDelta;
    this.innerTxns = innerTxns;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.receiverRewards = receiverRewards;
    this.senderRewards = senderRewards;
    this.attribute_map = {
      poolError: "pool-error",
      txn: "txn",
      applicationIndex: "application-index",
      assetClosingAmount: "asset-closing-amount",
      assetIndex: "asset-index",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      globalStateDelta: "global-state-delta",
      innerTxns: "inner-txns",
      localStateDelta: "local-state-delta",
      logs: "logs",
      receiverRewards: "receiver-rewards",
      senderRewards: "sender-rewards"
    };
  }
};
var PendingTransactionsResponse = class extends BaseModel {
  constructor(topTransactions, totalTransactions) {
    super();
    this.topTransactions = topTransactions;
    this.totalTransactions = totalTransactions;
    this.attribute_map = {
      topTransactions: "top-transactions",
      totalTransactions: "total-transactions"
    };
  }
};
var PostTransactionsResponse = class extends BaseModel {
  constructor(txid) {
    super();
    this.txid = txid;
    this.attribute_map = {
      txid: "txId"
    };
  }
};
var StateProof2 = class extends BaseModel {
  constructor(message, stateproof) {
    super();
    this.message = message;
    this.stateproof = typeof stateproof === "string" ? new Uint8Array(Buffer.from(stateproof, "base64")) : stateproof;
    this.attribute_map = {
      message: "Message",
      stateproof: "StateProof"
    };
  }
};
var StateProofMessage = class extends BaseModel {
  constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
    super();
    this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? new Uint8Array(Buffer.from(blockheaderscommitment, "base64")) : blockheaderscommitment;
    this.firstattestedround = firstattestedround;
    this.lastattestedround = lastattestedround;
    this.lnprovenweight = lnprovenweight;
    this.voterscommitment = typeof voterscommitment === "string" ? new Uint8Array(Buffer.from(voterscommitment, "base64")) : voterscommitment;
    this.attribute_map = {
      blockheaderscommitment: "BlockHeadersCommitment",
      firstattestedround: "FirstAttestedRound",
      lastattestedround: "LastAttestedRound",
      lnprovenweight: "LnProvenWeight",
      voterscommitment: "VotersCommitment"
    };
  }
};
var SupplyResponse = class extends BaseModel {
  constructor(currentRound, onlineMoney, totalMoney) {
    super();
    this.currentRound = currentRound;
    this.onlineMoney = onlineMoney;
    this.totalMoney = totalMoney;
    this.attribute_map = {
      currentRound: "current_round",
      onlineMoney: "online-money",
      totalMoney: "total-money"
    };
  }
};
var TealKeyValue = class extends BaseModel {
  constructor(key, value) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
};
var TealValue = class extends BaseModel {
  constructor(type, bytes, uint) {
    super();
    this.type = type;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      type: "type",
      bytes: "bytes",
      uint: "uint"
    };
  }
};
var TransactionParametersResponse = class extends BaseModel {
  constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
    super();
    this.consensusVersion = consensusVersion;
    this.fee = fee;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.lastRound = lastRound;
    this.minFee = minFee;
    this.attribute_map = {
      consensusVersion: "consensus-version",
      fee: "fee",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      lastRound: "last-round",
      minFee: "min-fee"
    };
  }
};
var TransactionProofResponse = class extends BaseModel {
  constructor({ idx, proof, stibhash, treedepth, hashtype }) {
    super();
    this.idx = idx;
    this.proof = typeof proof === "string" ? new Uint8Array(Buffer.from(proof, "base64")) : proof;
    this.stibhash = typeof stibhash === "string" ? new Uint8Array(Buffer.from(stibhash, "base64")) : stibhash;
    this.treedepth = treedepth;
    this.hashtype = hashtype;
    this.attribute_map = {
      idx: "idx",
      proof: "proof",
      stibhash: "stibhash",
      treedepth: "treedepth",
      hashtype: "hashtype"
    };
  }
};
var Version = class extends BaseModel {
  constructor(build, genesisHashB64, genesisId, versions) {
    super();
    this.build = build;
    this.genesisHashB64 = typeof genesisHashB64 === "string" ? new Uint8Array(Buffer.from(genesisHashB64, "base64")) : genesisHashB64;
    this.genesisId = genesisId;
    this.versions = versions;
    this.attribute_map = {
      build: "build",
      genesisHashB64: "genesis_hash_b64",
      genesisId: "genesis_id",
      versions: "versions"
    };
  }
};

// node_modules/algosdk/dist/esm/src/mnemonic/wordlists/english.js
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
var english_default = english;

// node_modules/algosdk/dist/esm/src/mnemonic/mnemonic.js
init_naclWrappers();
init_address();
var FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
var NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add);
  flush();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n) => english_default[n]);
}
function computeChecksum(seed) {
  const hashBuffer = genericHash(seed);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function mnemonicFromSeed(seed) {
  if (seed.length !== SEED_BTYES_LENGTH) {
    throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
  }
  const uint11Array = toUint11Array(seed);
  const words = applyWords(uint11Array);
  const checksumWord = computeChecksum(seed);
  return `${words.join(" ")} ${checksumWord}`;
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add);
  flush();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w of key) {
    if (english_default.indexOf(w) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word) => english_default.indexOf(word));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs = computeChecksum(uint8Array);
  if (cs === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn) {
  const seed = seedFromMnemonic(mn);
  const keys = keyPairFromSeed(seed);
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
function secretKeyToMnemonic(sk) {
  const seed = sk.slice(0, SEED_BTYES_LENGTH);
  return mnemonicFromSeed(seed);
}
function mnemonicToMasterDerivationKey(mn) {
  return seedFromMnemonic(mn);
}
function masterDerivationKeyToMnemonic(mdk) {
  return mnemonicFromSeed(mdk);
}

// node_modules/algosdk/dist/esm/src/main.js
init_group();
init_logicsig();
init_multisig();

// node_modules/vlq/src/index.js
var char_to_integer = {};
var integer_to_char = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i) {
  char_to_integer[char] = i;
  integer_to_char[i] = char;
});
function decode3(string) {
  let result = [];
  let shift = 0;
  let value = 0;
  for (let i = 0; i < string.length; i += 1) {
    let integer = char_to_integer[string[i]];
    if (integer === void 0) {
      throw new Error("Invalid character (" + string[i] + ")");
    }
    const has_continuation_bit = integer & 32;
    integer &= 31;
    value += integer << shift;
    if (has_continuation_bit) {
      shift += 5;
    } else {
      const should_negate = value & 1;
      value >>>= 1;
      if (should_negate) {
        result.push(value === 0 ? -2147483648 : -value);
      } else {
        result.push(value);
      }
      value = shift = 0;
    }
  }
  return result;
}

// node_modules/algosdk/dist/esm/src/logic/sourcemap.js
var SourceMap = class {
  constructor({ version, sources, names, mappings }) {
    this.version = version;
    this.sources = sources;
    this.names = names;
    this.mappings = mappings;
    if (this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    const pcList = this.mappings.split(";").map((m) => {
      const decoded = decode3(m);
      if (decoded.length > 2)
        return decoded[2];
      return void 0;
    });
    this.pcToLine = {};
    this.lineToPc = {};
    let lastLine = 0;
    for (const [pc, lineDelta] of pcList.entries()) {
      if (lineDelta !== void 0) {
        lastLine += lineDelta;
      }
      if (!(lastLine in this.lineToPc))
        this.lineToPc[lastLine] = [];
      this.lineToPc[lastLine].push(pc);
      this.pcToLine[pc] = lastLine;
    }
  }
  getLineForPc(pc) {
    return this.pcToLine[pc];
  }
  getPcsForLine(line) {
    return this.lineToPc[line];
  }
};

// node_modules/algosdk/dist/esm/src/dryrun.js
init_transactions();
init_address();
var defaultAppId = 1380011588;
var defaultMaxWidth = 30;
function decodePrograms(ap) {
  ap.params["approval-program"] = Buffer.from(ap.params["approval-program"].toString(), "base64");
  ap.params["clear-state-program"] = Buffer.from(ap.params["clear-state-program"].toString(), "base64");
  return ap;
}
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
  const appInfos = [];
  const acctInfos = [];
  const apps = [];
  const assets = [];
  const accts = [];
  for (const t of txns) {
    if (t.txn.type === TransactionType.appl) {
      accts.push(encodeAddress(t.txn.from.publicKey));
      if (t.txn.appAccounts)
        accts.push(...t.txn.appAccounts.map((a) => encodeAddress(a.publicKey)));
      if (t.txn.appForeignApps) {
        apps.push(...t.txn.appForeignApps);
        accts.push(...t.txn.appForeignApps.map((aidx) => getApplicationAddress(aidx)));
      }
      if (t.txn.appForeignAssets)
        assets.push(...t.txn.appForeignAssets);
      if (t.txn.appIndex === void 0 || t.txn.appIndex === 0) {
        appInfos.push(new Application(defaultAppId, new ApplicationParams({
          creator: encodeAddress(t.txn.from.publicKey),
          approvalProgram: t.txn.appApprovalProgram,
          clearStateProgram: t.txn.appClearProgram,
          localStateSchema: new ApplicationStateSchema(t.txn.appLocalInts, t.txn.appLocalByteSlices),
          globalStateSchema: new ApplicationStateSchema(t.txn.appGlobalInts, t.txn.appGlobalByteSlices)
        })));
      } else {
        apps.push(t.txn.appIndex);
        accts.push(getApplicationAddress(t.txn.appIndex));
      }
    }
  }
  const assetPromises = [];
  for (const assetId of [...new Set(assets)]) {
    assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
      accts.push(assetInfo.params.creator);
    }));
  }
  await Promise.all(assetPromises);
  const appPromises = [];
  for (const appId of [...new Set(apps)]) {
    appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
      const ai = decodePrograms(appInfo);
      appInfos.push(ai);
      accts.push(ai.params.creator);
    }));
  }
  await Promise.all(appPromises);
  const acctPromises = [];
  for (const acct of [...new Set(accts)]) {
    acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
      if ("created-apps" in acctInfo) {
        acctInfo["created-apps"] = acctInfo["created-apps"].map((app) => decodePrograms(app));
      }
      acctInfos.push(acctInfo);
    }));
  }
  await Promise.all(acctPromises);
  return new DryrunRequest({
    txns: txns.map((st) => ({ ...st, txn: st.txn.get_obj_for_encoding() })),
    accounts: acctInfos,
    apps: appInfos,
    latestTimestamp,
    round,
    protocolVersion,
    sources
  });
}
var DryrunStackValue = class {
  constructor(sv) {
    this.type = 0;
    this.bytes = "";
    this.uint = 0;
    this.type = sv.type;
    this.bytes = sv.bytes;
    this.uint = sv.uint;
  }
  toString() {
    if (this.type === 1) {
      return `0x${Buffer.from(this.bytes, "base64").toString("hex")}`;
    }
    return this.uint.toString();
  }
};
var DryrunTraceLine = class {
  constructor(line) {
    this.error = "";
    this.line = 0;
    this.pc = 0;
    this.scratch = [];
    this.stack = [];
    this.error = line.error === void 0 ? "" : line.error;
    this.line = line.line;
    this.pc = line.pc;
    this.scratch = line.scratch;
    this.stack = line.stack.map((sv) => new DryrunStackValue(sv));
  }
};
var DryrunTrace = class {
  constructor(t) {
    this.trace = [];
    if (t === void 0)
      return;
    this.trace = t.map((line) => new DryrunTraceLine(line));
  }
};
function truncate(str, maxValueWidth) {
  if (str.length > maxValueWidth && maxValueWidth > 0) {
    return `${str.slice(0, maxValueWidth)}...`;
  }
  return str;
}
function scratchToString(prevScratch, currScratch) {
  if (currScratch.length === 0)
    return "";
  let newScratchIdx = null;
  for (let idx = 0; idx < currScratch.length; idx++) {
    if (idx > prevScratch.length) {
      newScratchIdx = idx;
      continue;
    }
    if (JSON.stringify(prevScratch[idx]) !== JSON.stringify(currScratch[idx])) {
      newScratchIdx = idx;
    }
  }
  if (newScratchIdx == null)
    return "";
  const newScratch = currScratch[newScratchIdx];
  if (newScratch.bytes.length > 0) {
    return `${newScratchIdx} = 0x${Buffer.from(newScratch.bytes, "base64").toString("hex")}`;
  }
  return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse) {
  const svs = reverse ? stack.reverse() : stack;
  return `[${svs.map((sv) => {
    switch (sv.type) {
      case 1:
        return `0x${Buffer.from(sv.bytes, "base64").toString("hex")}`;
      case 2:
        return `${sv.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
var DryrunTransactionResult = class {
  constructor(dtr) {
    this.disassembly = [];
    this.appCallMessages = [];
    this.localDeltas = [];
    this.globalDelta = [];
    this.cost = 0;
    this.logicSigMessages = [];
    this.logicSigDisassembly = [];
    this.logs = [];
    this.appCallTrace = void 0;
    this.logicSigTrace = void 0;
    this.required = ["disassembly"];
    this.optionals = [
      "app-call-messages",
      "local-deltas",
      "global-delta",
      "cost",
      "logic-sig-messages",
      "logic-sig-disassembly",
      "logs"
    ];
    this.traces = ["app-call-trace", "logic-sig-trace"];
    this.disassembly = dtr.disassembly;
    this.appCallMessages = dtr["app-call-messages"];
    this.localDeltas = dtr["local-deltas"];
    this.globalDelta = dtr["global-delta"];
    this.cost = dtr.cost;
    this.logicSigMessages = dtr["logic-sig-messages"];
    this.logicSigDisassembly = dtr["logic-sig-disassembly"];
    this.logs = dtr.logs;
    this.appCallTrace = new DryrunTrace(dtr["app-call-trace"]);
    this.logicSigTrace = new DryrunTrace(dtr["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(drt, disassembly, spc) {
    const maxWidth = spc.maxValueWidth || defaultMaxWidth;
    const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let idx = 0; idx < drt.trace.length; idx++) {
      const { line, error, pc, scratch, stack } = drt.trace[idx];
      const currScratch = scratch !== void 0 ? scratch : [];
      const prevScratch = idx > 0 && drt.trace[idx - 1].scratch !== void 0 ? drt.trace[idx - 1].scratch : [];
      const src = error === "" ? disassembly[line] : `!! ${error} !!`;
      lines.push([
        pc.toString().padEnd(3, " "),
        line.toString().padEnd(3, " "),
        truncate(src, maxWidth),
        truncate(scratchToString(prevScratch, currScratch), maxWidth),
        truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
      ]);
    }
    const maxLengths = lines.reduce((prev, curr) => {
      const newVal = new Array(lines[0].length).fill(0);
      for (let idx = 0; idx < prev.length; idx++) {
        newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
      }
      return newVal;
    }, new Array(lines[0].length).fill(0));
    return `${lines.map((line) => line.map((v, idx) => v.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
  }
  appTrace(spc) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: false
      };
    return DryrunTransactionResult.trace(this.appCallTrace, this.disassembly, conf);
  }
  lsigTrace(spc) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: true
      };
    return DryrunTransactionResult.trace(this.logicSigTrace, this.logicSigDisassembly, conf);
  }
};
var DryrunResult = class {
  constructor(drrResp) {
    this.error = "";
    this.protocolVersion = "";
    this.txns = [];
    this.error = drrResp.error;
    this.protocolVersion = drrResp["protocol-version"];
    this.txns = drrResp.txns.map((txn) => new DryrunTransactionResult(txn));
  }
};

// node_modules/algosdk/dist/esm/src/main.js
init_makeTxn();
init_transaction();

// node_modules/algosdk/dist/esm/src/signer.js
init_logicsig();
init_multisig();
function makeBasicAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      signed.push(txnGroup[index].signTxn(account.sk));
    }
    return Promise.resolve(signed);
  };
}
function makeLogicSigAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      const { blob } = signLogicSigTransactionObject(txnGroup[index], account);
      signed.push(blob);
    }
    return Promise.resolve(signed);
  };
}
function makeMultiSigAccountTransactionSigner(msig, sks) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      const txn = txnGroup[index];
      const partialSigs = [];
      for (const sk of sks) {
        const { blob } = signMultisigTransaction(txn, msig, sk);
        partialSigs.push(blob);
      }
      signed.push(mergeMultisigTransactions(partialSigs));
    }
    return Promise.resolve(signed);
  };
}
function isTransactionWithSigner(value) {
  return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
}

// node_modules/algosdk/dist/esm/src/abi/abi_type.js
init_address();
init_utils();
var MAX_LEN = 2 ** 16 - 1;
var ADDR_BYTE_SIZE = 32;
var SINGLE_BYTE_SIZE = 1;
var SINGLE_BOOL_SIZE = 1;
var LENGTH_ENCODE_BYTE_SIZE = 2;
var staticArrayRegexp = /^([a-z\d[\](),]+)\[([1-9][\d]*)]$/;
var ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
var ABIType = class {
  static from(str) {
    if (str.endsWith("[]")) {
      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));
      return new ABIArrayDynamicType(arrayArgType);
    }
    if (str.endsWith("]")) {
      const stringMatches = str.match(staticArrayRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed static array string: ${str}`);
      }
      const arrayLengthStr = stringMatches[2];
      const arrayLength = parseInt(arrayLengthStr, 10);
      if (arrayLength > MAX_LEN) {
        throw new Error(`array length exceeds limit ${MAX_LEN}`);
      }
      const arrayType = ABIType.from(stringMatches[1]);
      return new ABIArrayStaticType(arrayType, arrayLength);
    }
    if (str.startsWith("uint")) {
      const digitsOnly = (string) => [...string].every((c) => "0123456789".includes(c));
      const typeSizeStr = str.slice(4, str.length);
      if (!digitsOnly(typeSizeStr)) {
        throw new Error(`malformed uint string: ${typeSizeStr}`);
      }
      const typeSize = parseInt(typeSizeStr, 10);
      if (typeSize > MAX_LEN) {
        throw new Error(`malformed uint string: ${typeSize}`);
      }
      return new ABIUintType(typeSize);
    }
    if (str === "byte") {
      return new ABIByteType();
    }
    if (str.startsWith("ufixed")) {
      const stringMatches = str.match(ufixedRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed ufixed type: ${str}`);
      }
      const ufixedSize = parseInt(stringMatches[1], 10);
      const ufixedPrecision = parseInt(stringMatches[2], 10);
      return new ABIUfixedType(ufixedSize, ufixedPrecision);
    }
    if (str === "bool") {
      return new ABIBoolType();
    }
    if (str === "address") {
      return new ABIAddressType();
    }
    if (str === "string") {
      return new ABIStringType();
    }
    if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
      const tupleTypes = [];
      for (let i = 0; i < tupleContent.length; i++) {
        const ti = ABIType.from(tupleContent[i]);
        tupleTypes.push(ti);
      }
      return new ABITupleType(tupleTypes);
    }
    throw new Error(`cannot convert a string ${str} to an ABI type`);
  }
};
var ABIUintType = class extends ABIType {
  constructor(size) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported uint type bitSize: ${size}`);
    }
    this.bitSize = size;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(other) {
    return other instanceof ABIUintType && this.bitSize === other.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIUfixedType = class extends ABIType {
  constructor(size, denominator) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported ufixed type bitSize: ${size}`);
    }
    if (denominator > 160 || denominator < 1) {
      throw new Error(`unsupported ufixed type precision: ${denominator}`);
    }
    this.bitSize = size;
    this.precision = denominator;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(other) {
    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIAddressType = class extends ABIType {
  toString() {
    return "address";
  }
  equals(other) {
    return other instanceof ABIAddressType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ADDR_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (typeof value === "string") {
      const decodedAddress = decodeAddress(value);
      return decodedAddress.publicKey;
    }
    if (value.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return value;
  }
  decode(byteString) {
    if (byteString.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return encodeAddress(byteString);
  }
};
var ABIBoolType = class extends ABIType {
  toString() {
    return "bool";
  }
  equals(other) {
    return other instanceof ABIBoolType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BOOL_SIZE;
  }
  encode(value) {
    if (typeof value !== "boolean") {
      throw new Error(`Cannot encode value as bool: ${value}`);
    }
    if (value) {
      return new Uint8Array([128]);
    }
    return new Uint8Array([0]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`bool string must be 1 byte long`);
    }
    const value = byteString[0];
    if (value === 128) {
      return true;
    }
    if (value === 0) {
      return false;
    }
    throw new Error(`boolean could not be decoded from the byte string`);
  }
};
var ABIByteType = class extends ABIType {
  toString() {
    return "byte";
  }
  equals(other) {
    return other instanceof ABIByteType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "number" && typeof value !== "bigint") {
      throw new Error(`Cannot encode value as byte: ${value}`);
    }
    if (typeof value === "bigint") {
      value = Number(value);
    }
    if (value < 0 || value > 255) {
      throw new Error(`${value} cannot be encoded into a byte`);
    }
    return new Uint8Array([value]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`byte string must be 1 byte long`);
    }
    return byteString[0];
  }
};
var ABIStringType = class extends ABIType {
  toString() {
    return "string";
  }
  equals(other) {
    return other instanceof ABIStringType;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as string: ${value}`);
    }
    const encodedBytes = Buffer.from(value);
    const encodedLength = bigIntToBytes(value.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = new Uint8Array(value.length + LENGTH_ENCODE_BYTE_SIZE);
    mergedBytes.set(encodedLength);
    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
    return mergedBytes;
  }
  decode(byteString) {
    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
    }
    const buf = Buffer.from(byteString);
    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
    if (byteLength !== byteValue.length) {
      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);
    }
    return Buffer.from(byteValue).toString("utf-8");
  }
};
var ABIArrayStaticType = class extends ABIType {
  constructor(argType, arrayLength) {
    super();
    if (arrayLength < 1) {
      throw new Error(`static array must have a length greater than 0: ${arrayLength}`);
    }
    this.childType = argType;
    this.staticLength = arrayLength;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(other) {
    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    if (this.childType.constructor === ABIBoolType) {
      return Math.ceil(this.staticLength / 8);
    }
    return this.staticLength * this.childType.byteLen();
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value.length !== this.staticLength) {
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
    }
    const convertedTuple = this.toABITupleType();
    return convertedTuple.encode(value);
  }
  decode(byteString) {
    const convertedTuple = this.toABITupleType();
    return convertedTuple.decode(byteString);
  }
  toABITupleType() {
    return new ABITupleType(Array(this.staticLength).fill(this.childType));
  }
};
var ABIArrayDynamicType = class extends ABIType {
  constructor(argType) {
    super();
    this.childType = argType;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(other) {
    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const convertedTuple = this.toABITupleType(value.length);
    const encodedTuple = convertedTuple.encode(value);
    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = concatArrays(encodedLength, encodedTuple);
    return mergedBytes;
  }
  decode(byteString) {
    const buf = Buffer.from(byteString);
    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const convertedTuple = this.toABITupleType(byteLength);
    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
  }
  toABITupleType(length) {
    return new ABITupleType(Array(length).fill(this.childType));
  }
};
var ABITupleType = class extends ABIType {
  constructor(argTypes) {
    super();
    if (argTypes.length >= MAX_LEN) {
      throw new Error("tuple type child type number larger than maximum uint16 error");
    }
    this.childTypes = argTypes;
  }
  toString() {
    const typeStrings = [];
    for (let i = 0; i < this.childTypes.length; i++) {
      typeStrings[i] = this.childTypes[i].toString();
    }
    return `(${typeStrings.join(",")})`;
  }
  equals(other) {
    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));
  }
  isDynamic() {
    const isDynamic = (child) => child.isDynamic();
    return this.childTypes.some(isDynamic);
  }
  byteLen() {
    let size = 0;
    for (let i = 0; i < this.childTypes.length; i++) {
      if (this.childTypes[i].constructor === ABIBoolType) {
        const after = findBoolLR(this.childTypes, i, 1);
        const boolNum = after + 1;
        i += after;
        size += Math.trunc((boolNum + 7) / 8);
      } else {
        const childByteSize = this.childTypes[i].byteLen();
        size += childByteSize;
      }
    }
    return size;
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const values = Array.from(value);
    if (value.length > MAX_LEN) {
      throw new Error("length of tuple array should not exceed a uint16");
    }
    const tupleTypes = this.childTypes;
    const heads = [];
    const tails = [];
    const isDynamicIndex = /* @__PURE__ */ new Map();
    let i = 0;
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        isDynamicIndex.set(heads.length, true);
        heads.push(new Uint8Array([0, 0]));
        tails.push(tupleType.encode(values[i]));
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(tupleTypes, i, -1);
          let after = findBoolLR(tupleTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          }
          after = Math.min(7, after);
          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));
          heads.push(bigIntToBytes(compressedInt, 1));
          i += after;
        } else {
          const encodedTupleValue = tupleType.encode(values[i]);
          heads.push(encodedTupleValue);
        }
        isDynamicIndex.set(i, false);
        tails.push(new Uint8Array());
      }
      i += 1;
    }
    let headLength = 0;
    for (const headElement of heads) {
      headLength += headElement.length;
    }
    let tailLength = 0;
    for (let j = 0; j < heads.length; j++) {
      if (isDynamicIndex.get(j)) {
        const headValue = headLength + tailLength;
        if (headValue > MAX_LEN) {
          throw new Error(`byte length of ${headValue} should not exceed a uint16`);
        }
        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
      }
      tailLength += tails[j].length;
    }
    return concatArrays(...heads, ...tails);
  }
  decode(byteString) {
    const tupleTypes = this.childTypes;
    const dynamicSegments = [];
    const valuePartition = [];
    let i = 0;
    let iterIndex = 0;
    const buf = Buffer.from(byteString);
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error("dynamic type in tuple is too short to be decoded");
        }
        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
            throw new Error("dynamic index segment miscalculation: left is greater than right index");
          }
        }
        const seg = {
          left: dynamicIndex,
          right: -1
        };
        dynamicSegments.push(seg);
        valuePartition.push(null);
        iterIndex += LENGTH_ENCODE_BYTE_SIZE;
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(this.childTypes, i, -1);
          let after = findBoolLR(this.childTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before bool number mod 8 === 0");
          }
          after = Math.min(7, after);
          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
            const boolMask = 128 >> boolIndex;
            if ((byteString[iterIndex] & boolMask) > 0) {
              valuePartition.push(new Uint8Array([128]));
            } else {
              valuePartition.push(new Uint8Array([0]));
            }
          }
          i += after;
          iterIndex += 1;
        } else {
          const currLen = tupleType.byteLen();
          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
          iterIndex += currLen;
        }
      }
      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
        throw new Error("input byte not enough to decode");
      }
      i += 1;
    }
    if (dynamicSegments.length > 0) {
      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
      iterIndex = byteString.length;
    }
    if (iterIndex < byteString.length) {
      throw new Error("input byte not fully consumed");
    }
    for (let j = 0; j < dynamicSegments.length; j++) {
      const seg = dynamicSegments[j];
      if (seg.left > seg.right) {
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      }
      if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {
        throw new Error("dynamic segment should be consecutive");
      }
    }
    let segIndex = 0;
    for (let j = 0; j < tupleTypes.length; j++) {
      if (tupleTypes[j].isDynamic()) {
        valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
        segIndex += 1;
      }
    }
    const returnValues = [];
    for (let j = 0; j < tupleTypes.length; j++) {
      const valueTi = tupleTypes[j].decode(valuePartition[j]);
      returnValues.push(valueTi);
    }
    return returnValues;
  }
  static parseTupleContent(str) {
    if (str.length === 0) {
      return [];
    }
    if (str.endsWith(",") || str.startsWith(",")) {
      throw new Error("tuple string should not start with comma");
    }
    if (str.includes(",,")) {
      throw new Error("tuple string should not have consecutive commas");
    }
    const tupleStrings = [];
    let depth = 0;
    let word = "";
    for (const char of str) {
      word += char;
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        depth -= 1;
      } else if (char === ",") {
        if (depth === 0) {
          tupleStrings.push(word.slice(0, word.length - 1));
          word = "";
        }
      }
    }
    if (word.length !== 0) {
      tupleStrings.push(word);
    }
    if (depth !== 0) {
      throw new Error("tuple string has mismatched parentheses");
    }
    return tupleStrings;
  }
};
function compressMultipleBool(valueList) {
  let res = 0;
  if (valueList.length > 8) {
    throw new Error("value list passed in should be no greater than length 8");
  }
  for (let i = 0; i < valueList.length; i++) {
    const boolVal = valueList[i];
    if (typeof boolVal !== "boolean") {
      throw new Error("non-boolean values cannot be compressed into a byte");
    }
    if (boolVal) {
      res |= 1 << 7 - i;
    }
  }
  return res;
}
function findBoolLR(typeList, index, delta) {
  let until = 0;
  while (true) {
    const curr = index + delta * until;
    if (typeList[curr].constructor === ABIBoolType) {
      if (curr !== typeList.length - 1 && delta === 1) {
        until += 1;
      } else if (curr > 0 && delta === -1) {
        until += 1;
      } else {
        break;
      }
    } else {
      until -= 1;
      break;
    }
  }
  return until;
}

// node_modules/algosdk/dist/esm/src/abi/method.js
init_naclWrappers();

// node_modules/algosdk/dist/esm/src/abi/transaction.js
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
function abiTypeIsTransaction(type) {
  return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
}
function abiCheckTransactionType(type, txn) {
  if (type === ABITransactionType.any) {
    return true;
  }
  return txn.type && txn.type.toString() === type.toString();
}

// node_modules/algosdk/dist/esm/src/abi/reference.js
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
function abiTypeIsReference(type) {
  return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
}

// node_modules/algosdk/dist/esm/src/abi/method.js
function parseMethodSignature(signature) {
  const argsStart = signature.indexOf("(");
  if (argsStart === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  let argsEnd = -1;
  let depth = 0;
  for (let i = argsStart; i < signature.length; i++) {
    const char = signature[i];
    if (char === "(") {
      depth += 1;
    } else if (char === ")") {
      if (depth === 0) {
        break;
      }
      depth -= 1;
      if (depth === 0) {
        argsEnd = i;
        break;
      }
    }
  }
  if (argsEnd === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  return {
    name: signature.slice(0, argsStart),
    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
    returns: signature.slice(argsEnd + 1)
  };
}
var ABIMethod = class {
  constructor(params) {
    if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
      throw new Error("Invalid ABIMethod parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.args = params.args.map(({ type, name, desc }) => {
      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
        return {
          type,
          name,
          description: desc
        };
      }
      return {
        type: ABIType.from(type),
        name,
        description: desc
      };
    });
    this.returns = {
      type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
      description: params.returns.desc
    };
  }
  getSignature() {
    const args = this.args.map((arg) => arg.type.toString()).join(",");
    const returns = this.returns.type.toString();
    return `${this.name}(${args})${returns}`;
  }
  getSelector() {
    const hash = genericHash(this.getSignature());
    return new Uint8Array(hash.slice(0, 4));
  }
  txnCount() {
    let count = 1;
    for (const arg of this.args) {
      if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
        count += 1;
      }
    }
    return count;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      args: this.args.map(({ type, name, description }) => ({
        type: type.toString(),
        name,
        desc: description
      })),
      returns: {
        type: this.returns.type.toString(),
        desc: this.returns.description
      }
    };
  }
  static fromSignature(signature) {
    const { name, args, returns } = parseMethodSignature(signature);
    return new ABIMethod({
      name,
      args: args.map((arg) => ({ type: arg })),
      returns: { type: returns }
    });
  }
};
function getMethodByName(methods, name) {
  if (methods === null || !Array.isArray(methods) || !methods.every((item) => item instanceof ABIMethod))
    throw new Error("Methods list provided is null or not the correct type");
  const filteredMethods = methods.filter((m) => m.name === name);
  if (filteredMethods.length > 1)
    throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m) => m.getSignature()).join(",")}`);
  if (filteredMethods.length === 0)
    throw new Error(`found 0 methods with the name ${name}`);
  return filteredMethods[0];
}

// node_modules/algosdk/dist/esm/src/abi/contract.js
var ABIContract = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
      throw new Error("Invalid ABIContract parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.networks = params.networks ? { ...params.networks } : {};
    this.methods = params.methods.map((method2) => new ABIMethod(method2));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      networks: this.networks,
      methods: this.methods.map((method2) => method2.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
};

// node_modules/algosdk/dist/esm/src/abi/interface.js
var ABIInterface = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
      throw new Error("Invalid ABIInterface parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.methods = params.methods.map((method2) => new ABIMethod(method2));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      methods: this.methods.map((method2) => method2.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
};

// node_modules/algosdk/dist/esm/src/composer.js
init_transaction();
init_makeTxn();
init_group();
init_base();
var RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);
var MAX_APP_ARGS = 16;
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
function populateForeignArray(valueToAdd, array, zeroValue) {
  if (zeroValue != null && valueToAdd === zeroValue) {
    return 0;
  }
  const offset = zeroValue == null ? 0 : 1;
  for (let i = 0; i < array.length; i++) {
    if (valueToAdd === array[i]) {
      return i + offset;
    }
  }
  array.push(valueToAdd);
  return array.length - 1 + offset;
}
var AtomicTransactionComposer = class {
  constructor() {
    this.status = AtomicTransactionComposerStatus.BUILDING;
    this.transactions = [];
    this.methodCalls = /* @__PURE__ */ new Map();
    this.signedTxns = [];
    this.txIDs = [];
  }
  getStatus() {
    return this.status;
  }
  count() {
    return this.transactions.length;
  }
  clone() {
    const theClone = new AtomicTransactionComposer();
    theClone.transactions = this.transactions.map(({ txn, signer }) => ({
      txn: Transaction.from_obj_for_encoding({
        ...txn.get_obj_for_encoding(),
        grp: void 0
      }),
      signer
    }));
    theClone.methodCalls = new Map(this.methodCalls);
    return theClone;
  }
  addTransaction(txnAndSigner) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {
      throw new Error("Cannot add a transaction with nonzero group ID");
    }
    this.transactions.push(txnAndSigner);
  }
  addMethodCall({ appID, method: method2, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, note, lease, rekeyTo, signer }) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length + method2.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (appID === 0) {
      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
      }
    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
      if (approvalProgram == null || clearProgram == null) {
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      }
      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    }
    if (methodArgs == null) {
      methodArgs = [];
    }
    if (methodArgs.length !== method2.args.length) {
      throw new Error(`Incorrect number of method arguments. Expected ${method2.args.length}, got ${methodArgs.length}`);
    }
    let basicArgTypes = [];
    let basicArgValues = [];
    const txnArgs = [];
    const refArgTypes = [];
    const refArgValues = [];
    const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
    for (let i = 0; i < methodArgs.length; i++) {
      let argType = method2.args[i].type;
      const argValue = methodArgs[i];
      if (abiTypeIsTransaction(argType)) {
        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
          throw new Error(`Expected ${argType} transaction for argument at index ${i}`);
        }
        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        txnArgs.push(argValue);
        continue;
      }
      if (isTransactionWithSigner(argValue)) {
        throw new Error(`Expected non-transaction value for argument at index ${i}`);
      }
      if (abiTypeIsReference(argType)) {
        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
        refArgTypes.push(argType);
        refArgValues.push(argValue);
        argType = new ABIUintType(8);
      }
      if (typeof argType === "string") {
        throw new Error(`Unknown ABI type: ${argType}`);
      }
      basicArgTypes.push(argType);
      basicArgValues.push(argValue);
    }
    const resolvedRefIndexes = [];
    const foreignAccounts = [];
    const foreignApps = [];
    const foreignAssets = [];
    for (let i = 0; i < refArgTypes.length; i++) {
      const refType = refArgTypes[i];
      const refValue = refArgValues[i];
      let resolved = 0;
      switch (refType) {
        case ABIReferenceType.account: {
          const addressType = new ABIAddressType();
          const address = addressType.decode(addressType.encode(refValue));
          resolved = populateForeignArray(address, foreignAccounts, sender);
          break;
        }
        case ABIReferenceType.application: {
          const uint64Type = new ABIUintType(64);
          const refAppID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAppID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for application value, got ${refAppID}`);
          }
          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);
          break;
        }
        case ABIReferenceType.asset: {
          const uint64Type = new ABIUintType(64);
          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAssetID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
          }
          resolved = populateForeignArray(Number(refAssetID), foreignAssets);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${refType}`);
      }
      resolvedRefIndexes.push(resolved);
    }
    for (let i = 0; i < resolvedRefIndexes.length; i++) {
      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);
      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];
    }
    if (basicArgTypes.length > MAX_APP_ARGS - 1) {
      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
      basicArgValues.push(lastArgTupleValues);
    }
    const appArgsEncoded = [method2.getSelector()];
    for (let i = 0; i < basicArgTypes.length; i++) {
      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));
    }
    const appCall = {
      txn: makeApplicationCallTxnFromObject({
        from: sender,
        appIndex: appID,
        appArgs: appArgsEncoded,
        accounts: foreignAccounts,
        foreignApps,
        foreignAssets,
        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
        approvalProgram,
        clearProgram,
        numGlobalInts,
        numGlobalByteSlices,
        numLocalInts,
        numLocalByteSlices,
        extraPages,
        lease,
        note,
        rekeyTo,
        suggestedParams
      }),
      signer
    };
    this.transactions.push(...txnArgs, appCall);
    this.methodCalls.set(this.transactions.length - 1, method2);
  }
  buildGroup() {
    if (this.status === AtomicTransactionComposerStatus.BUILDING) {
      if (this.transactions.length === 0) {
        throw new Error("Cannot build a group with 0 transactions");
      }
      if (this.transactions.length > 1) {
        assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
      }
      this.status = AtomicTransactionComposerStatus.BUILT;
    }
    return this.transactions;
  }
  async gatherSignatures() {
    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
      return this.signedTxns;
    }
    const txnsWithSigners = this.buildGroup();
    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
    const indexesPerSigner = /* @__PURE__ */ new Map();
    for (let i = 0; i < txnsWithSigners.length; i++) {
      const { signer } = txnsWithSigners[i];
      if (!indexesPerSigner.has(signer)) {
        indexesPerSigner.set(signer, []);
      }
      indexesPerSigner.get(signer).push(i);
    }
    const orderedSigners = Array.from(indexesPerSigner);
    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
    const signedTxns = txnsWithSigners.map(() => null);
    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
      const indexes = orderedSigners[signerIndex][1];
      const sigs = batchedSigs[signerIndex];
      for (let i = 0; i < indexes.length; i++) {
        signedTxns[indexes[i]] = sigs[i];
      }
    }
    if (!signedTxns.every((sig) => sig != null)) {
      throw new Error(`Missing signatures. Got ${signedTxns}`);
    }
    const txIDs = signedTxns.map((stxn, index) => {
      try {
        return decodeSignedTransaction(stxn).txn.txID();
      } catch (err) {
        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);
      }
    });
    this.signedTxns = signedTxns;
    this.txIDs = txIDs;
    this.status = AtomicTransactionComposerStatus.SIGNED;
    return signedTxns;
  }
  async submit(client) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Transaction group cannot be resubmitted");
    }
    const stxns = await this.gatherSignatures();
    await client.sendRawTransaction(stxns).do();
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    return this.txIDs;
  }
  async execute(client, waitRounds) {
    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
      throw new Error("Transaction group has already been executed successfully");
    }
    const txIDs = await this.submit(client);
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));
    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
    this.status = AtomicTransactionComposerStatus.COMMITTED;
    const confirmedRound = confirmedTxnInfo["confirmed-round"];
    const methodResults = [];
    for (const [txnIndex, method2] of this.methodCalls) {
      const txID = txIDs[txnIndex];
      const methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method: method2
      };
      try {
        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : await client.pendingTransactionInformation(txID).do();
        methodResult.txInfo = pendingInfo;
        if (method2.returns.type !== "void") {
          const logs = pendingInfo.logs || [];
          if (logs.length === 0) {
            throw new Error("App call transaction did not log a return value");
          }
          const lastLog = Buffer.from(logs[logs.length - 1], "base64");
          if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {
            throw new Error("App call transaction did not log a return value");
          }
          methodResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
          methodResult.returnValue = method2.returns.type.decode(methodResult.rawReturnValue);
        }
      } catch (err) {
        methodResult.decodeError = err;
      }
      methodResults.push(methodResult);
    }
    return {
      confirmedRound,
      txIDs,
      methodResults
    };
  }
};
AtomicTransactionComposer.MAX_GROUP_SIZE = 16;

// node_modules/algosdk/dist/esm/src/types/index.js
init_transactions();

// node_modules/algosdk/dist/esm/src/main.js
var SIGN_BYTES_PREFIX = Buffer.from([77, 88]);
var MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
function signTransaction(txn, sk) {
  if (typeof txn.from === "undefined") {
    const key = keyPairFromSecretKey(sk);
    txn.from = encodeAddress(key.publicKey);
  }
  const algoTxn = instantiateTxnIfNeeded(txn);
  return {
    txID: algoTxn.txID().toString(),
    blob: algoTxn.signTxn(sk)
  };
}
function signBid(bid, sk) {
  const signedBid = new Bid(bid);
  return signedBid.signBid(sk);
}
function signBytes(bytes, sk) {
  const toBeSigned = Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const sig = sign(toBeSigned, sk);
  return sig;
}
function verifyBytes(bytes, signature, addr) {
  const toBeVerified = Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const pk = decodeAddress(addr).publicKey;
  return verify(toBeVerified, signature, pk);
}
function encodeObj(o) {
  return new Uint8Array(encode2(o));
}
function decodeObj(o) {
  return decode2(o);
}
var ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
var ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);
var LogicTemplates = LogicTemplatesCommonJSExport.default;

// node_modules/algosdk/dist/esm/index.js
__reExport(esm_exports, main_exports);
var esm_default = main_exports;

// dep:algosdk
__reExport(algosdk_exports, esm_exports);
var algosdk_default = esm_default;
export {
  ABIAddressType,
  ABIArrayDynamicType,
  ABIArrayStaticType,
  ABIBoolType,
  ABIByteType,
  ABIContract,
  ABIInterface,
  ABIMethod,
  ABIReferenceType,
  ABIStringType,
  ABITransactionType,
  ABITupleType,
  ABIType,
  ABIUfixedType,
  ABIUintType,
  ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE,
  AlgodClient as Algodv2,
  AtomicTransactionComposer,
  AtomicTransactionComposerStatus,
  DryrunResult,
  ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG,
  IndexerClient as Indexer,
  intDecoding_default as IntDecoding,
  Kmd,
  LENGTH_ENCODE_BYTE_SIZE,
  LogicSigAccount,
  LogicTemplates,
  MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG,
  OnApplicationComplete,
  SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE,
  SourceMap,
  Transaction,
  TransactionType,
  abiCheckTransactionType,
  abiTypeIsReference,
  abiTypeIsTransaction,
  algosToMicroalgos,
  appendSignMultisigTransaction,
  appendSignRawMultisigSignature,
  assignGroupID,
  bigIntToBytes,
  bytesToBigInt,
  computeGroupID,
  createDryrun,
  createMultisigTransaction,
  decodeAddress,
  decodeObj,
  decodeSignedTransaction,
  decodeUint64,
  decodeUnsignedTransaction,
  algosdk_default as default,
  encodeAddress,
  encodeObj,
  encodeUint64,
  encodeUnsignedTransaction,
  generateAccount,
  getApplicationAddress,
  getMethodByName,
  instantiateTxnIfNeeded,
  isTransactionWithSigner,
  isValidAddress,
  logicSigFromByte,
  makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxn,
  makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxn,
  makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxn,
  makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxn,
  makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxn,
  makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner,
  makeKeyRegistrationTxn,
  makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSig,
  makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner,
  makePaymentTxn,
  makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic,
  mergeMultisigTransactions,
  microalgosToAlgos,
  mnemonicFromSeed,
  mnemonicToMasterDerivationKey,
  mnemonicToSecretKey,
  types_exports as modelsv2,
  multisigAddress,
  secretKeyToMnemonic,
  seedFromMnemonic,
  signBid,
  signBytes,
  signLogicSigTransaction,
  signLogicSigTransactionObject,
  signMultisigTransaction,
  signTransaction,
  tealSign,
  tealSignFromProgram,
  verifyBytes,
  verifyMultisig,
  waitForConfirmation
};
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=algosdk.js.map
